{"meta":{"title":"Taroballz StudyNotes","subtitle":null,"description":null,"author":"Taroballz","url":"http://www.taroballz.com","root":"/"},"pages":[{"title":"","date":"2019-07-08T18:05:00.000Z","updated":"2019-10-07T08:22:29.000Z","comments":true,"path":"about/index.html","permalink":"http://www.taroballz.com/about/index.html","excerpt":"","text":"About Me Personal Information Name： Yuan-Yu Chen (陳元裕) Nick： Taroballz Email：curtis992250@gmail.com Education Doctoral program National Chung Cheng University Chemistry &amp; BioChemistry (2017.02 ~ ) M.S National Chung Cheng University Chemistry &amp; BioChemistry (2014.09 ~ 2016.06) B.S Tunghai University Chemistry (2010.09 ~ 2014.06) Area of ExpertiseChemistry Analytical chemistry Microfludic system designed Pathogen(Virus, bacteria…) detection Programming languages Python, Golang, Arduino, LabVIEW, Database：MySQL,Mongodb Machine Learning (studying…) Interests Technology &amp; Programing Movie Shopping Projects &amp; Published papers程式相關作品集請參考Github連結 Security shecodject[開發&amp;維護] PSHinjector[開發&amp;維護] Data processing for Chemistry FOPPRplot[開發&amp;維護] Stock Stock_ROI_Caculator[開發&amp;維護] My Research Arduino-Cotrol-Interface-for-Electro-Wetting[開發&amp;維護] PyEWIOACP[開發&amp;維護] For Fun CCUHours[開發&amp;維護] Published papers Corona-induced micro-centrifugal flows for concentration of Neisseria and Salmonella bacteria prior to their quantitation using antibody-functionalized SERS-reporter nanobeads Development of Coplanar Electro-Wetting Based Microfluidic Sorter to Select Micro-Particles in High Volume Throughput at Milliliter Amount within Twenty Minutes Electrohydrodynamically enhanced drying droplets for concentration of Salmonella bacteria prior to their detections using antibody-functionalized SERS-reporter submicron beads"},{"title":"Categories","date":"2016-08-16T07:00:44.000Z","updated":"2018-04-03T19:06:16.000Z","comments":false,"path":"categories/index.html","permalink":"http://www.taroballz.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-08-11T04:12:45.000Z","updated":"2018-04-03T19:05:28.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.taroballz.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Tensorflow2-tensorflow-keras分類模型實踐","slug":"DL_Tensorflow_keras_classifier","date":"2020-02-23T13:50:00.000Z","updated":"2020-02-23T17:15:31.000Z","comments":true,"path":"2020/02/23/DL_Tensorflow_keras_classifier/","link":"","permalink":"http://www.taroballz.com/2020/02/23/DL_Tensorflow_keras_classifier/","excerpt":"Introduction以下將使用tensorflow-keras實踐深度學習示例 (基於fashion_mnist數據集)","text":"Introduction以下將使用tensorflow-keras實踐深度學習示例 (基於fashion_mnist數據集) Example","categories":[{"name":"tensorflow深度學習","slug":"tensorflow深度學習","permalink":"http://www.taroballz.com/categories/tensorflow深度學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://www.taroballz.com/tags/tensorflow/"},{"name":"深度學習(Deep Learning)","slug":"深度學習-Deep-Learning","permalink":"http://www.taroballz.com/tags/深度學習-Deep-Learning/"},{"name":"2020","slug":"2020","permalink":"http://www.taroballz.com/tags/2020/"}]},{"title":"Tensorflow2-tensorflow-keras","slug":"DL_Tensorflow_keras","date":"2020-02-23T10:10:00.000Z","updated":"2020-02-23T10:44:17.000Z","comments":true,"path":"2020/02/23/DL_Tensorflow_keras/","link":"","permalink":"http://www.taroballz.com/2020/02/23/DL_Tensorflow_keras/","excerpt":"Introduction of keras keras是基於python的高級神經網路的API 其必須要有後端才可以運行 支持Tensorflow、CNTK、Theano為後端運行 後端是可以切換的，現在多用Tensorflow 因其圖像化功能優異，極方便於快速實驗 幫助用戶以最少的時間驗證自己的想法","text":"Introduction of keras keras是基於python的高級神經網路的API 其必須要有後端才可以運行 支持Tensorflow、CNTK、Theano為後端運行 後端是可以切換的，現在多用Tensorflow 因其圖像化功能優異，極方便於快速實驗 幫助用戶以最少的時間驗證自己的想法 Introduction of Tensorflow-keras Tensorflow對keras API規範的實現 以Tensorflow為後端的keras 和 Tensorflow-keras是兩碼子事 Tensorflow-keras與Tensorflow 結合更加緊密 其實現在tf.keras空間下 Tf.keras 和 keras的聯繫 基於同一套API 原keras程序可以通過改導入(import…)的方式輕鬆轉為tf.keras程序 反之要轉為keras的代碼可能不成立 tf.keras有其他特性 相同的JSON和HDF5模型序列化格式和語議 tf.keras 和 keras的區別 tf.keras全面支持eager mode 若只是用keras.Sequential和keras.ModelAPI時並沒有影響 但若是需要自定義Model內部運算邏輯的時候便會受到影響 tf.keras可以使用tensorflow底層的API，以便於自定義keras的model.fit等抽象 適用於研究人員 tf.keras支持基於tf.data的模型訓練 tf.keras支持TPU訓練 tf.keras支持tf.distribution中的分布式策略 tf.keras可以與Tensorflow中的estimator集成 tf.keras可以保存為SavedModel 如果選擇？ 如果想用tf.keras的任何一個特性，請選擇tf.keras 注重後端互換性的話，請選擇keras","categories":[{"name":"tensorflow深度學習","slug":"tensorflow深度學習","permalink":"http://www.taroballz.com/categories/tensorflow深度學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://www.taroballz.com/tags/tensorflow/"},{"name":"深度學習(Deep Learning)","slug":"深度學習-Deep-Learning","permalink":"http://www.taroballz.com/tags/深度學習-Deep-Learning/"},{"name":"2020","slug":"2020","permalink":"http://www.taroballz.com/tags/2020/"}]},{"title":"Golang-select語句","slug":"Go_select","date":"2020-01-14T16:00:00.000Z","updated":"2020-01-14T17:25:58.000Z","comments":true,"path":"2020/01/15/Go_select/","link":"","permalink":"http://www.taroballz.com/2020/01/15/Go_select/","excerpt":"初識 select是golang中一種控制結構 可透過select語句監聽在channel上的數據流動狀態 類似於switch語句，但是select會隨機執行任何一個可運行的case 沒有case可運行時，則阻塞；直到有case可運行","text":"初識 select是golang中一種控制結構 可透過select語句監聽在channel上的數據流動狀態 類似於switch語句，但是select會隨機執行任何一個可運行的case 沒有case可運行時，則阻塞；直到有case可運行 語法結構類似switch，仍存在case語句和default語句12345678910select &#123; case communication clause: statement(s) case communication clase: statement(s) //可定義任意數量的case default: //可選擇使用 statments(s)&#125; 每一個case都是一個通信 必須為對channel操作(對channel發送數據 or 從channel中獲取數據 皆可) (重要)如果有多個case都可運行，select會隨機地選出一個執行，其他case便不會執行 否則： 如果有default語句，則執行該語句 無default語句時，select將阻塞，直到某個通信可以運行 Example I:1234567891011121314151617181920package mainimport ( \"fmt\" \"time\")func main()&#123; timer := time.NewTimer(1*time.Second) timer2 := time.NewTimer(2*time.Second) for i:=0;i&lt;2;i++&#123; select &#123; case &lt;-timer.C: fmt.Println(\"1\") case &lt;-timer2.C: fmt.Println(\"2\") &#125; &#125;&#125; Result1212 Example II:12345678910111213141516171819202122232425262728293031package mainimport ( \"fmt\" \"time\")func main()&#123; ch1 := make(chan int,1) ch2 := make(chan int) go func()&#123; for &#123; ch2 &lt;- 100 time.Sleep(100*time.Millisecond) &#125; &#125;() for &#123; select &#123; case ch1 &lt;- 1: fmt.Println(\"1\") time.Sleep(1*time.Second) case num := &lt;- ch1: fmt.Println(\"get data from ch1\",num) case &lt;- ch2 : fmt.Println(\"2\") &#125; &#125;&#125; Result1234567891011121314151617181912get data from ch1 11get data from ch1 121get data from ch1 1212get data from ch1 112get data from ch1 11get data from ch1 112","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2020","slug":"2020","permalink":"http://www.taroballz.com/tags/2020/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"goroutine","slug":"goroutine","permalink":"http://www.taroballz.com/tags/goroutine/"}]},{"title":"Golang多線程-線程同步(sync)包-WaitGroup","slug":"Go_sync_Waitgroup","date":"2020-01-01T16:00:00.000Z","updated":"2020-01-02T16:11:19.000Z","comments":true,"path":"2020/01/02/Go_sync_Waitgroup/","link":"","permalink":"http://www.taroballz.com/2020/01/02/Go_sync_Waitgroup/","excerpt":"WaitGroup 其位於較低級的同步包sync WaitGroup為一個結構體；其實例化的用途為等待一組goroutine的集合 完成工作 WaitGroup中都有一個counter(計數器)用來記錄等待goroutine的數量","text":"WaitGroup 其位於較低級的同步包sync WaitGroup為一個結構體；其實例化的用途為等待一組goroutine的集合 完成工作 WaitGroup中都有一個counter(計數器)用來記錄等待goroutine的數量 Add用來設置WaitGroup實例中goroutine counter的數量 在執行goroutine之前先創建對象並加入欲管理的goroutine的數量 counter的值為0時代表 等待阻塞的goroutine皆已經被釋放 若是counter的值為負數，則會panic Wait等待其它線程完成，並進入阻塞狀態 當實例化的WaitGroup的counter數為0時就會解除當前線程的阻塞狀態 Done讓實例化的WaitGroup對象數值減 1 其內部代碼就是調用了Add方法只是將其參數(delta)設為 -1123func (wg *WaitGroup) Done()&#123; wg.Add(-1)&#125; Example Code12345678910111213141516171819202122232425262728293031323334353637package mainimport ( \"fmt\" \"sync\")//創建WaitGroup的實例對象var wg sync.WaitGroupfunc main()&#123; wg.Add(2) go PrintNum() go PrintByte() fmt.Println(\"Main Goroutine 將進入阻塞阻塞狀態，等待子goroutine完成工作\") wg.Wait() //main goroutine進入阻塞 fmt.Println(\"子goroutine工作已全數完成，main goroutine解除阻塞\")&#125;func PrintNum() &#123; for i:=0;i&lt;10;i++ &#123; fmt.Println(\"PrintNum Gorotine\",i) &#125; wg.Done() //給WaitGroup的實例化對象counter數值減1，同wg.Add(-1)&#125;func PrintByte() &#123; for i:=0;i&lt;10;i++ &#123; char := byte(65 + i) fmt.Println(string(char)) &#125; wg.Done()&#125; Result12345678910111213141516171819202122Main Goroutine 將進入阻塞阻塞狀態，等待子goroutine完成工作ABCDEFGHIJPrintNum Gorotine 0PrintNum Gorotine 1PrintNum Gorotine 2PrintNum Gorotine 3PrintNum Gorotine 4PrintNum Gorotine 5PrintNum Gorotine 6PrintNum Gorotine 7PrintNum Gorotine 8PrintNum Gorotine 9子goroutine工作已全數完成，main goroutine解除阻塞","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2020","slug":"2020","permalink":"http://www.taroballz.com/tags/2020/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"多線程","slug":"多線程","permalink":"http://www.taroballz.com/tags/多線程/"},{"name":"goroutine","slug":"goroutine","permalink":"http://www.taroballz.com/tags/goroutine/"},{"name":"線程同步(sync)","slug":"線程同步-sync","permalink":"http://www.taroballz.com/tags/線程同步-sync/"}]},{"title":"深度學習-神經網路基礎","slug":"DL_NeuralNetwork_intro","date":"2019-07-30T16:12:00.000Z","updated":"2019-08-28T15:07:57.000Z","comments":true,"path":"2019/07/31/DL_NeuralNetwork_intro/","link":"","permalink":"http://www.taroballz.com/2019/07/31/DL_NeuralNetwork_intro/","excerpt":"Introduction 神經網路是為了模擬神經元傳遞的過程 不同結構的神經網路解決不同的問題","text":"Introduction 神經網路是為了模擬神經元傳遞的過程 不同結構的神經網路解決不同的問題 感知器(Perceptron)有n個輸入數據，通過權重與各數據之間的計算和，比較激活函數結果，得出輸出 應用：很容易解決與(and)、或(or)問題 常用來解決分類問題 一個感知器通常建立一條直線 單個感知器解決不了的問題，可以增加感知機的數目 結構 其中$f$為閾值(threshold) 大於$f$或是小於$f$則屬於不同類別 神經網路的特點 輸入向量的維度和輸入神經元的個數相同 每個連接都有個權值 同一層神經元之間沒有連接 由輸入層、隱層、輸出層組成 最後一層與第前一層的所有神經元連接，也叫全連接 其最後有多少全連接神經元，代表共有多少輸出類別 神經網路組成 結構(Architecture)：例如神經網路中權重、神經元等等 激活函數(Activity Rule)： 學習規則(Learning Rule)：學習規則指定了網路中的權重如何隨著時間推進而調整。(反向傳播算法) 神經網絡的多分類問題輸入一個樣本，並得出這個樣本屬於全部每一個類別的概率，並比較哪個概率較大決定類別 其有多少類別輸出就為多少個類別 神經網路API在使用tensorflow時，tf.nn、tf.layers、tf.contrib模塊有很多功能式重複的 tf.nn提供神經網路相關操作的支持，包括卷積操作(conv)、池化操作(pooling)、歸一化、損失(loss)、分類操作、embedding、RNN、Evaluation tf.layers主要提供的高層神經網路，主要和卷積相關，對tf.nn進一步的封裝 tf.contrib(最高層的接口)tf.contrib.layers提供夠將計算圖中的網絡層、正則化、摘要操作。是構建計算圖的高級操作，但是tf.contrib包不穩定以及擁有一些實驗性的代碼 SoftMax回歸公式： S_i = \\frac{e^i}{\\sum_je^j} 其經過softmax後的結果類似邏輯回歸為一概率值 所有類別的概率值相加都等於1 真實類別的值為one-hot編碼形式 全連接-從輸入直接到輸出 特徵加權： tf.matmul(a, b, name=None) + $bias$ return: 全連接的結果，供交叉損失運算 不需要激活函數(因為是最後的輸出) 神經網絡策略-交叉熵損失類似邏輯回歸-對數似然損失的推廣 H_{y'}(y) = - \\sum_{i}y_{i}'log(y_i) $y_{i}’$ 為真實結果，$y_i$為softmax後結果 一個樣本就有一個交叉熵損失 softmax計算出來的概率值 越接近真實值類別onehot編碼的話 表示損失越小 SoftMax計算、交叉熵API求所有樣本的損失，然後求平均損失 tf.nn.softmax_cross_entropy_with_logits(labels=None,logits=None, name=None) 計算logits和labels之間的交叉損失熵 labels:標籤值(真實值) logits:樣本加權之後的值(預測值) return:返回損失列表 tf.reduce_mean(input_tensor) 計算張量的尺寸的元素平均值 神經網絡優化-反向傳播算法就是梯度下降 損失下降APItf.train.GradientDescentOptimizer(learning_rate) 用於梯度下降優化 learning_rate:學習率 minimize(loss)：最小化損失 return:梯度下降op 準確率計算API equal_list = tf.equal(tf.argmax(y,1),tf.argmax(y_label,1)) 找尋特徵得到概率最大值的index，如果與onehot編碼label為1的index相同則為1，不同則為0 tf.argmax(data,row or column) 返回data中的最大值index 第二個參數為0代表取列中最大值的索引，1則為行中最大值的索引 accuracy = tf.reduce_mean(tf.cast(equal_list, tf.float32)) mnist dataset的基本操作https://github.com/curtis992250/MachineLearning_StudyNote/blob/master/mnist.ipynb Example 單層（全連接層）實現手寫數字識別123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115import tensorflow as tffrom tensorflow.examples.tutorials.mnist import input_data# 定義命令行參數FLAGS = tf.app.flags.FLAGStf.app.flags.DEFINE_integer(\"is_train\",1,\"指定程序為預測或是訓練模型\")def full_connected(): #獲取真實的數據 mnist = input_data.read_data_sets(\"./Training_Data/mnistData\", one_hot=True) # 1. 建立數據的佔位符 x[None, 781] y_true[None, 10] with tf.variable_scope(\"data\"): x = tf.placeholder(tf.float32, [None,784]) y_true = tf.placeholder(tf.int32, [None,10]) # 2.建立一個全連接層的神經網絡 weight[784,10] bias[10] with tf.variable_scope(\"full_connected_model\"): # 隨機初始化權重和偏置 weight = tf.Variable(tf.random_normal([784,10],mean=0.0, stddev=1.0,name=\"weight\")) bias = tf.Variable(tf.constant(0.0,shape=[10])) # 預測None個樣本的輸出結果 x[None, 784] * w[784, 10] + b[10] = result[None,10] y_predict = tf.matmul(x, weight) + bias #3. 求出所有樣本的損失，然後求平均值 with tf.variable_scope(\"soft_cross\"): # 求平均交叉熵損失 loss_list = tf.nn.softmax_cross_entropy_with_logits(labels=y_true, logits=y_predict) loss = tf.reduce_mean(loss_list) # 4. 梯度下降求出損失 with tf.variable_scope(\"optimizer\"): train_op = tf.train.GradientDescentOptimizer(learning_rate=0.1).minimize(loss=loss) # 5. 計算準確率 with tf.variable_scope(\"calc_accuracy\"): equal_list = tf.equal(tf.arg_max(y_true,1), tf.arg_max(y_predict,1)) # equal_list 應有None個樣本類似 [0,1,0,0,1,1,1,1,....] accuracy = tf.reduce_mean(tf.cast(equal_list, tf.float32)) # 收集單個數字的變量 tf.summary.scalar(\"losses\", loss) tf.summary.scalar(\"accuracy\", accuracy) # 收集高維度的變量 tf.summary.histogram(\"weights\", weight) tf.summary.histogram(\"biases\",bias) # 定義一個初始化變量的op init_op = tf.global_variables_initializer() # 定義一個合併變量的op merged = tf.summary.merge_all() # 創建一個saver用於保存模型(Save, restore方法) saver = tf.train.Saver() # 開啟會話訓練 with tf.Session() as sess: #初始化變量 sess.run(init_op) # 建立events文件然後寫入 filewriter = tf.summary.FileWriter(\"./summary/number_recognize\",graph=sess.graph) if FLAGS.is_train == True: #迭代步數去訓練，更新參數預測 for i in range(2000): #取出真實存在的特徵值和目標值 mnist_x, mnist_y = mnist.train.next_batch(50) #運行train_op訓練 sess.run(train_op, feed_dict=&#123;x: mnist_x,y_true: mnist_y&#125;) # 寫入每步訓練的值 summary = sess.run(merged, feed_dict=&#123;x: mnist_x,y_true: mnist_y&#125;) filewriter.add_summary(summary,i) print(\"訓練第%d步，準確率為：%f\"%(i,sess.run(accuracy, feed_dict=&#123;x: mnist_x,y_true: mnist_y&#125;))) else: # 訓練結束後保存模型 saver.save(sess,\"./ckpt/fc_model\") else: # 加載模型 saver.restore(sess,\"./ckpt/fc_model\") # 要是is_train為則做出預測 for i in range(100): #每次測試一張圖片[0,0,0,0,0,0,1,0,0,0] x_test, y_test = mnist.test.next_batch(1) print(\"第%d張圖片，手寫數字圖片為%d，預測結果是:%d\"%(i, tf.argmax(y_test,1).eval(), tf.argmax(sess.run(y_predict,feed_dict=&#123;x: x_test,y_true: y_test&#125;),1).eval() ))if __name__ == '__main__': full_connected()","categories":[{"name":"tensorflow深度學習","slug":"tensorflow深度學習","permalink":"http://www.taroballz.com/categories/tensorflow深度學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://www.taroballz.com/tags/tensorflow/"},{"name":"2019","slug":"2019","permalink":"http://www.taroballz.com/tags/2019/"},{"name":"深度學習(Deep Learning)","slug":"深度學習-Deep-Learning","permalink":"http://www.taroballz.com/tags/深度學習-Deep-Learning/"}]},{"title":"深度學習-tensorflow基礎-讀取數據-API應用-二進制文件讀取","slug":"DL_BinaryReadAPI","date":"2019-07-29T14:16:00.000Z","updated":"2019-07-30T15:29:20.000Z","comments":true,"path":"2019/07/29/DL_BinaryReadAPI/","link":"","permalink":"http://www.taroballz.com/2019/07/29/DL_BinaryReadAPI/","excerpt":"Introduction 圖片也算是一種二進制文件格式 將進行CIFAR-10二進制數據讀取 https://www.cs.toronto.edu/~kriz/cifar.html 全部共60000萬張圖片，每張圖片為32x32彩色圖像所組成 50000個訓練集及10000個測試集 五個訓練批次(data_batch_1.bin, data_batch_2.bin…) 一個測試批次(test_batch.bin) 其有10個類別(飛機、汽車、鳥…等)的圖片 每個類別共6000個圖片 文件中的格式都是第1個像素為標籤(0~9) 剩下的 3072 (3*32*32)像素為特徵 前1024像素為red_channel, 下1024像素為green_channel, 最後1024像素為blue_channel","text":"Introduction 圖片也算是一種二進制文件格式 將進行CIFAR-10二進制數據讀取 https://www.cs.toronto.edu/~kriz/cifar.html 全部共60000萬張圖片，每張圖片為32x32彩色圖像所組成 50000個訓練集及10000個測試集 五個訓練批次(data_batch_1.bin, data_batch_2.bin…) 一個測試批次(test_batch.bin) 其有10個類別(飛機、汽車、鳥…等)的圖片 每個類別共6000個圖片 文件中的格式都是第1個像素為標籤(0~9) 剩下的 3072 (3*32*32)像素為特徵 前1024像素為red_channel, 下1024像素為green_channel, 最後1024像素為blue_channel 構造圖片文件隊列與讀取文字文件的文件隊列相同 構造讀取器 讀取每個記錄是固定數量bytes的二進制文件 tf.FixedLengthRecordReader(record_bytes) record_bytes:整型參數，指定每次讀取(一個樣本)為多少bytes 返回一個讀取器實例 method read(file_queue)：輸出將是一個文件名(key)和該文件的內容(value) 二進制文件解碼tf.decode_raw(bytes, out_type, little_endian=None, name=None) bytes:欲解碼的數據，也就是read方法返回的value 將bytes轉換為一個數字向量表示 bytes原本為一字符串類型的張量 與函數tf.FixedLengthRecordReader()搭配使用 讀取後優先為uint8類型，可改變out_type參數改變成不同類型 其解碼出來的shape並不是固定，所以須自己額外去固定形狀 Example1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import tensorflow as tfimport os# 定義cifar數據等命令行參數FLAGS = tf.app.flags.FLAGStf.app.flags.DEFINE_string(\"cifar_dir\",\"./cifar-10-batches-bin/\",\"where's cifar data dir?\")class CifarRead(object): def __init__(self,filelist): # 文件列表 self.filelist = filelist # 定義讀取圖片的屬性 self.width = 32 self.height = 32 self.channel = 3 # 二進制文件圖片的bytes self.label_pixel = 1 # 標籤的bytes self.image_pixel = self.width * self.height * self.channel self.whole_image = self.label_pixel + self.image_pixel def read_and_decode(self): # 1. 構造文件名隊列 file_queue = tf.train.string_input_producer(self.filelist) # 2. 構造二進制文件讀取器，讀取內容，cifar-10每個樣本為3073bytes binary_reader = tf.FixedLengthRecordReader(record_bytes=self.whole_image) key, value = binary_reader.read(file_queue) # 3. 解碼內容（進行二進制文件內容的解碼） label_image = tf.decode_raw(value, out_type=tf.uint8) # 4. 分割圖片和標籤數據，切出特徵值及目標值 label = tf.slice(label_image, [0], [self.label_pixel]) image = tf.slice(label_image, [self.label_pixel], [self.image_pixel]) # 將label轉換為int32類型 label = tf.cast(label,tf.int32) # 5. 對圖片的特徵數據進行形狀的改變 [3072] ---&gt; [3, 32, 32] image_reshape = tf.reshape(image,[self.channel, self.height, self.width ]) # 6. 批處理數據 image_batch, label_batch = tf.train.batch([image_reshape, label], batch_size=10, num_threads=1, capacity=10) print(image_batch, label_batch) return image_batch, label_batchif __name__ == '__main__': # 1. 找到文件，放入列表 路徑+文件名字 --&gt; 列表當中 file_name = os.listdir(FLAGS.cifar_dir) # 對二進制文件來說我們只要裡面的bin文件 file_list = [os.path.join(FLAGS.cifar_dir, file) for file in file_name if file.endswith('bin')] # 實例化我們自定義CifarRead實例用於讀取使用 cfR = CifarRead(file_list) image_batch, label_batch = cfR.read_and_decode() with tf.Session() as sess: # 定義一個線程協調器 coord = tf.train.Coordinator() # 開啟讀文件的線程 threads = tf.train.start_queue_runners(sess, coord=coord) # 顯示讀取內容 print(sess.run([image_batch, label_batch])) # 回收子線程 coord.request_stop() coord.join(threads) Result123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317Tensor(&quot;batch:0&quot;, shape=(10, 32, 32, 3), dtype=uint8) Tensor(&quot;batch:1&quot;, shape=(10, 1), dtype=int32)[array([[[[ 26, 17, 13], [ 13, 13, 14], [ 14, 15, 14], ..., [ 12, 15, 21], [ 36, 26, 22], [ 17, 25, 31]], [[ 13, 17, 14], [ 14, 11, 9], [ 19, 18, 11], ..., [174, 229, 249], [251, 244, 248], [175, 29, 11]], [[ 17, 17, 16], [ 14, 12, 11], [ 10, 11, 12], ..., [251, 252, 252], [242, 240, 160], [ 18, 14, 16]], ..., [[105, 40, 58], [ 79, 79, 84], [ 47, 5, 0], ..., [ 69, 20, 21], [ 21, 20, 23], [ 26, 29, 25]], [[139, 168, 57], [ 4, 8, 21], [ 34, 72, 105], ..., [142, 29, 20], [ 21, 25, 25], [ 44, 34, 25]], [[137, 95, 90], [ 57, 46, 55], [ 28, 64, 126], ..., [237, 144, 33], [ 29, 46, 28], [ 27, 26, 27]]], [[[ 94, 101, 95], [ 94, 94, 97], [111, 142, 166], ..., [133, 136, 138], [140, 142, 145], [146, 147, 123]], [[ 84, 88, 101], [102, 100, 99], [109, 126, 146], ..., [154, 132, 124], [135, 139, 141], [144, 145, 121]], [[ 90, 85, 85], [119, 167, 218], [224, 219, 207], ..., [204, 189, 161], [113, 107, 117], [137, 137, 115]], ..., [[193, 191, 178], [167, 165, 170], [176, 185, 193], ..., [181, 176, 175], [182, 181, 174], [160, 140, 117]], [[197, 198, 190], [180, 178, 182], [183, 181, 182], ..., [175, 169, 163], [161, 151, 144], [141, 142, 117]], [[204, 207, 200], [185, 177, 178], [181, 189, 195], ..., [145, 147, 150], [152, 163, 174], [182, 184, 155]]], [[[183, 158, 166], [167, 169, 171], [163, 163, 160], ..., [ 69, 61, 61], [ 57, 63, 75], [ 63, 53, 60]], [[119, 86, 82], [132, 225, 181], [ 90, 76, 91], ..., [ 59, 67, 75], [ 67, 55, 54], [ 59, 48, 46]], [[103, 74, 91], [161, 225, 230], [170, 108, 99], ..., [ 62, 70, 80], [ 65, 84, 115], [143, 166, 148]], ..., [[105, 75, 91], [ 99, 79, 77], [ 81, 76, 85], ..., [ 86, 82, 76], [ 65, 61, 67], [ 57, 56, 67]], [[136, 97, 76], [ 79, 80, 75], [ 75, 76, 76], ..., [ 74, 68, 70], [ 81, 94, 82], [ 77, 62, 78]], [[103, 87, 105], [107, 111, 103], [ 94, 84, 104], ..., [174, 177, 227], [250, 250, 250], [250, 250, 250]]], ..., [[[225, 214, 190], [167, 169, 184], [231, 254, 218], ..., [160, 163, 167], [165, 161, 157], [154, 153, 157]], [[123, 129, 118], [ 78, 91, 166], [170, 142, 125], ..., [167, 171, 179], [185, 175, 169], [167, 165, 165]], [[ 48, 63, 125], [159, 109, 112], [167, 167, 149], ..., [169, 177, 181], [192, 196, 185], [180, 174, 178]], ..., [[ 50, 28, 24], [ 17, 13, 18], [ 34, 71, 95], ..., [140, 125, 153], [181, 159, 154], [182, 193, 195]], [[ 39, 37, 46], [ 50, 49, 45], [ 45, 55, 61], ..., [127, 123, 119], [120, 123, 125], [121, 114, 114]], [[117, 115, 113], [115, 125, 128], [126, 128, 132], ..., [123, 122, 117], [114, 120, 128], [144, 167, 171]]], [[[ 82, 69, 63], [ 65, 68, 65], [ 58, 54, 51], ..., [ 53, 54, 39], [ 49, 68, 70], [ 69, 77, 83]], [[ 76, 74, 59], [ 53, 56, 61], [ 61, 57, 50], ..., [ 39, 54, 56], [ 42, 50, 65], [ 73, 78, 83]], [[ 54, 63, 66], [ 56, 54, 56], [ 55, 56, 66], ..., [ 33, 44, 54], [ 61, 55, 59], [ 51, 49, 70]], ..., [[ 73, 85, 87], [ 78, 71, 79], [103, 126, 124], ..., [ 78, 65, 72], [ 71, 57, 61], [ 79, 65, 73]], [[ 61, 47, 76], [ 85, 88, 68], [ 82, 105, 88], ..., [ 27, 40, 60], [ 62, 62, 78], [ 67, 61, 64]], [[ 81, 70, 65], [ 66, 85, 96], [ 91, 110, 118], ..., [ 55, 69, 82], [ 84, 80, 78], [ 67, 57, 68]]], [[[198, 173, 144], [124, 96, 58], [ 52, 56, 52], ..., [ 47, 54, 56], [ 53, 51, 46], [ 46, 40, 45]], [[185, 158, 134], [124, 100, 55], [ 49, 47, 46], ..., [ 41, 40, 41], [ 38, 37, 43], [ 55, 58, 53]], [[172, 151, 126], [114, 88, 51], [ 48, 48, 50], ..., [ 42, 43, 42], [ 46, 45, 40], [ 43, 41, 37]], ..., [[142, 120, 108], [102, 74, 46], [ 44, 45, 44], ..., [ 56, 39, 34], [ 30, 33, 51], [ 61, 52, 42]], [[146, 121, 107], [ 94, 68, 44], [ 39, 37, 39], ..., [ 65, 55, 42], [ 56, 51, 43], [ 58, 57, 44]], [[156, 126, 92], [ 64, 60, 41], [ 37, 36, 35], ..., [ 40, 45, 46], [ 49, 50, 49], [ 40, 31, 26]]]], dtype=uint8), array([[8], [5], [0], [6], [9], [2], [8], [3], [6], [2]], dtype=int32)]","categories":[{"name":"tensorflow深度學習","slug":"tensorflow深度學習","permalink":"http://www.taroballz.com/categories/tensorflow深度學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://www.taroballz.com/tags/tensorflow/"},{"name":"2019","slug":"2019","permalink":"http://www.taroballz.com/tags/2019/"},{"name":"深度學習(Deep Learning)","slug":"深度學習-Deep-Learning","permalink":"http://www.taroballz.com/tags/深度學習-Deep-Learning/"}]},{"title":"機器學習-樣本不均衡","slug":"ML_sample_notbalance","date":"2019-07-04T12:06:10.000Z","updated":"2019-07-04T12:24:03.000Z","comments":true,"path":"2019/07/04/ML_sample_notbalance/","link":"","permalink":"http://www.taroballz.com/2019/07/04/ML_sample_notbalance/","excerpt":"Introduction樣本不均衡代表在某一類數據集中，Label其中一類佔有很大的比例 通常會使用上採樣來解決問題 將較少類的樣本增加到與較多類的樣本一樣多","text":"Introduction樣本不均衡代表在某一類數據集中，Label其中一類佔有很大的比例 通常會使用上採樣來解決問題 將較少類的樣本增加到與較多類的樣本一樣多 imblearnimblearn是專門用來處理不平衡數據集的庫，性能較sklearn高 也需使用fit_sample方法進行擬合，用法與sklearn相近安裝1conda install -c glemaitre imbalanced-learn or 1pip install imblearn 上採樣釋例1234from imblearn.over_sampling iimport SMOTEsm = SMOTE(random_state=42) #實例化X,y = sm.fit_sample(X,y) #進行上採樣的轉換 X,y 可為pandas.DataFrame 或是 pandas.Series 類型","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2019","slug":"2019","permalink":"http://www.taroballz.com/tags/2019/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"}]},{"title":"機器學習-邏輯回歸的特徵工程","slug":"ML_FeatureEnginering_for_LogisticRegression","date":"2019-06-25T16:37:00.000Z","updated":"2019-06-26T15:03:53.000Z","comments":true,"path":"2019/06/26/ML_FeatureEnginering_for_LogisticRegression/","link":"","permalink":"http://www.taroballz.com/2019/06/26/ML_FeatureEnginering_for_LogisticRegression/","excerpt":"Introduction 在進行邏輯回歸模型訓練時，通常需要對數據進行降維 在高維(&gt;1000個)特徵情況下，可先使用特徵選擇的演算法幫助我們篩選特徵，在根據自己相關的業務常識選擇更為相關的特徵 在邏輯回歸中，一般不使用PCA和SVD的降維演算法 會抹滅特徵的可解釋性 降維後會無法解釋特徵與Label的關係 在不需探究特徵與標籤之間關係的線性數據上，仍可使用 著重於對測試樣本進行分類時，可使用 在邏輯回歸中，前幾章提到的特徵選擇方法都可以使用","text":"Introduction 在進行邏輯回歸模型訓練時，通常需要對數據進行降維 在高維(&gt;1000個)特徵情況下，可先使用特徵選擇的演算法幫助我們篩選特徵，在根據自己相關的業務常識選擇更為相關的特徵 在邏輯回歸中，一般不使用PCA和SVD的降維演算法 會抹滅特徵的可解釋性 降維後會無法解釋特徵與Label的關係 在不需探究特徵與標籤之間關係的線性數據上，仍可使用 著重於對測試樣本進行分類時，可使用 在邏輯回歸中，前幾章提到的特徵選擇方法都可以使用 嵌入法 L1 正則化會使得部分特徵參數(權重)$\\theta$($w$)變為0，因此L1正則化可以用來做特徵選擇 結合特徵選擇-嵌入法模塊(sklearn.feature_selection.SelectFromModel) 邏輯回歸預設是使用 L1,L2懲罰項來進行特徵篩選的 邏輯回歸具有coef_屬性，指定norm_order參數，來決定使用范數進行降維 預設為1 為L1范數 選擇器會刪除在L1範式下無效的特徵 優化在特徵選擇的前提下保證模型的高效率 Method I 優化threshold 在上面並未指定threshold參數，預設為None 刪除了所有L1正則化後 參數(權重)$\\theta$($w$)為0 的特徵 對threshold參數進行調整 (繪製threshold學習曲線) 優化模型 調整threshold值時，就不是使用 L1正則化 選擇特徵，而是使用模型的屬性coef_ 生成的各個係數來選擇 係數越大的特徵 對邏輯回歸的影響就越大 Method II 優化模型本身參數C 使用L1范數來做特徵選擇，但是調整 邏輯回歸建模時的C這個超參數 邏輯回歸建模搭配不同C參數的取值；將不同參數C取值的模型，用來進行嵌入法特徵選擇，並繪製學習曲線 係數累加法 包裝法 直接設定需要的特徵個數 現實運用邏輯回歸時，通常會限定變量個數的需求，包裝法此時會非常方便","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2019","slug":"2019","permalink":"http://www.taroballz.com/tags/2019/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"},{"name":"特徵預處理","slug":"特徵預處理","permalink":"http://www.taroballz.com/tags/特徵預處理/"},{"name":"特徵工程","slug":"特徵工程","permalink":"http://www.taroballz.com/tags/特徵工程/"}]},{"title":"機器學習-特徵工程-細談特徵降維","slug":"ML_feature_decomposition","date":"2019-06-15T16:00:00.000Z","updated":"2019-06-21T17:59:42.000Z","comments":true,"path":"2019/06/16/ML_feature_decomposition/","link":"","permalink":"http://www.taroballz.com/2019/06/16/ML_feature_decomposition/","excerpt":"Introduction sklearn中的降維演算法都被包括在模塊decomposition中 decomposition模塊為一個矩陣分解模塊 SVD和主成分分析PCA都屬於矩陣分解算法中的入門算法，通過分解特徵矩陣來進行降維 降維(矩陣分解)的過程中追求既減少特徵的數量，又保留大量有效信息的 新特徵矩陣 將帶有重複信息(特徵與特徵之間有線性相關)的特徵合併 刪除無效信息(noise)的特徵 如果一個特徵的方差(Variance)很大，則可以說明這個特徵帶有大量信息 兩種主要的降維方法；其矩陣分解的方法不同，信息量衡量指標不同，但都涉及大量矩陣運算 主成分分析(PCA) 奇異值分解(SVD) 通常在能進行PCA降維的情況下，不會進行特徵選擇 無法使用PCA降維的情況下才會做特徵選擇","text":"Introduction sklearn中的降維演算法都被包括在模塊decomposition中 decomposition模塊為一個矩陣分解模塊 SVD和主成分分析PCA都屬於矩陣分解算法中的入門算法，通過分解特徵矩陣來進行降維 降維(矩陣分解)的過程中追求既減少特徵的數量，又保留大量有效信息的 新特徵矩陣 將帶有重複信息(特徵與特徵之間有線性相關)的特徵合併 刪除無效信息(noise)的特徵 如果一個特徵的方差(Variance)很大，則可以說明這個特徵帶有大量信息 兩種主要的降維方法；其矩陣分解的方法不同，信息量衡量指標不同，但都涉及大量矩陣運算 主成分分析(PCA) 奇異值分解(SVD) 通常在能進行PCA降維的情況下，不會進行特徵選擇 無法使用PCA降維的情況下才會做特徵選擇 主成分分析(PCA) PCA使用的信息量衡量指標，就是樣本方差(Variance)；又稱可解釋性方差，其值越大，特徵所帶的信息量越多 樣本方差公式如下 Var = \\frac{1}{n-1} \\sum_{i=1}^{n} (x_i-\\hat{x})^2 $Var$代表 一個特徵的方差 $n$代表樣本量 $x_i$代表一個特徵中的每個樣本的取值 $\\hat{x}$代表該列樣本的均值 PCA本質就是將已存在的特徵進行壓縮，降維後的特徵不是原本特徵中的任何一個特徵，而是通過某些方式組合起來的新特徵 新特徵矩陣生成不具有可讀性 以PCA為代表的 降維方法 是屬於特徵創造(feature creation) 在線性模型當中，不能使用PCA 通常使用特徵選擇進行降維 參考http://www.taroballz.com/2018/07/06/ML_DecreaseFeature/#%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90-PCA 奇異值分解(SVD) 奇異值分解可以在不計算協方差矩陣等等複雜計算冗長的情況下，直接求出新特徵空間和降維後的特徵矩陣 SVD在矩陣分解中會比PCA簡單快速 SVD的信息衡量指標為奇異值 比較複雜","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2019","slug":"2019","permalink":"http://www.taroballz.com/tags/2019/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"},{"name":"特徵工程","slug":"特徵工程","permalink":"http://www.taroballz.com/tags/特徵工程/"}]},{"title":"機器學習-特徵工程-特徵選擇-包裝法","slug":"ML_feature_selection_wrapper_method","date":"2019-06-14T16:00:00.000Z","updated":"2019-06-21T17:32:46.000Z","comments":true,"path":"2019/06/15/ML_feature_selection_wrapper_method/","link":"","permalink":"http://www.taroballz.com/2019/06/15/ML_feature_selection_wrapper_method/","excerpt":"Introduction 包裝法(wrapper)仍是一種特徵選擇和演算法訓練同時進行的方法 與嵌入法相似的地方，仍是依賴算法有coef_及feature_importances_等屬性來完成特徵選擇 不同之處為 使用一個專業的數據挖掘演算法；而非使用 在評估模型使用的演算法 wrapper method 黑箱中所使用的Learning Algorithm是一個目標函數，專門用於選取特徵 不需像過濾法那樣在指定評估指標 和 threshold值 計算成本位於嵌入法與過濾法中間 包裝法效果是所有特徵選擇方法中最利於提升模型表現的 不適用於大 包裝法相比嵌入法更能保證模型效果","text":"Introduction 包裝法(wrapper)仍是一種特徵選擇和演算法訓練同時進行的方法 與嵌入法相似的地方，仍是依賴算法有coef_及feature_importances_等屬性來完成特徵選擇 不同之處為 使用一個專業的數據挖掘演算法；而非使用 在評估模型使用的演算法 wrapper method 黑箱中所使用的Learning Algorithm是一個目標函數，專門用於選取特徵 不需像過濾法那樣在指定評估指標 和 threshold值 計算成本位於嵌入法與過濾法中間 包裝法效果是所有特徵選擇方法中最利於提升模型表現的 不適用於大 包裝法相比嵌入法更能保證模型效果 Process 在初始特徵(全部特徵)集上訓練黑箱中的Learning Algorithm 獲得coef, feature_importances_等屬性作為重要程度指標 除去最不重要的特徵，得到修剪的特徵集合 回到步驟1，直到達到所指定所需數量的特徵 遞歸特徵消除法(RFE) 最典型的Learning Algorithm為遞歸特徵消除法(Recursive feature elimination,RFE) 為一貪婪優化演算法,旨在找尋最佳的特徵子集 from sklearn.feature_selection import RFE 重要參數estimator填寫實例化後的演算法模型實例 n_features_to_select填寫想要選擇出來的特徵個數 預設為None 意指想保留的維度為多少 為一超參數 可使用學習曲線法進行優化 step填寫每次迭代中欲移除的特徵個數 預設為1 方法與其他轉換器(transformer)一樣皆具有fit_transform、fit、transform、inverse_transform 等方法 重要屬性.support_返回所有的特徵是否最後被選中的boolean矩陣 .ranking_返回特徵 按數次迭代中綜合重要性的排名 排名越前面的特徵越重要 RFECV1from feature_selection import RFECV 其會在交叉驗證循環中執行RFE以找到最佳數量的特徵 增加參數cv(交叉驗證的次數)，其他用法與RFE一模一樣 特徵選擇總結 過濾法較快速但是粗糙 包裝法和嵌入法更精確，計算量較大，運行時間長 數據量大時，優先使用方差過濾(VarianceThreshold)和互信息法(mutal_info_classif(regression))，再使用其他的特徵選擇方法 Logistic Regression：優先使用嵌入法 SVM：優先使用包裝法 不知道用哪個時，先使用過濾法","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2019","slug":"2019","permalink":"http://www.taroballz.com/tags/2019/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"},{"name":"特徵工程","slug":"特徵工程","permalink":"http://www.taroballz.com/tags/特徵工程/"}]},{"title":"機器學習-特徵工程-特徵選擇-嵌入法","slug":"ML_feature_selection_embedded_method","date":"2019-06-13T16:00:00.000Z","updated":"2019-06-21T17:30:53.000Z","comments":true,"path":"2019/06/14/ML_feature_selection_embedded_method/","link":"","permalink":"http://www.taroballz.com/2019/06/14/ML_feature_selection_embedded_method/","excerpt":"Introduction 嵌入法(Embedded)是讓演算法自己決定使用那些特徵的方法 特徵選擇 及 演算法訓練 同時進行 特徵的選擇是依賴模型的表現來進行選擇，因此為一循環過程 Embedded method 最後得到各個特徵的權值，根據權值從大到小選擇特徵 相比過濾法，嵌入法的篩選的特徵更為精確，對模型更有效 缺點1：無法有效界定有用特徵 權值係數的臨界值 不像過濾法有p值可幫助我們做界定 只能說要是權值係數為0時，則對模型毫無貢獻 改善方法： 權值係數作為 超參數，使用學習曲線方法進行調參 根據 模型本身性質 判斷權值係數範圍 缺點2：因為其是引入演算法來挑選特徵，且會使用全部特徵 計算時間與所使用的演算法 及 數據量有關係 from sklearn.feature_selection import SelectFromModel","text":"Introduction 嵌入法(Embedded)是讓演算法自己決定使用那些特徵的方法 特徵選擇 及 演算法訓練 同時進行 特徵的選擇是依賴模型的表現來進行選擇，因此為一循環過程 Embedded method 最後得到各個特徵的權值，根據權值從大到小選擇特徵 相比過濾法，嵌入法的篩選的特徵更為精確，對模型更有效 缺點1：無法有效界定有用特徵 權值係數的臨界值 不像過濾法有p值可幫助我們做界定 只能說要是權值係數為0時，則對模型毫無貢獻 改善方法： 權值係數作為 超參數，使用學習曲線方法進行調參 根據 模型本身性質 判斷權值係數範圍 缺點2：因為其是引入演算法來挑選特徵，且會使用全部特徵 計算時間與所使用的演算法 及 數據量有關係 from sklearn.feature_selection import SelectFromModel SelectFromModel 為一種 元轉換器 可與任何擬合後具有coef_, feature_importances_屬性 或 參數中可選懲罰項的評估器合用 RandomForest, DecisionTree：具有feature_importances_(取值範圍為0-1) 若重要性低於閥值：特徵不重要 LogisticRegression：l1,l2 懲罰項 SVM：l2 懲罰項 重要參數estimator所使用的演算法模型，只要是帶feature_importances_ or coef_ 屬性 or 帶有 l1, l2懲罰項的演算法都可以使用 必須將模型實例化後，填入實例化的模型變量 threshold特徵重要性的閥值，重要性低於指定的值都將被刪除 挑選threshold的值非常重要，其決定刪掉多少特徵 其為超參數 使用學習曲線方法調教此參數 方法fit_transform與其他轉換器不一樣的是fit_transform參數中須放入兩個參數 1X_Embedded = SelectFromModel(estimator=RFC_,threshold=0.005).fit_transform(X,y) 第一個參數須放入欲轉換的feature矩陣X 第二個參數為Label矩陣y 總結 比起必須思考很多統計量的過濾法來說，嵌入法可能是更有效的選擇 過濾法計算較嵌入法快 大型數據中，優先使用過濾法 或使用結合過濾法和嵌入法的包裝法(wrapper)","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2019","slug":"2019","permalink":"http://www.taroballz.com/tags/2019/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"},{"name":"特徵工程","slug":"特徵工程","permalink":"http://www.taroballz.com/tags/特徵工程/"}]},{"title":"機器學習-特徵工程-特徵選擇(feature_selection)-過濾法","slug":"ML_feature_selection_filter_method","date":"2019-06-11T16:00:00.000Z","updated":"2019-07-08T16:44:55.000Z","comments":true,"path":"2019/06/12/ML_feature_selection_filter_method/","link":"","permalink":"http://www.taroballz.com/2019/06/12/ML_feature_selection_filter_method/","excerpt":"Introduction從所有的特徵中，選擇出有意義的或對模型有幫助的特徵 避免必須將所有特徵都導入模型進行訓練的窘境 重要！！：必須與數據提供者討論 若是我們無法找到合適領域的人幫助理解數據來選擇特徵的話，可使用以下四種方法 過濾法 嵌入法 包裝法 降維演算法","text":"Introduction從所有的特徵中，選擇出有意義的或對模型有幫助的特徵 避免必須將所有特徵都導入模型進行訓練的窘境 重要！！：必須與數據提供者討論 若是我們無法找到合適領域的人幫助理解數據來選擇特徵的話，可使用以下四種方法 過濾法 嵌入法 包裝法 降維演算法 過濾法(Filter) 常被用作特徵預處理的步驟 根據各種統計檢驗的分數 及 相關性的各項指標來進行特徵選擇 方差過濾法(VarianceThreshold)請參考http://www.taroballz.com/2018/07/06/ML_DecreaseFeature/ 相關性過濾方差過濾完畢後，我們希望挑選出與標籤(Label)相關且有意義的特徵 若特徵與標籤無關：浪費計算資源 有三種常用的方法來評判特徵與標籤之間的相關性 卡方過濾 F-score檢驗 互信息 卡方過濾 專門針對離散型標籤(分類問題)的相關性過濾 sklearn.feature_selection.chi2 計算每個 非負數特徵 和 標籤 之間的卡方統計量 卡方檢驗法不能計算負數；可是用以下兩種預處理方法變為正數 MinMaxScalar StandardScalar 依照卡方統計量 由高到低 為 特徵排名 再結合feature_selection.SelectKBest 輸入 評分標準 來選出前K個分數最高的特徵 除去最可能獨立於標籤，與分類目的無關的特徵 若卡方檢驗檢測到某個特徵所有值都相同時，會提示先進行方差過濾 SelectKBest()為一轉換器，有兩個重要的參數score_func 及 k score_func 指定轉換器用於評估的統計量，可以是chi2等標準 ref：https://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.SelectKBest.html k 選出前k個 卡方值最高 的特徵 可指定自己所需要的特徵數目 為一超參數，設定過低的值有可能會刪除與模型相關且有效的特徵，須不斷進行調整 使用學習曲線驗證法得出好的k值 計算成本龐大 實例化chi2等評估指標 獲得卡方值很大且P值&lt;0.05 的特徵數作為k值 請參考 卡方檢驗 章 fit_transform與其他轉換器不一樣的是fit_transform參數中須放入兩個參數 X_fschi = SelectKBest(chi2,k=300).fit_transform(X,y) 第一個參數須放入欲轉換的feature矩陣X 第二個參數為Label矩陣y 卡方檢驗 推測兩組數據(feature,Label)之間的差異 原假設：兩組數據是互相獨立的 檢驗後返回 卡方值 及 P值 兩個統計量 卡方值：難界定有效篩選的範圍 P值：一般使用 0.01 or 0.05 作為顯著性水平(p值判斷邊界) >=0.05 or 0.01：兩組數據相關 (拒絕原假設，接受備擇假設) 該特徵對模型訓練有貢獻 \\&lt;0.05 or 0.01：兩組數據相互獨立 (接受原假設) 因此須選取 卡方值很大且P值>=0.05 or 0.01 的特徵(與標籤相關的特徵) 可從chi2實例獲得 各個特徵對應的 卡方值 及 P值 123from sklearn.feature_selection import chi2chivalue,pvalues_chi = chi2(X,y) X為feature矩陣 y為Label矩陣 chivalue為各特徵的卡方值，為一ndarray pvalues為各特徵相對標籤的p值，為一ndarray K_value = chi_values.shape[0] - (p_values_chi &lt; 0.01).sum() 將得到超參數k值該定為多少 F檢驗(ANOVA) 又稱作方差齊性檢驗(變異數分析;Analysis of variance) 是用來捕捉每個特徵與標籤之間的 線性 關係的過濾方法 原假設：數據不存在顯著的線性關係 F檢驗分類 feature_selection.f_classif 用於Label為離散型數據 F檢驗回歸 feature_selection.f_regression 用於Label為連續型數據 檢驗後返回 F值 及 P值 兩個統計量 F值：難界定有效篩選的範圍 P值：一般使用 0.01 or 0.05 作為顯著性水平(p值判斷邊界) &lt;=0.05 or 0.01：兩組數據存在 顯著線性相關 (拒絕原假設，接受備擇假設) 該特徵對模型訓練有貢獻 >0.05 or 0.01：兩組數據 沒有顯著線性關係 (接受原假設) 應被刪除 選取P值&lt;0.05 or 0.01 的特徵(與標籤相關的特徵) 123from sklearn.feature_selection import f_classifF, pvalues_f = f_classif(X,y) *pvalues為各特徵相對標籤的p值，為一ndarray K_value = F.shape[0] - (pvalues_f &gt; 0.01).sum() 將得到超參數k值該定為多少 F檢驗在服從正態分布時效果會非常穩定 如要使用F檢驗過濾特徵，會先將數據轉換為 服從正態分布 的形式 StandardScalar 再結合feature_selection.SelectKBest一起聯用 輸入 評分標準 來選出前K個分數最高的特徵 互信息法 是用來捕捉特徵與標籤之間的任意關係(線性及非線性)的過濾方法 故比F檢驗更強大 互信息分類 feature_selection.mutual_info_classif 互信息回歸 feature_selection.mutual_info_regression 返回 每個特徵 與 標籤 之間的 互信息量的估計 介於0-1之間 0：表示兩組數據相互獨立 1：表示兩組數據完全相關 選取 結果值大於0的特徵(與標籤相關的特徵) 123from sklearn.feature_selection import mutual_info_classif as MICresult = MIC(X,y) result為各特徵的戶信息量估計 只要不等於0就是與標籤有關 K_values_all_MIC = result.shape[0] -(result == 0).sum() 可得到超參數k值該定為多少 總結先使用方差過濾，在使用各種過濾法來捕捉相關性，可直接使用互信息法更好","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2019","slug":"2019","permalink":"http://www.taroballz.com/tags/2019/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"},{"name":"特徵工程","slug":"特徵工程","permalink":"http://www.taroballz.com/tags/特徵工程/"}]},{"title":"機器學習-特徵預處理-處理連續型數據","slug":"ML_continueVar_Preprocessing","date":"2019-06-08T16:23:54.000Z","updated":"2019-06-11T17:18:55.000Z","comments":true,"path":"2019/06/09/ML_continueVar_Preprocessing/","link":"","permalink":"http://www.taroballz.com/2019/06/09/ML_continueVar_Preprocessing/","excerpt":"Introduction 二值化(binarizer) 根據閥值(threshold)將數值二元化(大於閥值設為1;小於or等於閥值設為0) 用於處理連續型變量 連續型變量劃分為二分類 決定僅考慮某種現象存在與否 分段(KBinsDiscretizer;分箱) 將連續型數據劃分為不同分類變量 例如：根據不同的年齡段分成老年、中年、青少年、小孩、幼齡","text":"Introduction 二值化(binarizer) 根據閥值(threshold)將數值二元化(大於閥值設為1;小於or等於閥值設為0) 用於處理連續型變量 連續型變量劃分為二分類 決定僅考慮某種現象存在與否 分段(KBinsDiscretizer;分箱) 將連續型數據劃分為不同分類變量 例如：根據不同的年齡段分成老年、中年、青少年、小孩、幼齡 二值化(Binarizer) from sklearn.preprocessing import Binarizer Binarizer為特徵專用，不能使用一維數據，需進行reshape(-1,1)升維成二維 一列的數據 實例化指定threshold Binarizer(threshold=?) 大於threshold值會設為1，小於等於threshold值會設為0 方法與其他轉換器(transformer)一樣皆具有fit_transform、fit、transform、inverse_transform 等方法 分段(KBinsDiscretizer) from sklearn.preprocessing import KBinsDiscretizer 將連續型數據排序後，按順序分箱後編碼 KBinsDiscretizer為特徵專用，不能使用一維數據，需進行reshape(-1,1)升維成二維 一列的數據 實例化的重要參數n_bins每個特徵中分箱的個數 預設為5，將連續型數據分為5類 一次會被運用到所有fit進來的特徵矩陣 若一次導入有10個feature的特徵矩陣，全部特徵都會被分為指定的類數別 若希望不同特徵的分箱數不同，則必須實例化多個不同的分箱依據的KBinsDiscretizer轉換器 encode編碼的方式 預設為&quot;onehot&quot;：返回sparse matrix，含有該類別的樣本為1，反之為0 分為多少箱就有多少列 &quot;ordinal&quot;：每個特徵(箱)被編碼為一個整數，返回一列含有不同整數編碼的箱的矩陣 &quot;onehot-dense&quot;：做onehot編碼後，返回一個密集數組 strategy用來定義箱寬的方式 預設為&quot;quantile&quot;：表示等位分箱，每個特徵中的每個箱內的樣本數量相同 根據箱內樣本的數量進行分割 &quot;uniform&quot;：表示等寬分箱，每個特徵中的每個箱最大值之間差為((特徵.max() - 特徵.min()) / (n_bins)) 根據數據的值來進行分箱 &quot;kmeans&quot;：表示按聚類分箱 每個箱中的值到最近的一維k均值聚類的簇心的距離相同 方法與其他轉換器(transformer)一樣皆具有fit_transform、fit、transform、inverse_transform 等方法 Reference http://www.peixun.net/view/1281.html","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2019","slug":"2019","permalink":"http://www.taroballz.com/tags/2019/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"},{"name":"特徵預處理","slug":"特徵預處理","permalink":"http://www.taroballz.com/tags/特徵預處理/"}]},{"title":"機器學習-特徵預處理(處理分類型數據)-編碼(Encode)","slug":"ML_Encoder","date":"2019-06-04T16:08:00.000Z","updated":"2019-06-11T17:18:55.000Z","comments":true,"path":"2019/06/05/ML_Encoder/","link":"","permalink":"http://www.taroballz.com/2019/06/05/ML_Encoder/","excerpt":"Introduction 將文字型的數據轉換為數值型數據","text":"Introduction 將文字型的數據轉換為數值型數據 分類標籤轉換為分類數值(LabelEncoer) 為標籤(Label)專用的，能夠將文字分類轉換為分類數值 位於sklearn.preprocessing中 實例化成物件後，因其接受的數據為標籤，所以允許一維數據的輸入 不用將其轉換為二維 一列的數據 方法與其他轉換器(transformer)一樣皆具有fit_transform、fit、transform、inverse_transform 等方法 屬性.classes_ 查看標籤中有哪些類別 LabelEncoder.classes_ 分類特徵轉換為分類數值(OrdinalEncoder) 為特徵專用的，將文字分類特徵轉換為數值 位於sklearn.preprocessing中 不允許導入一維的數據 方法與其他轉換器(transformer)一樣皆具有fit_transform、fit、transform、inverse_transform 等方法 屬性.categories_ 查看各個特徵中有哪些類別 OrdinalEncoder.categories_ one-hot編碼(OneHotEncoder) 用作表示互相獨立且不可計算的變量，例如性別，進船的艙門等 位於sklearn.preprocessing中 OneHotEncoder(categories=&quot;auto&quot;) categories：0.20版本可以直接輸入&quot;auto&quot;會自動遍歷特徵有多少類；0.19版本須用list明確指定各個特徵含有多少類別 方法與其他轉換器(transformer)一樣皆具有fit_transform、fit、transform、inverse_transform 等方法 transform 與 fit_transform 其會將載入的數據進行one-hot編碼後輸出，輸出的為sparse matrix 如欲輸出像前面兩種編碼器的ndarray型式的話，需進行toarray() data_array = OneHotEncoder.fit_transform(data).toarray() inverse_transform 依然可以進行還原 get_feature_names 查看onehot編碼後的 sparse matrix 各列(column)對應的原特徵的類別 OneHotEncoder.get_feature_names() tips 可對標籤Label進行one-hot編碼 使用sklearn.preprocessing.LabelBinarizer 在實際處理時並不常見 Reference http://www.peixun.net/view/1281.html","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2019","slug":"2019","permalink":"http://www.taroballz.com/tags/2019/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"},{"name":"特徵預處理","slug":"特徵預處理","permalink":"http://www.taroballz.com/tags/特徵預處理/"}]},{"title":"機器學習-Data Mining Introduction","slug":"ML_FeatureEnginering_and_data_preprocessing","date":"2019-06-03T13:11:00.000Z","updated":"2019-06-04T16:00:22.000Z","comments":true,"path":"2019/06/03/ML_FeatureEnginering_and_data_preprocessing/","link":"","permalink":"http://www.taroballz.com/2019/06/03/ML_FeatureEnginering_and_data_preprocessing/","excerpt":"Introduction 數據不給力，再高級的算法都沒有用","text":"Introduction 數據不給力，再高級的算法都沒有用 Data Mining 五大流程1. 獲取數據2. 數據預處理從數據中檢測、糾正或刪除損壞、不正確或不適用的記錄之過程。 面臨問題 數據類型不同，有的是文字有的是數字，有的為時間序列 有的是連續型變量，亦有可能是離散型變量 數據質量不好，有噪聲、有異常值、有缺失、有錯誤 數據量太大或太小 目的讓數據適應模型，匹配模型需求 3. 特徵工程將原始數據轉換為更能代表預測模型的潛在問題特徵的過程 原始數據不一定能引導模型算出最好的結果 通過挑選相關特徵、組合特徵、提取有效特徵及創造特徵等手法來實現 創造特徵通常以降維演算法的方式實現 面臨問題 特徵之間有相關性 特徵和標籤無關 特徵太多或太小 特徵無法表現出應有的數據現象、無法展示數據的真實面貌 目的 降低計算成本 提升模型上限 至少保證模型在一個比較好的水平 降噪：剔除有不良影響的特徵 4. 建模測試模型並預測結果 5. 模型上線在真實狀況中去驗證模型效果","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2019","slug":"2019","permalink":"http://www.taroballz.com/tags/2019/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"},{"name":"特徵預處理","slug":"特徵預處理","permalink":"http://www.taroballz.com/tags/特徵預處理/"},{"name":"特徵工程","slug":"特徵工程","permalink":"http://www.taroballz.com/tags/特徵工程/"}]},{"title":"機器學習-調參","slug":"ML_modifyparm","date":"2019-05-28T16:12:10.000Z","updated":"2019-05-28T17:11:33.000Z","comments":true,"path":"2019/05/29/ML_modifyparm/","link":"","permalink":"http://www.taroballz.com/2019/05/29/ML_modifyparm/","excerpt":"泛化誤差(Genelization error)衡量模型在未知數據上的準確率 模型在未知數據(測試集or袋外數據)上表現不好時，通常會說模型泛化程度不夠或是泛化誤差大 泛化誤差受到模型結構(複雜度)影響","text":"泛化誤差(Genelization error)衡量模型在未知數據上的準確率 模型在未知數據(測試集or袋外數據)上表現不好時，通常會說模型泛化程度不夠或是泛化誤差大 泛化誤差受到模型結構(複雜度)影響 模型太簡單：模型欠擬合，泛化誤差大 模型太複雜：模型過擬合，泛化能力不夠，泛化誤差大 只有模型複雜度剛剛好才能夠達到泛化誤差最小 調參之前要先判斷，模型當前處於圖像的哪一邊 樹模型調參 模型太複雜或太簡單，都會讓泛化誤差高，我們追求是位於中間平衡點 模型太複雜就會過擬合，太簡單就會欠擬合 對樹模型和樹集成模型來說，樹深度越深，枝葉越多，模型越複雜 剪枝就是為了降低模型複雜度 樹模型和樹集成模型的目標，都是減少模型複雜度，將摸型往圖像左邊移動 Reference http://www.peixun.net/view/1281.html","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2019","slug":"2019","permalink":"http://www.taroballz.com/tags/2019/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"}]},{"title":"機器學習-特徵工程-填補缺失值","slug":"ML_FillNanValue","date":"2019-05-27T16:14:00.000Z","updated":"2019-06-04T16:00:22.000Z","comments":true,"path":"2019/05/28/ML_FillNanValue/","link":"","permalink":"http://www.taroballz.com/2019/05/28/ML_FillNanValue/","excerpt":"Introduction 現實中所蒐集的數據不可能完美，往往伴隨著缺失值的存在處理方法通常為： 直接將含有缺失值的樣本刪除 直接將含有過多缺失值的特徵列刪除 使用sklearn.impute.SimpleImputer將均值、中位數、眾數、常數填補數據 專門用作填補缺失值的類 使用隨機森林回歸填補缺失值","text":"Introduction 現實中所蒐集的數據不可能完美，往往伴隨著缺失值的存在處理方法通常為： 直接將含有缺失值的樣本刪除 直接將含有過多缺失值的特徵列刪除 使用sklearn.impute.SimpleImputer將均值、中位數、眾數、常數填補數據 專門用作填補缺失值的類 使用隨機森林回歸填補缺失值 使用特定值填補缺失值123from sklearn.impute import SimpleImputerimp_mean = SimpleImputer(missing_values = np.nan, strategy=\"mean\",copy=True)x_missing_mean = imp_mean.fit_transform(X_missing) X_missing:是含有缺失值的pandas.dataframe或是numpy.ndarray類型的數據 x_missing_mean：是使用均值填補的結果 返回的類型為numpy.ndarray類型 strategy參數：可為&quot;mean&quot;(平均數[預設])、&quot;median&quot;(中位數)、&quot;most_frequent&quot;(眾數[可用於填充文字])、&quot;constant&quot;(常數[可用於填充文字]) 若使用&quot;constant&quot;(常數)進行填補，則需再指定fill_value參數為何值 fill_value = 0：使用0進行填補 copy: 預設為True:創建特徵矩陣的副本 ; 設為False時，會將缺失值直接填補到原本的特徵矩陣中去 判斷是否填補完成 使用pandas.DataFrame.isnull()判斷是否填補完成 加總每一列的結果確定皆為0，則代表填補完成 1pd.DataFrame(x_missing_mean).isnull().sum() 使用隨機森林回歸進行填補 建立在回歸演算法認為特徵和標籤之間存在著某種關係 利用標籤 + 其他特徵反推缺失值 此種做法對於某一個特徵大量缺失，其他特徵卻很完整的情況非常適用 流程 先遍歷所有特徵，查看有缺失值的為哪些特徵，並從缺失值最少的特徵開始進行填補 填補缺失值最少的特徵所需要的準確信息最少 填補其中一個特徵時，先將其他特徵缺失值用0代替 劃分測試集及訓練集 建模後預測該特徵的缺失值 將預測值放到原本的特徵矩陣中；重複第2步驟 Reference http://www.peixun.net/view/1281.html","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2019","slug":"2019","permalink":"http://www.taroballz.com/tags/2019/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"}]},{"title":"機器學習-演算法-隨機森林回歸(RandomForestRegressor)","slug":"ML_RandomForest_Regressor","date":"2019-05-25T16:00:00.000Z","updated":"2019-05-26T08:12:13.000Z","comments":true,"path":"2019/05/26/ML_RandomForest_Regressor/","link":"","permalink":"http://www.taroballz.com/2019/05/26/ML_RandomForest_Regressor/","excerpt":"DecisionTreeClassifier12345class sklearn.ensemble.RandomForestRegressor(n_estimators=’warn’, criterion=’mse’, max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_features=’auto’, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, bootstrap=True, oob_score=False, n_jobs=None, random_state=None, verbose=0, warm_start=False)","text":"DecisionTreeClassifier12345class sklearn.ensemble.RandomForestRegressor(n_estimators=’warn’, criterion=’mse’, max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_features=’auto’, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, bootstrap=True, oob_score=False, n_jobs=None, random_state=None, verbose=0, warm_start=False) 其大部分的參數、屬性、接口全部和隨機森林回歸(RandomForestClassifier) 僅只有回歸樹和分類樹的不同 不純度指標，參數criterion不一致 重要參數 criterion:參閱回歸樹介紹 tips 因其不存在每個樣本被分類到某個標籤的概率問題，所以並沒有predict_proba的接口可以使用 Reference http://www.peixun.net/view/1281.html","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2019","slug":"2019","permalink":"http://www.taroballz.com/tags/2019/"},{"name":"演算法","slug":"演算法","permalink":"http://www.taroballz.com/tags/演算法/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"}]},{"title":"機器學習-演算法-隨機森林分類(RandomForestClassifier)","slug":"ML_RandomForest_Classifier","date":"2019-05-25T15:25:00.000Z","updated":"2019-05-25T15:52:19.000Z","comments":true,"path":"2019/05/25/ML_RandomForest_Classifier/","link":"","permalink":"http://www.taroballz.com/2019/05/25/ML_RandomForest_Classifier/","excerpt":"Introduction隨機森林是非常具有代表性的Bagging集成演算法 所有的基評估器(base estimator)都是決策樹 單個決策樹的準確率越高，隨機森林的準確率也會越高 Bagging是依賴於平均值或多數決原則來決定集成結果的 DecisionTreeClassifier12345class sklearn.ensemble.RandomForestClassifier(n_estimators=’warn’, criterion=’gini’, max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_features=’auto’, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, bootstrap=True, oob_score=False, n_jobs=None, random_state=None, verbose=0, warm_start=False, class_weight=None)","text":"Introduction隨機森林是非常具有代表性的Bagging集成演算法 所有的基評估器(base estimator)都是決策樹 單個決策樹的準確率越高，隨機森林的準確率也會越高 Bagging是依賴於平均值或多數決原則來決定集成結果的 DecisionTreeClassifier12345class sklearn.ensemble.RandomForestClassifier(n_estimators=’warn’, criterion=’gini’, max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_features=’auto’, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, bootstrap=True, oob_score=False, n_jobs=None, random_state=None, verbose=0, warm_start=False, class_weight=None) 其大部分的參數幾乎與決策樹一致 重要參數 其是使用bagging的集成算法都會有的重要參數 n_estimators 森林中樹木的數量(base estimator的數量) 通常此值越大，模型效果往往越好 任何模型都有決策邊界，其值達到一定程度時，精確性往往不在上升或開始波動 其值越大，計算量與內存消耗量越大，訓練時間越長 渴望在訓練難度和模型效果之間取得平衡 random_state 隨機森林中的random_state，其控制的是森林生成的模式(生成一片固定的森林)，而非讓一個森林之中只有一棵樹 固定生成的每棵樹的random_state;但是森林中樹跟樹之間還是不一樣 不像決策樹的random_state都是生成同一棵樹 bootstrap bagging是通過樣本抽取後有放回的隨機抽樣技術來型成不同的訓練集bootstrap就是用來控制抽樣技術的參數 參數默認為True:有放回的隨機採樣技術 通常這個參數不會被我們設置為False 由於是有放回的抽樣技術，樣本可能在新的自助集中出現多次，其他樣本可能被忽略 自助集大約平均會包含 63% 的原始數據 表示會有37%的數據集被浪費掉，沒有參與建模，其被稱為袋外數據(out of bag data;oob) 亦可以被用來作為集成算法的測試集使用 亦指在使用隨機森林時，我們可以不劃分測試集和訓練集，只需要用袋外數據來測試模型 當原始樣本數及n_estimators不夠大的時候，也很可能沒有數據落在袋外，便無法使用oob數據來測試模型 oob_score 若希望用袋外數據測試，實例化時將oob_score設為True RF_classifier = RandomForestClassifier(n_estimators=25,random_state=2,oob_score=True) 為True時無須再劃分訓練集及測試集 重要屬性estimators_ 使用estimator.estimators_查看森林中所有樹的狀況 其返回每棵樹對象構建的參數，為一列表 可以發現每棵樹只有random_state不同 可使用列表的方式取出某棵樹，再利用.屬性的方式查看該樹的屬性 estimator.estimators_[0].random_state 查看estimator模型裡第0顆樹的random_state之值 oobscore 要是建模oob_score為True時，可使用其屬性查看使用袋外數據測試的結果 重要接口和其他演算法模型一樣，隨機森林仍有apply、fit、predict、score等接口 predict_proba (predict probability)返回每個測試樣本對應被分到每一類標籤的概率 標籤有幾種不一樣的分類就會返回幾個概率 二分類問題：數值大於0.5被分為1，小於0.5被分為0 傳統隨機森林是利用bagging規則，平均或多數決集成結果 sklearn中隨機森林是平均每個樣本對應的predict_proba返回的概率，得到一個平均概率，從而決定樣本的分類 Reference http://www.peixun.net/view/1281.html","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2019","slug":"2019","permalink":"http://www.taroballz.com/tags/2019/"},{"name":"演算法","slug":"演算法","permalink":"http://www.taroballz.com/tags/演算法/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"}]},{"title":"機器學習-集成學習(ensemble learning)方法概述","slug":"ML_Introduction_EnsembleLearning","date":"2019-05-22T02:25:00.000Z","updated":"2019-05-25T15:42:22.000Z","comments":true,"path":"2019/05/22/ML_Introduction_EnsembleLearning/","link":"","permalink":"http://www.taroballz.com/2019/05/22/ML_Introduction_EnsembleLearning/","excerpt":"集成學習(ensemble learning)方法通過建立幾個模型組合來解決單一預測問題，其工作原理是在數據集上構建多個分類器/模型，各自獨立學習和做出預測，這些預測最後結合成單預測，因此優於任何一個單分類器做出的預測 不是一個單獨的機器學習的算法阿 現在各種演算法競賽中，隨機森林、梯度提升樹(GBDT)、Xgboost隨處可見 sklearn中的集成學習方法位於sklearn.ensemble中","text":"集成學習(ensemble learning)方法通過建立幾個模型組合來解決單一預測問題，其工作原理是在數據集上構建多個分類器/模型，各自獨立學習和做出預測，這些預測最後結合成單預測，因此優於任何一個單分類器做出的預測 不是一個單獨的機器學習的算法阿 現在各種演算法競賽中，隨機森林、梯度提升樹(GBDT)、Xgboost隨處可見 sklearn中的集成學習方法位於sklearn.ensemble中 集成演算法 多個演算法模型集成成為的模型叫做集成評估器(ensemble estimator) 組成集成評估器的每個演算法模型都叫做基評估器(base estimator) 通常分為三類： 裝袋法(Bagging) 構建多個相互獨立的評估器(彼此建立的過程互不干擾) 對其預測進行平均或多數表決原則來決定結果 隨機森林 單獨一個基評估器判斷準確率至少要超過50%，才可以確保集成評估器的表現會比基評估器好;否則集成評估器的效果會劣於基評估器。在使用隨機森林之前，一定要檢查，用來組成隨機森林的分類樹是否都至少有50%的預測正確率 提升法(Boosting) 基評估器是相關的(是按順序構建的) 第一次採樣訓練，對於判斷錯誤的樣本，在下一次採樣訓練模型的過程中，會增加其權重，使其更容易被下一個建立的評估器提取到，不斷循環 在一次次建模的過程中，對難以評估特徵的樣本進行強力的預測，構建出一個強評估器 Adaboost、梯度提升樹 stacking 集成算法目標集成算法會考慮多個estimator建模的結果，匯總後得到一個綜合的結果 以此來獲取比單個模型更好的回歸或分類表現","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2019","slug":"2019","permalink":"http://www.taroballz.com/tags/2019/"},{"name":"演算法","slug":"演算法","permalink":"http://www.taroballz.com/tags/演算法/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"},{"name":"集成學習方法","slug":"集成學習方法","permalink":"http://www.taroballz.com/tags/集成學習方法/"}]},{"title":"機器學習-演算法-決策樹回歸樹(DecisionTreeRegressor)","slug":"ML_decision_tree_TreeRegressor","date":"2019-05-19T06:43:00.000Z","updated":"2019-05-26T08:16:16.000Z","comments":true,"path":"2019/05/19/ML_decision_tree_TreeRegressor/","link":"","permalink":"http://www.taroballz.com/2019/05/19/ML_decision_tree_TreeRegressor/","excerpt":"DecisionTreeRegressor","text":"DecisionTreeRegressor 1234class sklearn.tree.DecisionTreeRegressor(criterion=’mse’, splitter=’best’, max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_features=None, random_state=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, presort=False) 幾乎所有參數、屬性、接口都和分類樹相同 回歸樹沒有標籤分佈是否均衡的問題 因此沒有class_weight這樣的參數 重要參數criterion 回歸樹衡量分枝質量的指標，支持的標準有三種 &quot;mse&quot;: 使用均方誤差(mean squared error) 父節點和葉子節點之間均方誤差之差額被用作特徵選擇的標準 使用葉子節點的平均值來最小化L2損失 &quot;friedman_mse&quot;：費爾德曼均方誤差 對潛在分枝問題進行改進的另一種計算均方誤差的方法 &quot;mae&quot;：使用絕對平均誤差(mean absolute error) 使用葉子節點的中位數來最小化L1損失 Mean Squared Error(MSE) MSE = \\frac{1}{N} \\sum_{i=1}^{N} (f_i - y_i)^2 $f_i$：是模型回歸出的數值 $y_i$：是樣本點$i$實際的數值標籤 重要接口score 回歸樹中恆量指標，返回的是$R^2$，並不是MSE $R^2$範圍為1至負無窮大 tips 在回歸樹中,MSE是分枝質量衡量指標 在回歸樹中,MSE是最常使用回歸質量衡量指標 使用交叉驗證(cross_validation)時，通常選擇均方誤差作為評估 cross_val_score(regressor,data,target,cv=10,scoring=&quot;neg_mean_squared_error&quot;) scoring不指定的話，預設返回的是$R^2$ 在回歸模型中,MSE越小越好 結論如果樹的最大深度(max_depth)設置得太高，決策樹會學習的太精細 從訓練數據中學了太多細節(包括noise) 使模型偏離真實欲表達得曲線，變成過擬合 Reference http://www.peixun.net/view/1281.html","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2019","slug":"2019","permalink":"http://www.taroballz.com/tags/2019/"},{"name":"演算法","slug":"演算法","permalink":"http://www.taroballz.com/tags/演算法/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"}]},{"title":"機器學習-演算法-細談決策樹分類樹(DecisionTreeClassifier)","slug":"ML_decision_tree_detail","date":"2019-05-15T13:25:00.000Z","updated":"2019-05-19T06:39:38.000Z","comments":true,"path":"2019/05/15/ML_decision_tree_detail/","link":"","permalink":"http://www.taroballz.com/2019/05/15/ML_decision_tree_detail/","excerpt":"Introduction 一種非參數的監督學習(有目標值)的演算法 非參數：不限制數據的結構與類型 任何數據皆適用","text":"Introduction 一種非參數的監督學習(有目標值)的演算法 非參數：不限制數據的結構與類型 任何數據皆適用 只要是決策樹的葉子節點(有進邊，沒有出邊)，都是一個類別的標籤 決策樹演算法的核心是要解決兩個問題 如何從數據中找出最佳節點和最佳分枝 如何讓決策樹停止生長，防止過擬合 sklearn中的決策樹 sklearn中關於決策樹的類(不包含集成演算法)都在sklearn.tree這個模塊下，共包含五個類 tree.DecisionTreeClassifier：分類樹 tree.DecisionTreeRegressor：回歸樹 tree.export_graphviz：將生成的決策樹導出為DOT格式，畫圖專用 tree.ExtraTreeClassifier：高隨機版本的分類樹 tree.ExtraTreeRegressor：高隨機版本的回歸樹 DecisionTreeClassifier123class sklearn.tree.DecisionTreeClassifier (criterion=’gini’, splitter=’best’, max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_features=None, random_state=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, class_weight=None, presort=False) 重要參數criterion 對分類樹來說，找出最佳節點及分枝的指標為＂不純度＂，不純度越低，決策樹對訓練集得的擬合越好。決策樹就是追求不純度相關指標的最優化 樹中的每個節點都會有一個不純度 子節點的不純度定低於父節點 葉子節點的不純度是最低的 &quot;entropy&quot;: 使用信息熵 信息熵對不純度叫基尼係數強(對不純度懲罰最強) 容易過擬合 實際使用中兩者效果基本一樣 &quot;gini&quot;：使用基尼係數 適用於數據維度大，噪音很大的數據 隨機性參數random_state 設置分枝中隨機模式的參數，預設為None使用同一批訓練集(Xtrain)進行訓練，得到的準確度仍有差異，原因決策樹本身就具有隨機性輸入任意整數，會針對特定模型選定的feature,長出同一顆樹讓模型穩定下來(固定隨機性) 調參優化時通常會固定random_state splitter 用作控制決策樹的隨機性 &quot;best&quot;: 決策樹雖然本身就具有隨機性，但會優先選擇更重要的特徵進行分枝 &quot;random: 決策樹在分枝時會更為隨機 樹深度更深 對訓練集的擬合會降低(防止過擬合的一種方式) 剪枝參數 決策樹會生長到衡量不純度最優，或者沒有更多特徵可用為止 這樣決策樹往往會過擬合 會在訓練集上表現很好，測試集卻很糟糕 為了決策樹有更好的泛化性，須對決策樹進行剪枝 剪枝策略對決策樹的影響巨大，正確的剪枝策略是優化決策樹算法的核心 max_depth 限制樹的最大深度，超過設定深度的樹枝全部剪掉 用的最廣泛的剪枝參數 在高維度、低樣本量時非常有效 在集成算法中也非常實用 建議從 = 3開始嘗試 min_samples_leaf 一個節點在分枝後每個子節點都必須包含至少min_samples_leaf個訓練樣本；分枝會朝著滿足每個子節點都包含min_samples_leaf個樣本的方向去發展 一般搭配max_depth使用 一般建議從= 5開始使用 如果葉節點中含有的樣本量變化很大，建議輸入浮點樹作為樣本量的百分比使用 min_samples_split 一個中間節點必須包含至少min_samples_split個訓練樣本，這個節點在允許被分枝，否則分枝不會發生 max_features 限制分枝時考慮的特徵個數，超過限制個數的特徵都會被捨棄和max_depth異曲同工 在不知道決策樹中的各個特徵的重要性情況下，設定這個參數會導致學習不足 min_impurity_decrease 限制信息增益的大小信息增益小於設定數值的分枝不會發生 利用matplotlib畫出學習曲線來確認最優的剪枝參數1234567891011121314import matplotlib.pyplot as plty_eff = []for i in range(10): # 測試的條件數 tree_clf = tree.DecisionTreeClassifier(criterion=\"entropy\" ,random_state = 30 ,splitter = \"random\" ,max_depth = i+1 #測試條件 ) tree_clf = tree_clf.fit(Xtrain,ytrain) score = tree_clf.score(Xtest,ytest) y_eff.append(score)plt.plot(range(1,11),y_eff,color=\"red\",label=\"max_depth\")plt.legend()plt.show() 目標權重參數控制目標權重的參數 class_weight 樣本不平衡是指在一組數據集中，某個標籤天生佔有很大的比例完成樣本標籤平衡的參數，對樣本標籤進行一定的均衡 給少量的標籤更多的權重 讓模型更偏向少數類，向捕獲少數類的方向建模 該參數默認為None 自動給予數據集中的所有標籤相同的權重 min_weight_fraction_leaf 有了權重之後，樣本量就不再是單純記錄樹目，而是受輸入權重影響此時剪枝須搭配min_weight_fraction_leaf這個基於權重的剪枝參數使用 重要屬性和接口所有接口中要求輸入X_train,X_test的部分，輸入的特徵矩陣必須至少是一個二維的矩陣 sklearn不接受任何一維矩陣作為特徵矩陣被輸入 如果數據確實只有一個特徵的data 必須用reshape(-1,1)來給矩陣增維 如果數據只有一個特徵和一個樣本(one-sample) 必須用reshape(1,-1)來給數據增維 estimator.apply(Xtest)返回每個測試樣本所在的葉子節點的索引 只輸入測試集，返回預測的結果 estimator.predict(Xtest)返回每個測試樣本分類/回歸的結果 只輸入測試集，返回預測的結果 結論分類樹(DecisionTreeClassifier)天生不擅長環形數據，每個模型都有自己決策的上限 一個怎樣調整參數都無法提升的表現的可能性仍存在 Reference http://www.peixun.net/view/1281.html","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2019","slug":"2019","permalink":"http://www.taroballz.com/tags/2019/"},{"name":"演算法","slug":"演算法","permalink":"http://www.taroballz.com/tags/演算法/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"}]},{"title":"Go初識-正則表達式","slug":"Go_Regular_Expression","date":"2019-03-29T16:00:00.000Z","updated":"2019-03-30T17:32:18.000Z","comments":true,"path":"2019/03/30/Go_Regular_Expression/","link":"","permalink":"http://www.taroballz.com/2019/03/30/Go_Regular_Expression/","excerpt":"Introduction 正則表達式常用來處理字符串的匹配 Go語言標準庫內建提供了regexp包，來處理正則表達式的問題","text":"Introduction 正則表達式常用來處理字符串的匹配 Go語言標準庫內建提供了regexp包，來處理正則表達式的問題 正則表達式規則匹配字符 .：匹配除換行符以外的任意字符 \\w：匹配字母或數字或下劃線或漢字 \\s：匹配任意的空白符號 \\d：匹配數字 \\b：匹配單詞的開始或結束 ^：匹配字符串的開始 $：匹配字符串的結束匹配數量 *：重複零次或更多次 +:重複一次或更多次 ?:重複零次或一次 {n}:重複n次 {n,}：重複n次或更多次 {n,m}：重複n到m次 Golang中的正則匹配是否匹配到該字符串 使用Match函數來進行匹配 func Match(pattern string, b []byte)(matched bool, err error) pattern : 欲匹配的格式(模式) b : 被匹配的字符串(須轉換成[]byte類型) 使用MatchString函數進行匹配 func MatchString(pattern string, s string)(matched bool, err error) s :被匹配的字符串(字符串格式) 123456789101112131415package mainimport ( \"fmt\" \"regexp\")func main()&#123; var s = \"He\" matchbool,err := regexp.MatchString(\"[a-zA-Z]&#123;3&#125;\",s) if err != nil&#123; panic(\"wow!!\") &#125; fmt.Println(\"match:\",matchbool)&#125; Result1match: false 返回匹配到的字符串以下兩函式常搭配一起使用 func MustCompile(str string) *Regexp str：欲匹配的正則表達式格式(模式) 返回一個正則表達的對象 func (re *Regexp) FindAllString(s string, n int) []string s:被匹配的字符串(字符串格式) n：滿足正則表達對象前n個字符串 n為-1時則返回全部滿足正則表達式的字符串 返回一個字符串陣列 1234567891011121314package mainimport ( \"fmt\" \"regexp\")func main()&#123; var s = \"Hello World\" re := regexp.MustCompile(\"\\\\w&#123;3&#125;\") //填入欲匹配的正則表達式（有斜槓時須轉譯） result := re.FindAllString(s,-1) fmt.Println(result)&#125; 捕獲 捕獲(exp)：匹配exp,並捕獲文本到自動命名的組裡 (?&lt;name&gt;exp):匹配exp，並捕獲文本到名稱為name的組裡，也可以寫成(?&#39;name&#39;exp) (?:exp)：匹配exp,不捕獲匹配的文本，也不給此分組分配組號 其會捕獲到()中匹配的字符串並放置在字符串陣列中 func (re *Regexp)FindStringSubmatch(s string)[]string s:被匹配的字符串(字符串格式) 返回一個字符串陣列 字符串陣列的第0個值為匹配到的字符串 第1個值之後為欲捕獲()中的字符串12345678910111213141516package mainimport ( \"fmt\" \"regexp\")func main()&#123; flysnowRegexp := regexp.MustCompile(`^http://www.flysnow.org/([\\d]&#123;4&#125;)/([\\d]&#123;2&#125;)/([\\d]&#123;2&#125;)/([\\w-]+).html$`) params := flysnowRegexp.FindStringSubmatch(\"http://www.flysnow.org/2018/01/20/golang-goquery-examples-selector.html\") fmt.Println(\"年份为：\"+params[1]) fmt.Println(\"月份为：\"+params[2]) fmt.Println(\"天数为：\"+params[3]) fmt.Println(\"文章名为：\"+params[4])&#125; Result1234年份为：2018月份为：01天数为：20文章名为：golang-goquery-examples-selector Referencehttps://www.flysnow.org/2018/02/09/go-regexp-extract-text.html","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"正則表達式","slug":"正則表達式","permalink":"http://www.taroballz.com/tags/正則表達式/"}]},{"title":"Go初識-MD5加密","slug":"Go_crypto_md5","date":"2019-03-29T16:00:00.000Z","updated":"2019-03-30T09:11:35.000Z","comments":true,"path":"2019/03/30/Go_crypto_md5/","link":"","permalink":"http://www.taroballz.com/2019/03/30/Go_crypto_md5/","excerpt":"Introduction 須引入crypto/md5的package 常用於數據庫密碼加密","text":"Introduction 須引入crypto/md5的package 常用於數據庫密碼加密 範例12345678910111213141516171819202122package mainimport ( \"crypto/md5\" \"fmt\")func main()&#123; str := \"admin\" //需將字符串轉為byte形式才能調用函數進行加密 data := []byte(str) // Method 1 encoding_data := md5.Sum(data) fmt.Printf(\"%x\\n\",encoding_data) //以16進制輸出 // Method 2 w := md5.New() //實例化一個md5加密的對象 w.Write(data) //將str寫入到w中 result := w.Sum(nil) //計算w結果 fmt.Printf(\"%x\\n\",result)","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"2019 - 加密","slug":"2019-加密","permalink":"http://www.taroballz.com/tags/2019-加密/"}]},{"title":"Golang項目-Kafka,tailf,config,log","slug":"Go_Kafka","date":"2019-03-21T16:00:00.000Z","updated":"2019-03-26T13:17:29.000Z","comments":true,"path":"2019/03/22/Go_Kafka/","link":"","permalink":"http://www.taroballz.com/2019/03/22/Go_Kafka/","excerpt":"introduction Kafka為一分布式的系統 一個kafka的集群可能有三台以上 使用第三方基礎庫來操作Kafka import &quot;github.com/Shopify/sarama&quot; 往kafka放東西的，稱為生產者(Producer) 客戶端連上Kafka，從Kafka取(消費)數據，稱為消費者 tailf庫 其為golang內部的基礎庫 其可以從一個不斷寫入的文件，持續的拿出數據 import &quot;github.com/hpcloud/tail&quot;","text":"introduction Kafka為一分布式的系統 一個kafka的集群可能有三台以上 使用第三方基礎庫來操作Kafka import &quot;github.com/Shopify/sarama&quot; 往kafka放東西的，稱為生產者(Producer) 客戶端連上Kafka，從Kafka取(消費)數據，稱為消費者 tailf庫 其為golang內部的基礎庫 其可以從一個不斷寫入的文件，持續的拿出數據 import &quot;github.com/hpcloud/tail&quot; Sarama 往kafka發送數據實例12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( \"fmt\" //導入操作Kafka的第三方庫 \"github.com/Shopify/sarama\")func main()&#123; //實例化一個新的配置 config := sarama.NewConfig() //config.Producer為一個結構體 config.Producer.RequiredAcks = sarama.WaitForAll //[1] //Partitioner為進行分區(負載均衡)配置 //NewRandomPartitioner其為隨機分區，其會分區到最大的配置主機數目上 config.Producer.Partitioner = sarama.NewRandomPartitioner config.Producer.Return.Successes = true //因此須建立與kafka連接的實例(NewSyncProducer為同步的客戶端) //若為異步客戶端 則內部會創建一個channel client,err := sarama.NewSyncProducer([]string&#123;\"127.0.0.1:9092\"&#125;,config) if err != nil &#123; fmt.Println(\"producer.close, err:\",err) return &#125; defer client.Close() //構造欲寫入Kafka的消息(為一struct) msg := &amp;sarama.ProducerMessage&#123;&#125; msg.Topic = \"nginx_log\" msg.Value = sarama.StringEncoder(\"this is a test message\") //向kafka發送消息 //異步客戶端發送消息時，會往內部channel發送消息，由後台發送給kafka //同步客戶端則直接向kafka發送消息 //會返回寫到哪個分區的id號(pid)，及訊息在kafka分區的偏移量(offset) pid,offset,err := client.SendMessage(msg) if err != nil &#123; fmt.Println(\"send message failed:\",err) return &#125; fmt.Printf(\"pid %v offset %v\\n\",pid,offset)&#125; 透過第三方庫發消息給kafka時，sarma會等待接收ack包，當kafka收到消息並寫入文件時，會回發ack包給sarma，藉以確認消息未丟失且已經存入kafka中 可評估自己所需的業務邏輯是否允許消息丟失 使用kafka-cli測試消費數據 使用kafka-console-consumer測試從終端消費數據1kafka-console-consumer --bootstrap-server localhost:9092 --topic nginx_log --from-beginning result成功消費數據 tailf 其可在程序中去調用tailf，而非傳統Linux的開啟一個tail命令的進程 使用tail.TailFile(filename,config) filename: 欲被tail的文件 config:其為tail.Config的實例，為一個struct Location:記下文件最後的位置 Poll:是否不斷地進行查詢 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport ( \"fmt\" \"github.com/hpcloud/tail\" \"time\")func main()&#123; fileName := \"./my.log\" // 生成一個tail的實例 tails,err := tail.TailFile(fileName,tail.Config&#123; ReOpen:true, //類似Linux下的tail -F Follow:true, Location: &amp;tail.SeekInfo&#123;Offset:0, Whence:2&#125;, MustExist:false, Poll:true, &#125;) if err != nil &#123; fmt.Println(\"tail file err\",err) return &#125; //一行日誌數據 var msg *tail.Line var ok bool // 無間斷的從配置的tail.Lines中拿取數據 //[1] for &#123; msg,ok = &lt;- tails.Lines //tails.Lines為一個管道 if !ok &#123; fmt.Println(\"tail file close reopen,filename:%s\\n\",tails.Filename) time.Sleep(100* time.Millisecond) continue &#125; fmt.Println(\"msg:\",msg) &#125;&#125;``` 1. 真實情況下須處理信號問題************************# 配置文件(config)庫* 其可支持多種格式的配置文件，例如yaml,ini等* `go get github.com/astaxie/beego/config` * 其為beego web框架其中一個基礎庫，可單獨使用* `import \"github.com/astaxie/beego/config\"`* 暫時使用config庫來將配置寫到文件中，之後可以使用**etcd**在線web介面管理配，並實時生效## ini格式初識* ini格式的配置文件分為**節、配置項**`(配置項名 = 配置項內容)` [server]listen_ip = “0.0.0.0”listen_port = 8080 [logs]log_level= debuglog_path = ./logs/logagent.log [collect]log_path = /home/work/logs/nginx/access.logtopic = nginx_log123456789101112131415161718192021222324## 讀取配置文件```gopackage mainimport ( &quot;fmt&quot; &quot;github.com/astaxie/beego/config&quot;)func main()&#123; //新增一個讀取配置文件實例 conf, err := config.NewConfig(&quot;ini&quot;,&quot;./logagent.conf&quot;) //[1] if err != nil&#123; fmt.Println(&quot;new config failed:&quot;,err) return &#125; port,err := conf.Int(&quot;server::listen_port&quot;) fmt.Println(&quot;port :&quot;,port) log_level := conf.String(&quot;logs::log_level&quot;) fmt.Println(&quot;log_Level :&quot;,log_level)&#125; NewConfig(adapterName,fileName) adapterName:欲讀取配置文件的格式 fileName:欲讀取配置文件名 日誌(log)庫 配置日誌庫logs.SetLogger(AdapterFile,config)的config參數為一json串 通常會使用json Marshal函數進行配置(較安全)，而非自己構造json字串 go get github.com/astaxie/beego/logs import &quot;github.com/astaxie/beego/logs&quot; 123456789101112131415161718192021222324252627282930313233package mainimport ( \"encoding/json\" \"fmt\" //導入日誌庫 \"github.com/astaxie/beego/logs\")func main()&#123; //Log的配置(config)放入map中 config := make(map[string]interface&#123;&#125;) config[\"filename\"] = \"./my.log\" //寫日誌的路徑及文件名 config[\"level\"] = logs.LevelDebug //日誌級別 //將log配置Marshal成json字串 configStr,err := json.Marshal(config) if err != nil&#123; fmt.Println(\"Config Marshal Failed:\",err) return &#125; //實例化一個logger對象 err = logs.SetLogger(logs.AdapterFile,string(configStr)) //log.AdapterFile為一常量 ---&gt; \"file\" if err != nil &#123; fmt.Println(\"SetLogger Failed:\",err) &#125; //格式化日誌並記錄到日誌文件中 logs.Debug(\"this is a test my name is %s\",\"stu01\") logs.Trace(\"this is a trace my name is %s\",\"stu02\") logs.Warn(\"this is a warn, my name is %s\",\"stu03\")&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2019","slug":"2019","permalink":"http://www.taroballz.com/tags/2019/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"Kafka","slug":"Kafka","permalink":"http://www.taroballz.com/tags/Kafka/"},{"name":"tailf","slug":"tailf","permalink":"http://www.taroballz.com/tags/tailf/"},{"name":"config","slug":"config","permalink":"http://www.taroballz.com/tags/config/"},{"name":"log","slug":"log","permalink":"http://www.taroballz.com/tags/log/"}]},{"title":"Golang網路編程-http編程","slug":"Go_http_program","date":"2019-03-17T16:00:00.000Z","updated":"2019-03-30T12:49:33.000Z","comments":true,"path":"2019/03/18/Go_http_program/","link":"","permalink":"http://www.taroballz.com/2019/03/18/Go_http_program/","excerpt":"introduction golang原生支持http 只需import &quot;net/http&quot;即可使用http相關的功能 goalng的http服務性能和nginx非常接近 只需幾行代碼就能實現一個簡單的web服務","text":"introduction golang原生支持http 只需import &quot;net/http&quot;即可使用http相關的功能 goalng的http服務性能和nginx非常接近 只需幾行代碼就能實現一個簡單的web服務 http Server實現 使用http.HandleFunc函數設置web路由，針對用戶輸入的url進行處理 傳入相對應用戶輸入的url，使用不同的函數進行處理 http.HandleFunc(web路由路徑,處理函數) http.ListenAndServe()將tcp編程的的Listen及Accept等代表server端函數都封裝了 1234567891011121314151617181920212223242526272829package mainimport ( \"fmt\" //引入http package \"net/http\")func Hello(w http.ResponseWriter,r *http.Request)&#123; fmt.Println(\"handle Hello\") _,_ = fmt.Fprintf(w,\"hello\")&#125;func update(w http.ResponseWriter,r *http.Request)&#123; fmt.Println(\"Update!!\") _,_ = fmt.Fprintf(w,\"updating!!!\")&#125;func main()&#123; //設置web路由規則，針對用戶輸入的url進行處理 http.HandleFunc(\"/\",Hello) http.HandleFunc(\"/update\",update) //開啟服務 err := http.ListenAndServe(\"0.0.0.0:8888\",nil) if err != nil &#123; fmt.Println(\"Listen Failed!!\") &#125;&#125; http Client 客戶端(Client)用於調用服務端(Server)的服務 其Get方法預設使用內部已實現的客戶端12345678910111213141516171819202122232425package mainimport ( \"fmt\" \"io/ioutil\" \"net/http\")func main()&#123; //參數可替換欲請求的網址 res,err := http.Get(\"http://taroballz.com\") if err !=nil &#123; fmt.Println(\"get err:\",err) return &#125; //成功Get到後結束時一定要記得關掉 defer res.Body.Close() //res.Body實現了Reader接口 data,err := ioutil.ReadAll(res.Body) if err !=nil&#123; fmt.Println(\"get data err:\",err) return &#125; fmt.Println(string(data))&#125; http常見請求 Get請求： 用於請求返回數據(讀) data位於url的後面 url長度有限制 沒有包體 Post請求： data位於包體中 其提交的data長度不受限制 用於更新資源 Put請求： 用於創建資源 Delete請求： 用於刪除資源 Head請求： 請求封包頭 通常用於查看服務正不正常，而不返回數據 http Head請求 http.Head(url):使用Head請求對應的url 其Head方法預設使用內部已實現的客戶端 123456789101112131415161718192021package mainimport ( \"fmt\" \"net/http\")var url_data []string = []string&#123;\"http://taroballz.com\", \"https://ccu.edu.tw\", \"http://baidu.com\"&#125;func main()&#123; for _,v := range url_data&#123; resp,err := http.Head(v) if err != nil &#123; fmt.Println(\"http head request failed:\",err) continue &#125; fmt.Println(\"request succ:\",resp.Status) &#125;&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2019","slug":"2019","permalink":"http://www.taroballz.com/tags/2019/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"網路編程","slug":"網路編程","permalink":"http://www.taroballz.com/tags/網路編程/"}]},{"title":"Golang資料結構-稀疏矩陣(sparse matrix)","slug":"Go_sparse_matrix","date":"2019-03-16T16:00:00.000Z","updated":"2019-03-17T15:13:43.000Z","comments":true,"path":"2019/03/17/Go_sparse_matrix/","link":"","permalink":"http://www.taroballz.com/2019/03/17/Go_sparse_matrix/","excerpt":"introduction 在數值分析中，大部分元素為零或是同一個值的矩陣。反之，如果大部分元素都非零或為不同值，則這個矩陣是稠密的。 處理方式： 記錄矩陣中共有多少行列(row,col,default(預設值)) 記錄有多少個不同的值 把具不同值的元素之行列與值 記錄在一小規模的陣列中，從而縮小程序的規模","text":"introduction 在數值分析中，大部分元素為零或是同一個值的矩陣。反之，如果大部分元素都非零或為不同值，則這個矩陣是稠密的。 處理方式： 記錄矩陣中共有多少行列(row,col,default(預設值)) 記錄有多少個不同的值 把具不同值的元素之行列與值 記錄在一小規模的陣列中，從而縮小程序的規模 稀疏矩陣保存 其相當於將原稀疏矩陣進行壓縮 原始矩陣轉成稀疏矩陣 遍歷矩陣，如果發現有元素之值不為默認值，創建一個有值節點(Node) 將其放入對應切片中1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package mainimport ( \"bufio\" \"fmt\" \"math/rand\" \"os\" \"time\")type Matrix_node struct &#123; row int col int val int&#125;func init()&#123; rand.Seed(time.Now().UnixNano())&#125;func rand_val(matrix *[10][10]int)&#123; for i:=0;i&lt;20;i++&#123; c := rand.Intn(10) r := rand.Intn(10) v := rand.Intn(100) matrix[c][r] = v &#125;&#125;func tranverse_matrix(matrix *[10][10]int,node_array *[]*Matrix_node)&#123; //標準的稀疏矩陣一開始的節點會記錄元素矩陣的規模（最大行，最大列及預設值） init_node := &amp;Matrix_node&#123; row:10, col:10, val:0, &#125; *node_array = append(*node_array,init_node) //遍歷矩陣 for i, row := range *matrix &#123; for j,v := range row &#123; //發現有元素之值不為默認值 if v != 0 &#123; //創建節點 Node := &amp;Matrix_node&#123; row:i, col:j, val:v, &#125; //於切片中加入節點 *node_array = append(*node_array,Node) &#125; &#125; &#125;&#125;func SaveData(filepath string, data []*Matrix_node)&#123; file,err := os.OpenFile(filepath,os.O_CREATE|os.O_WRONLY|os.O_TRUNC,0666) if err != nil &#123; fmt.Println(\"OpenFile Error:\",err) return &#125; defer file.Close() Writer := bufio.NewWriter(file) for _,v := range data &#123; line := fmt.Sprintf(\"%d\\t%d\\t%d\\n\",v.col,v.row,v.val) _,err := Writer.WriteString(line) if err != nil&#123; fmt.Println(\"Write string error:\",err) return &#125; _ = Writer.Flush() &#125;&#125;func main()&#123; //創建一個原始的數組 var origin_matrix [10][10]int = [10][10]int&#123;&#125; //於matrix中塞入隨機數據 rand_val(&amp;origin_matrix) for _,v := range origin_matrix &#123; fmt.Println(v) &#125; //轉成一個稀疏數組 Node_array := make([]*Matrix_node,0) tranverse_matrix(&amp;origin_matrix,&amp;Node_array) //儲存數據 SaveData(\"learning_note/data_structure/sparse_matrix/main/matrix.data\",Node_array)&#125; 稀疏矩陣轉成原始矩陣 創建一個原始矩陣 可根據稀疏矩陣的第一個節點知道其規模大小 必須跳過第一個節點進行恢復，否則會out of range 遍歷稀疏矩陣 讀取行、列、值在原數組上進行修改 1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport ( \"fmt\" \"io/ioutil\" \"strings\")type intslice []intfunc ReadData(fileName string)(data string)&#123; d,err := ioutil.ReadFile(fileName) if err != nil &#123; fmt.Println(\"Read Data Failed\",err) return &#125; data = string(d) return&#125;func main()&#123; filepath := \"learning_note/data_structure/sparse_matrix/main/matrix.data\" data := ReadData(filepath) data_array := strings.Split(data,\"\\n\") result := make([]intslice,0) for i,v := range data_array[:len(data_array)-1]&#123; var row,col,data = 0,0,0 _,err := fmt.Sscanf(v,\"%d\\t%d\\t%d\",&amp;row,&amp;col,&amp;data) if err != nil&#123; fmt.Println(\"strconvert Failed:\",err) &#125; if i == 0 &#123; for i:=0;i&lt;col;i++&#123; data := make(intslice,row) result = append(result,data) &#125; &#125;else&#123; result[row][col] = data &#125; &#125; for _,v := range result&#123; fmt.Println(v) &#125; &#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2019","slug":"2019","permalink":"http://www.taroballz.com/tags/2019/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"稀疏矩陣(sparse matrix)","slug":"稀疏矩陣-sparse-matrix","permalink":"http://www.taroballz.com/tags/稀疏矩陣-sparse-matrix/"}]},{"title":"Golang基礎-補充知識-工程管理與go install","slug":"Go_manage","date":"2019-02-15T16:00:00.000Z","updated":"2019-02-16T18:49:48.000Z","comments":true,"path":"2019/02/16/Go_manage/","link":"","permalink":"http://www.taroballz.com/2019/02/16/Go_manage/","excerpt":"工作區 Go代碼必須放在工作區中 工作區：一個對應於特定工程的目錄，其包含三個子目錄 src目錄：用於以代碼包的形式組織並保存Go源碼文件（必須存在） pkg目錄：用於存放go install命令構建安裝後的代碼包(包含原Golang庫的源碼文件)，生成相關的靜態庫文件(其會與所使用的os相對應) bin目錄：與pkg目錄類似，保存由go install命令生成的可執行程序","text":"工作區 Go代碼必須放在工作區中 工作區：一個對應於特定工程的目錄，其包含三個子目錄 src目錄：用於以代碼包的形式組織並保存Go源碼文件（必須存在） pkg目錄：用於存放go install命令構建安裝後的代碼包(包含原Golang庫的源碼文件)，生成相關的靜態庫文件(其會與所使用的os相對應) bin目錄：與pkg目錄類似，保存由go install命令生成的可執行程序 使用go install命令時須配置GOBIN及GOPATH環境變量","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"工程管理","slug":"工程管理","permalink":"http://www.taroballz.com/tags/工程管理/"}]},{"title":"深度學習-tensorflow基礎-讀取數據-API應用-圖像讀取","slug":"DL_imageReadAPI","date":"2019-01-06T08:41:00.000Z","updated":"2019-07-29T15:00:03.000Z","comments":true,"path":"2019/01/06/DL_imageReadAPI/","link":"","permalink":"http://www.taroballz.com/2019/01/06/DL_imageReadAPI/","excerpt":"Introduction圖像基本知識 在電腦中圖片是由pixel(像素)組成的 圖片的特徵值就是像素值(長度x寬度x通道數) 黑白圖片又稱為單通道圖片：每一個像素點只有一個值(灰度值)，介於0～255之間 彩色圖片又稱為三通道圖片：每一個像素點由RGB三個值組成","text":"Introduction圖像基本知識 在電腦中圖片是由pixel(像素)組成的 圖片的特徵值就是像素值(長度x寬度x通道數) 黑白圖片又稱為單通道圖片：每一個像素點只有一個值(灰度值)，介於0～255之間 彩色圖片又稱為三通道圖片：每一個像素點由RGB三個值組成 張量表達圖片數據圖像數字化三要素：長度、寬度、通道數 一通道：灰度值 三通道：RGB 三要素與張量的關係指定3-D張量：[長度,寬度,通道數(channel)] 通道數決定彩色或是黑白圖片 圖像基本操作機器學習進行分類時，每一個樣本必須保持特徵值數量一致(將所有圖片統一大小，像素值一樣) 目的 增加圖片數據的統一性 所有圖片轉換成指定大小 縮小圖片數據量，防止增加開銷 縮放圖片大小 tf.image.resize_images(images,size) resize過後的圖片可能會改變圖片的數據，整數(uint8)—-&gt;浮點數(float32) 一般圖片都是用uint8類型儲存，float32類型還原不了為一張圖片 uint8用於存儲：節約空間 float32用於提高矩陣計算的經度 但是計算都是使用float32進行計算 images 4-D形狀([batch, height, width, channels])張量的圖片數據 batch：幾張圖片 3-D形狀([height, width, channels])張量的圖片數據 size： 1-D int32張量 new_height, new_width：圖像的新尺寸，例如[200,200] 返回4-D格式 或 3-D格式的圖片 構造圖片文件隊列與讀取文字文件的文件隊列相同 構造讀取器 圖片是一張一張的讀取 tf.WholeFileReader() 將文件的全部內容作為值輸出的讀取器 常用於圖片讀取 返回一個圖像讀取器實例 method read(file_queue)：輸出將是一個文件名(key)和該文件的內容(value) 預設value為一張圖片的內容 圖片解碼其對應不同的圖片格式擁有不同的解碼器 JPEG tf.image.decode_jpeg(contents) 將JPEG編碼的圖像解碼為uint8類型的張量 contents：讀取器讀取出來的文件內容 也就是read方法的value內容 返回一個uint8張量 3-D形狀([height,width,channels]) PNG tf.image.decode_png(contents) 將PNG編碼的圖像解碼為uint8 或 uint16類型的張量 返回一個uint8 或 uint16張量類型 3-D形狀([height,width,channels]) 批處理在進行批處理之前長、寬、通道數全部都必須定義，不能有不確定的值，否則會報錯 利用set_shape方法固定長、寬、通道數 batch方法與文件批處理相同 讀取狗的圖片範例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import tensorflow as tfimport glob# 讀取狗的圖片並轉換成張量def picread(filelist): # 2. 構造文件隊列 file_queue = tf.train.string_input_producer(filelist) # 3. 構造圖片讀取器讀取圖片內容(預設值是讀取一張圖片) reader = tf.WholeFileReader() key,val = reader.read(file_queue) # 4. 對讀取圖片進行解碼 image_data = tf.image.decode_jpeg(val) # 讀取出來image_data為unit8類型，shape(?,?,?)，分別為長、寬、通道數 # 5. 處理圖片的大小(統一大小) image_resize = tf.image.resize_images(image_data,[200,200]) # 注意：批處理之前一定要把樣本的形狀固定[200,200,3] image_resize.set_shape([200,200,3]) # 6. 進行批處理 image_batch = tf.train.batch([image_resize],batch_size=100,num_threads=1,capacity=100) return image_batchif __name__ == '__main__': # 1. 找到文件，並放入列表 路徑+名字---&gt;列表當中 file_name = glob.glob(\"./dog_pic/*.jpg\") filelist = [path_name for path_name in file_name] image_batch = picread(filelist) # 開啟會話運行結果 with tf.Session() as sess: # 定義一個線程協調器 coord = tf.train.Coordinator() # 開啟讀文件的線程 threads = tf.train.start_queue_runners(sess,coord = coord) # 查看讀取的內容(模擬訓練) print(sess.run([image_batch])) # 回收子線程 coord.request_stop() coord.join(threads) Result1234567891011[array([[[[255. , 255. , 255. ], [255. , 255. , 255. ], [255. , 255. , 255. ], ..., [[199. , 98. , 56. ], [197.28 , 100.12 , 55.08 ], [204.24 , 103.479996 , 57.239998 ], ..., [129.4002 , 82.00026 , 69.40021 ], [109.520035 , 77.16 , 74.359985 ], [ 94.56012 , 72.20004 , 74.04001 ]]]], dtype=float32)] tips 讀取出來的圖片矩陣要儲存，為了節省空間最好使用uint8類型進行儲存 如要將圖片數據進行計算，為了提高精度需使用tf.cast()轉換類型的方法轉換成float32類型","categories":[{"name":"tensorflow深度學習","slug":"tensorflow深度學習","permalink":"http://www.taroballz.com/categories/tensorflow深度學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://www.taroballz.com/tags/tensorflow/"},{"name":"深度學習(Deep Learning)","slug":"深度學習-Deep-Learning","permalink":"http://www.taroballz.com/tags/深度學習-Deep-Learning/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"}]},{"title":"深度學習-tensorflow基礎-讀取數據-API應用-csv檔讀取","slug":"DL_csvReadAPI","date":"2019-01-01T16:01:00.000Z","updated":"2019-07-29T17:41:29.000Z","comments":true,"path":"2019/01/02/DL_csvReadAPI/","link":"","permalink":"http://www.taroballz.com/2019/01/02/DL_csvReadAPI/","excerpt":"構造文件名隊列(string_input_producer)不管任何形式的文件(csv,圖片,二進制)都會使用此API來構造文件名的隊列 tf.train.string_input_producer(string_tensor,shuffle=True) string_tensor：含有文件名的1階張量 列表裡面含有各個文件的路徑+文件名 可直接傳入列表，會將其轉換成一階張量 num_epochs： 當讀入的量比較少時，且批處理隊列所需要的數據量比較大時，會重複的使用已經讀取過的文件 預設是過無限次的數據，直到滿足批處理隊列的大小為止，或者可限定讀取次數 shuffle：bool值，是否亂序讀取，預設為True 返回一個具有路徑+檔名的字符串隊列 將輸出字符串(例如：文件名)輸入到管道隊列","text":"構造文件名隊列(string_input_producer)不管任何形式的文件(csv,圖片,二進制)都會使用此API來構造文件名的隊列 tf.train.string_input_producer(string_tensor,shuffle=True) string_tensor：含有文件名的1階張量 列表裡面含有各個文件的路徑+文件名 可直接傳入列表，會將其轉換成一階張量 num_epochs： 當讀入的量比較少時，且批處理隊列所需要的數據量比較大時，會重複的使用已經讀取過的文件 預設是過無限次的數據，直到滿足批處理隊列的大小為止，或者可限定讀取次數 shuffle：bool值，是否亂序讀取，預設為True 返回一個具有路徑+檔名的字符串隊列 將輸出字符串(例如：文件名)輸入到管道隊列 構造文件閱讀器用於讀取隊列內容，不同文件格式所使用的閱讀器亦不同 文本文件 通常是以逗號作為分隔值的csv或txt格式 預設是按行讀取，且一次只讀取一行 tf.TextLineReader() 返回一個讀取器的實例 讀取TfRecords文件 tf.TFRecordReader() 返回一個讀取器實例 method以上三種讀取器都有一個共同的方法： read(file_queue)：從隊列中讀取指定數量內容 返回一個tensor元組 key為文件名;value為一個樣本內容(行,字節) 文件內容解碼器由於從文件中讀取的是字符串或bits，需要函數去解析這些內容到張量 CSV解碼 tf.decode_csv(records,record_defaults=None,field_delim=None,name=None) records：tensor型字符串，每個字符串是csv中讀取器讀取出來的記錄行 也就是閱讀器read方法返回的value值 field_delim：分割符號，預設的分割符號為”,” record_defaults：決定所得張量類型(指定每樣本的每一column的類型)，並設置一個缺失值的默認值 可按照不同數據類型進行解碼 [[1],[&quot;None&quot;],[0.0]]：有三個colmn分別為int類型(缺失值預設為1)，string型(缺失值預設為”None”)，float型(缺失值預設為0.0) 必須為一個二維的列表 返回每個樣本每一列之值 一列有多少值就用多少變量去接收 將csv轉換為張量，與tf.TextLineReader搭配使用 開啟子線程操作開啟線程進行讀取操作(於會話當中運行)，為固定寫法 tf.train.strat_queue_runners(sess=None,coord=None) 收集所有圖中的隊列線程，並啟動線程 coord：其開啟線程後仍需要有回收的機制，因此須定義線程協調器 範例(讀取csv文件)欲讀取A.csv,B.csv,C.csv中的數據其數據內容如下A.csv:123Alpha1,A1Alpha2,A2Alpha3,A3 B.csv:123Beta1,B1Beta2,B2Beta3,B3 C.csv:123Gama1,C1Gama2,C2Gama3,C3 代碼123456789101112131415161718192021222324252627282930313233343536373839import tensorflow as tfimport os# 定一個csv讀取函數其接收存放數據的路徑+文件列表def csvread(FileList): # 1. 構造文件隊列 file_queue = tf.train.string_input_producer(FileList) # 2. 構造csv閱讀器讀取隊列文件中的數據(按行讀取) Reader = tf.TextLineReader() key, val = Reader.read(file_queue) # 調用閱讀器的read方法，返回key與value # 3. 對每一行內容解碼 records = [[\"None\"],[\"None\"]] # 根據column數決定二維陣列中有幾個列表，並填入默認值 Feature,Label = tf.decode_csv(val,record_defaults=records) #共兩列數據因此用兩個變量接收 return Feature,Label # 將每一列得到的值返回if __name__ == '__main__': # 找到欲訓練的文件，將所有文件的 路徑+文件名 放入列表 FileName = os.listdir(\"./Training_Data\") filelist = [os.path.join(\"./Training_Data/\",name) for name in FileName] # 拼接路徑 Feature,Label = csvread(filelist) with tf.Session() as sess: # 定義一個線程協調器 coord = tf.train.Coordinator() # 開啟讀取文件的線程 threads = tf.train.start_queue_runners(sess,coord=coord) # 讀取內容(訓練操作) print(sess.run([Feature,Label])) # 回收子線程 coord.request_stop() coord.join(threads) Result1[b&apos;Alpha1&apos;, b&apos;A1&apos;] 讀取一行的數據，如想要讀取多個數據須進行批處理操作 管道讀端批處理由於預設只會讀取一個樣本，如要進行批處理(進行多個數據的讀取)，使用以下兩個API，便於之後指定每批次多個樣本的訓練 tf.train.batch(tensors,batch_size,num_threads=1,capacity=32,name=None) 其可讀取指定大小(個數)的張量 tensors：可以是包含張量的列表(一行有多少數據)，欲批處理的內容都要放到列表當中 batch_size：從隊列中讀取的批處理大小 每一次讀取多少條數據 批處理大小，跟隊列，數據的數量多少沒有影響，只決定當前此批次取多少數據 取的數據有無重複，對訓練並無影響 num_threads：進入隊列的線程數 capacity：整數，隊列中元素的最大數量 返回批處理完成多個value值的tensor tf.train.shuffle_batch(tensors,batch_size,num_threads=1,capacity,min_after_dequeue) 亂序讀取指定大小(個數)的張量 min_after_dequeue：留下隊列裡的張量個數，能夠保持隨機打亂的狀態 改善代碼12345678910111213141516171819202122232425262728293031323334353637import tensorflow as tfimport osdef csvread(FileList): file_queue = tf.train.string_input_producer(FileList) Reader = tf.TextLineReader() key, val = Reader.read(file_queue) # 調用閱讀器的read方法，返回key與value records = [[\"None\"],[\"None\"]] # 根據column數決定二維陣列中有幾個列表，並填入默認值 Feature,Label = tf.decode_csv(val,record_defaults=records) #共兩列數據因此用兩個變量接收 # 4. 欲讀取多個數據，批處理 Feature_batch, Label_batch = tf.train.batch([Feature,Label],batch_size=20,num_threads=1,capacity=9) return Feature_batch,Label_batch # 將每一列得到的值返回if __name__ == '__main__': FileName = os.listdir(\"./Training_Data\") filelist = [os.path.join(\"./Training_Data/\",name) for name in FileName] # 拼接路徑 Feature_batch,Label_batch = csvread(filelist) with tf.Session() as sess: coord = tf.train.Coordinator() threads = tf.train.start_queue_runners(sess,coord=coord) # 讀取內容(訓練操作)，要取幾批次的數據進行訓練自行使用for循環訓練 print(sess.run([Feature_batch,Label_batch])) coord.request_stop() coord.join(threads) Result1234567[array([b&apos;Beta1&apos;, b&apos;Beta2&apos;, b&apos;Beta3&apos;, b&apos;Gama1&apos;, b&apos;Gama2&apos;, b&apos;Gama3&apos;, b&apos;Alpha1&apos;, b&apos;Alpha2&apos;, b&apos;Alpha3&apos;, b&apos;Gama1&apos;, b&apos;Gama2&apos;, b&apos;Gama3&apos;, b&apos;Alpha1&apos;, b&apos;Alpha2&apos;, b&apos;Alpha3&apos;, b&apos;Beta1&apos;, b&apos;Beta2&apos;, b&apos;Beta3&apos;, b&apos;Gama1&apos;, b&apos;Gama2&apos;], dtype=object), array([b&apos;B1&apos;, b&apos;B2&apos;, b&apos;B3&apos;, b&apos;C1&apos;, b&apos;C2&apos;, b&apos;C3&apos;, b&apos;A1&apos;, b&apos;A2&apos;, b&apos;A3&apos;, b&apos;C1&apos;, b&apos;C2&apos;, b&apos;C3&apos;, b&apos;A1&apos;, b&apos;A2&apos;, b&apos;A3&apos;, b&apos;B1&apos;, b&apos;B2&apos;, b&apos;B3&apos;, b&apos;C1&apos;, b&apos;C2&apos;], dtype=object)] 即使文本中只有9條數據，但此批次取20個樣本，會有重複的樣本被取出，但對訓練並無影響 但一般batch_size 跟 capacity都設為相同之值","categories":[{"name":"tensorflow深度學習","slug":"tensorflow深度學習","permalink":"http://www.taroballz.com/categories/tensorflow深度學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://www.taroballz.com/tags/tensorflow/"},{"name":"深度學習(Deep Learning)","slug":"深度學習-Deep-Learning","permalink":"http://www.taroballz.com/tags/深度學習-Deep-Learning/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"}]},{"title":"深度學習-tensorflow基礎-讀取數據-文件讀取流程","slug":"DL_ReadProcess","date":"2019-01-01T06:19:00.000Z","updated":"2019-07-29T13:52:49.000Z","comments":true,"path":"2019/01/01/DL_ReadProcess/","link":"","permalink":"http://www.taroballz.com/2019/01/01/DL_ReadProcess/","excerpt":"Introduction 在tensorflow中讀取文件有既定的流程 不同的文件格式(csv,jpeg,binary_file)，在tensorflow中有不同讀取的API可以使用","text":"Introduction 在tensorflow中讀取文件有既定的流程 不同的文件格式(csv,jpeg,binary_file)，在tensorflow中有不同讀取的API可以使用 流程我們欲使用的數據可能存在不同的文件中，因此API會進行以下操作 構造一個欲讀取文件的隊列 文件隊列中包含路徑+文件名 可亂序置入隊列中也可順序置入 讀取(read)隊列文件的內容 預設讀取時，只讀取一個樣本 讀取的文件格式不一樣，所使用的API也不一樣 文件格式： csv文件：讀取一行數據 二進制文件(binary)：指定一個樣本的bytes讀取 圖片文件(jpeg,png…)：一張一張的讀取 解碼(decode) 讀取時只返回一個樣本的結果，因此也只解碼一個樣本的內容 批處理 構造一隊列 將解碼後的文件放入隊列中(A文件A1樣本,A文件A2樣本……) 訓練模型 主線程拿取批處理隊列的樣本，進行訓練 手動開啟線程 前面四步則由子線程完成 tips 前面提到的隊列，隊列管理器，線程協調器皆有完整的固定API已經封裝好直接調用，不需在自己定義","categories":[{"name":"tensorflow深度學習","slug":"tensorflow深度學習","permalink":"http://www.taroballz.com/categories/tensorflow深度學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://www.taroballz.com/tags/tensorflow/"},{"name":"深度學習(Deep Learning)","slug":"深度學習-Deep-Learning","permalink":"http://www.taroballz.com/tags/深度學習-Deep-Learning/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"}]},{"title":"深度學習-tensorflow基礎-讀取數據-異步讀取","slug":"DL_asynchronous_read_operate","date":"2018-12-30T17:50:00.000Z","updated":"2019-07-29T17:59:21.000Z","comments":true,"path":"2018/12/31/DL_asynchronous_read_operate/","link":"","permalink":"http://www.taroballz.com/2018/12/31/DL_asynchronous_read_operate/","excerpt":"Introduction當數據量很大時，入隊列操作從硬盤讀取數據，放入內存中，主線程須等待入隊列操作完成，才能進行訓練，此時會話裡可以運行多個線程，實現異步讀取","text":"Introduction當數據量很大時，入隊列操作從硬盤讀取數據，放入內存中，主線程須等待入隊列操作完成，才能進行訓練，此時會話裡可以運行多個線程，實現異步讀取 隊列管理器(QueueRunner) 其較為高效 雖然叫做管理器，但其是用來創建線程 不能與threading(偽多線程)庫混用 tf.train.QueueRunner(queue,enqueue_ops=None)創建一個QueueRunner queue：先前定義的隊列 enqueue_ops：添加線程的隊列操作列表(指定開啟幾個線程，並指定這些線程去做什麼操作) 列表[]中輸入線程將執行的操作 例如[]*2：指定兩個線程進行此操作 開啟的線程會有上限數 create_threads(sess,coord=None,start=False)：創建線程來運行給定會話的入隊操作 start：bool值 True：啟動線程 False：調用者必須調用start()啟動線程 coord：線程協調器(後面線程管理需要用到) 返回一個隊列管理器op tf.train.start_queue_runners(sess=None, coord=None)函數會要求圖中的每個QueueRunner啟動它的運行隊列操作的線程 須在會話中開啟 收集圖中所有隊列線程，預設同時開啟線程 sess:所在的會話 coord：線程協調器 返回所有的線程 實現異步操作通過隊列管理器來實現變量+1、入隊、主線程出隊列的操作 子線程不斷的往隊列放數據，主線程不斷的往裡頭取數據 兩者操作彼此互不干擾12345678910111213141516171819202122232425262728293031import tensorflow as tf# 模擬異步的過程# 子線程存入樣本，主線程讀取樣本# 定義一個隊列Q = tf.FIFOQueue(1000,dtypes=tf.float32)# 定義子線程要執行的任務(值+1，放入隊列當中)var = tf.Variable(0.0,dtype=tf.float32)# 實現一個自增加法(assign_add)，把本身做加法並返回給自身data = tf.assign_add(var,tf.constant(1.0))en_q = Q.enqueue(data)# 定義隊列管理器op，指定多少個子線程，子線程該做什麼qr = tf.train.QueueRunner(Q,enqueue_ops=[en_q]*2) # 使用兩個線程完成en_q這個任務# 初始化變量opinit_var_op = tf.global_variables_initializer()with tf.Session() as sess: # 初始化變量 sess.run(init_var_op) # 真正的開啟子線程(必須在會話中開啟) threads = qr.create_threads(sess,start=True) # 主線程不斷的去讀取數據 for i in range(300): print(sess.run(Q.dequeue())) Result1234567891011121314152.019.043.068.088.0108.0135.0.........1298.01299.01300.0tensorflow.python.framework.errors_impl.CancelledError: Enqueue operation was cancelled [[Node: fifo_queue_enqueue = QueueEnqueueV2[Tcomponents=[DT_FLOAT], timeout_ms=-1, _device=&quot;/job:localhost/replica:0/task:0/device:CPU:0&quot;](fifo_queue, AssignAdd)]] 最後會報錯的原因是因為，主線程結束的情況下，Session被關閉，且資源被釋放，但子線程並未回收還在執行，因此報錯 因此須管理子線程，並確實的回收子線程(線程協調器) 線程協調器用作管理線程 tf.train.Coordinator():線程協調員，實現一個簡單的機制來協調一組線程的終止 返回一個線程協調器的實例 method request_stop()：要求線程終止 should_stop()：檢查是否要求停止 join(threads=None,stop_grace_period_secs=120)：等待線程終止 改善後1234567891011121314151617181920212223242526272829import tensorflow as tfQ = tf.FIFOQueue(1000,dtypes=tf.float32)var = tf.Variable(0.0,dtype=tf.float32)data = tf.assign_add(var,tf.constant(1.0))en_q = Q.enqueue(data)qr = tf.train.QueueRunner(Q,enqueue_ops=[en_q]*2) init_var_op = tf.global_variables_initializer()with tf.Session() as sess: sess.run(init_var_op) # 開啟線程管理器 coord = tf.train.Coordinator() # coord須指定線程管理器的對象 threads = qr.create_threads(sess,coord=coord,start=True) for i in range(300): print(sess.run(Q.dequeue())) # 回收子線程 coord.request_stop() coord.join(threads)","categories":[{"name":"tensorflow深度學習","slug":"tensorflow深度學習","permalink":"http://www.taroballz.com/categories/tensorflow深度學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://www.taroballz.com/tags/tensorflow/"},{"name":"深度學習(Deep Learning)","slug":"深度學習-Deep-Learning","permalink":"http://www.taroballz.com/tags/深度學習-Deep-Learning/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"}]},{"title":"深度學習-tensorflow基礎-讀取數據-隊列與線程","slug":"DL_Queue","date":"2018-12-30T11:15:00.000Z","updated":"2018-12-30T11:18:39.000Z","comments":true,"path":"2018/12/30/DL_Queue/","link":"","permalink":"http://www.taroballz.com/2018/12/30/DL_Queue/","excerpt":"Introduction在訓練model時最重要的就是數據，數據通常儲存於文件當中，早期在機器學習章程，我們使用pandas讀取數據但在tensorflow中，提供的各種優化的方式來讀取數據","text":"Introduction在訓練model時最重要的就是數據，數據通常儲存於文件當中，早期在機器學習章程，我們使用pandas讀取數據但在tensorflow中，提供的各種優化的方式來讀取數據 在計算爭分奪秒的時候，需要去提高IO讀取的速度？ 計算(CPU)操作 相比 IO(硬碟讀取)操作 快非常多 如果利用IO操作將1G甚至2G文件一次讀取到記憶體中 內存消耗嚴重 一次性讀取後，在一次性訓練，嚴重影響效率 讀取的速度太慢，訓練的時間嚴重被延後 tensorflow優化文件讀取 tensorflow提供多線程讀取的機制 在tensorflow當中的多線程是真正的多線程( 並行(非併發) 的執行任務) 提供隊列(Queue)機制 提供專屬的文件格式 tfrecords(非一般文件格式csv或圖片格式png,jpeg等) 提高讀取速度 提高解析文件速度 解決一次性讀取數據的問題 使用多線程開啟多任務：創建並開啟子線程讀取數據 適時的讀取數據並訓練模型：讀取100個數據，拿100個數據訓練模型，再讀取100個 placeholder(佔位符) Queue(隊列) Tensorflow隊列 其與python自帶的隊列庫使用方法大同小異 在訓練樣本時，希望讀入的訓練樣本是有序的 tf.FIFOQueue：先進先出隊列，按順序出隊列 tf.RandomShuffleQueue：隨機出隊列 FIFOQueue使用tf.FIFOQueue(capacity,dtypes,name=&quot;fifo_queue&quot;)創建一個先進先出的順序對元素進行排隊的隊列 capacity：整數，能儲存在此隊列中的元素數量的上限 dtypes：隊列存儲的數據類型 name：隊列的名字 method dequeue(name=None) 返回一個出隊列操作 enqueue(vals,name=None) 返回一個入隊列操作 enqueue_many(vals,name=None) 多個數據同時入隊列 vals列表或者元組 返回一個進隊列操作(op) size(name=None) 返回當前隊列存放多少數據 利用隊列實現同步同步就是傳統先放完數據，再去取數據訓練 完成一個數據出隊列+1後入隊列操作12345678910111213141516171819202122232425262728293031import tensorflow as tf#模擬同步流程# 1.定義一個隊列Q = tf.FIFOQueue(3,dtypes=tf.float32)# 2.先放入初始數據到隊列中enq_many = Q.enqueue_many([[0.1,0.2,0.3],]) #[註2]# 3. 定義處理數據的邏輯過程(取出數據，+1，重新入隊列)# 取出數據de_q = Q.dequeue()# 對取出的數據+1(因為有重載機制 +1會轉換為tensor類型)new_data = de_q + 1# 重新將新數據入隊列en_q = Q.enqueue(new_data)with tf.Session() as sess: # 初始化隊列，運行前面定義好的圖 sess.run(enq_many) # 模擬訓練過程 for i in range(100): # 邏輯過程不需要全部執行[註1] sess.run(en_q) # 取出數據 for i in range(Q.size().eval()): # Q.size()為op因此須先運行(可用.eval()運行op取值) print(sess.run(Q.dequeue())) 在tensorflow當中，運行op是有依賴性的，也就是在運行最後一個操作(op)時，其會回溯到最原始的op將其執行，直到指定的op執行完畢為止 因此定義圖(graph)時要是有流程的依賴性，只要執行最後一個op即可 因en_q操作含有new_data操作，且new_data操作中又含有de_q操作，因此只要運行en_q前面的op都會一起執行 在傳入多個數據時應讓其認為是多個數據而非一個張量 使用[[data1,data2,data3],]來確保傳入的為三個數據(二維)，而非[data1,data2,data3]一個張量(一維) 如表示元組(tuple)應為(5,)而非(5) Result12333.233.334.1","categories":[{"name":"tensorflow深度學習","slug":"tensorflow深度學習","permalink":"http://www.taroballz.com/categories/tensorflow深度學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://www.taroballz.com/tags/tensorflow/"},{"name":"深度學習(Deep Learning)","slug":"深度學習-Deep-Learning","permalink":"http://www.taroballz.com/tags/深度學習-Deep-Learning/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"}]},{"title":"深度學習-tensorflow基礎-自定義命令行參數","slug":"DL_selfDefCommandline","date":"2018-12-09T19:44:00.000Z","updated":"2018-12-09T19:45:28.000Z","comments":true,"path":"2018/12/10/DL_selfDefCommandline/","link":"","permalink":"http://www.taroballz.com/2018/12/10/DL_selfDefCommandline/","excerpt":"Introduction可在程序運行前在不修改程序的情況下，去實時修改一些我們定義好可改變的參數 類似於sys.argv的功能 tensorflow本身自帶一樣的功能 常應用在設定訓練次數或是學習率 流程: 首先定義有哪些參數需要在運行時指定 程序當中獲取定義命令行參數 替換要改變的參數","text":"Introduction可在程序運行前在不修改程序的情況下，去實時修改一些我們定義好可改變的參數 類似於sys.argv的功能 tensorflow本身自帶一樣的功能 常應用在設定訓練次數或是學習率 流程: 首先定義有哪些參數需要在運行時指定 程序當中獲取定義命令行參數 替換要改變的參數 定義需要修改的參數(app.flags)使用tf.app.flags支持應用從命令行接受參數，可以用來指定集群配置等。在tf.app.flags下面有各種定義接受不同參數的類型 DEFINE_string(flag_name,default_value,docstring) DEFINE_integer(flag_name,default_value,docstring) DEFINE_boolean(flag_name,default_value,docstring) DEFINE_float(flag_name,default_value,docstring) flag_name：指定參數名字 default_value：指定默認值 docstring：對此參數的說明 獲取定義命令行參數(app.flags.FLAGS)使用tf.app.flags.FLAGS獲取定義好的參數 之後可以使用tf.app.flags.FLAGS.參數名字獲取道參數 但每次獲取參數名字太長，可以先把前面賦值給一變量在獲取12FLAGS = tf.app.flags.FLAGSFLAGS.參數名字 範例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import tensorflow as tfimport os# 1. 定義有哪些參數需要在運行時指定tf.app.flags.DEFINE_integer(\"max_step\",100,\"模型訓練的步數\")tf.app.flags.DEFINE_float(\"learning_rate\",0.1,\"學習率\")tf.app.flags.DEFINE_string(\"ckpt_path\",\" \",\"模型文件加載路徑\")# 2. 定義獲取上面 定義命令行參數的物件FLAGS = tf.app.flags.FLAGS# 3. 替換要改變的參數def LinearRegression(): with tf.variable_scope(\"data_preparation\"): X = tf.random_normal([100,1],mean=1.75,stddev=0.5, name=\"x_data\") y_true = tf.matmul(X,[[0.7]]) + 0.8 with tf.variable_scope(\"LinearRegression_model_build\"): weight = tf.Variable(tf.random_normal([1,1],mean=0.0,stddev=1.0),name=\"w\") #必須用變量定義才能優化(改變) bias = tf.Variable(0.0,name=\"bias\") y_predict = tf.matmul(X,weight) + bias with tf.variable_scope(\"loss_calculate\"): loss = tf.reduce_mean(tf.square(y_true - y_predict)) with tf.variable_scope(\"optimize\"): #替換學習率 train_op = tf.train.GradientDescentOptimizer(FLAGS.learning_rate).minimize(loss) tf.summary.scalar(\"Loss\",loss) tf.summary.histogram(\"Weight\",weight) tf.summary.scalar(\"Bias\",bias) merged = tf.summary.merge_all() init_var_op = tf.global_variables_initializer() Saver = tf.train.Saver() with tf.Session() as sess: sess.run(init_var_op) print(\"起始初始化權重：%f, 初始化偏置：%f\"%(weight.eval(),bias.eval())) FileWriter = tf.summary.FileWriter(\"./summary/\",graph=sess.graph) if os.path.exists(\"/Volumes/MacData/MEGA/pythonwork/ML_study/tensorflow_tutorial/checkpoint_document/checkpoint\"): # 替換模型加載路徑 Saver.restore(sess,FLAGS.ckpt_path) print(\"加載模型後 權重：%f, 偏置：%f\" % (weight.eval(), bias.eval())) #替換學習步數 for i in range(FLAGS.max_step): sess.run(train_op) summary = sess.run(merged) FileWriter.add_summary(summary,i) if i%50 == 0: print(\"優化%d次後 權重：%f, 優化偏置：%f\" % (i,weight.eval(), bias.eval())) else: Saver.save(sess, \"/Volumes/MacData/MEGA/pythonwork/ML_study/tensorflow_tutorial/checkpoint_document/LinearRegressionModel\")if __name__ == '__main__': LinearRegression() 執行腳本1python commandline.py --max_step=300 --learning_rate=0.05 --ckpt_path=/Volumes/MacData/MEGA/pythonwork/ML_study/tensorflow_tutorial/checkpoint_document/LinearRegressionModel Result12345678起始初始化權重：0.258629, 初始化偏置：0.000000加載模型後 權重：0.700000, 偏置：0.799999優化0次後 權重：0.700000, 優化偏置：0.799999優化50次後 權重：0.700000, 優化偏置：0.799999優化100次後 權重：0.700000, 優化偏置：0.799999優化150次後 權重：0.700000, 優化偏置：0.799999優化200次後 權重：0.700000, 優化偏置：0.799999優化250次後 權重：0.700000, 優化偏置：0.799999","categories":[{"name":"tensorflow深度學習","slug":"tensorflow深度學習","permalink":"http://www.taroballz.com/categories/tensorflow深度學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://www.taroballz.com/tags/tensorflow/"},{"name":"深度學習(Deep Learning)","slug":"深度學習-Deep-Learning","permalink":"http://www.taroballz.com/tags/深度學習-Deep-Learning/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"}]},{"title":"深度學習-tensorflow基礎-模型的保存與加載","slug":"DL_model_SaveRestore","date":"2018-12-09T17:57:00.000Z","updated":"2018-12-09T17:58:08.000Z","comments":true,"path":"2018/12/10/DL_model_SaveRestore/","link":"","permalink":"http://www.taroballz.com/2018/12/10/DL_model_SaveRestore/","excerpt":"Introduction 可保存目前為止訓練的結果，等待繼續訓練或使用 完整模型儲存的方式應該每訓練一段步數後就保存一些成果，例如權重、偏置等變量 模型的保存與加載預設也是保存及加載變量值","text":"Introduction 可保存目前為止訓練的結果，等待繼續訓練或使用 完整模型儲存的方式應該每訓練一段步數後就保存一些成果，例如權重、偏置等變量 模型的保存與加載預設也是保存及加載變量值 保存模型 模型的保存就是將訓練後改變的變量儲存起來 保存模型的文件格式為checkpoint文件(檢查點文件) train.Saver使用tf.train.Saver(var_list=None,max_to_keep=5)返回一個saver物件 var_list：指定要保存和還原的變量，可以作為一個dict或是一個list傳遞進去 max_to_keep：指示要保留的最近檢查點文件的最大數量 創建新文件時，會刪除較舊的文件 如果無舊文件，則保留所有檢查點文件，預設為5(即保留最新的5個檢查點文件) 使用返回的saver物件去操作保存(save)或是加載(restore) saver.save(sess,&quot;保存路徑及模型名&quot;) saver.restore(sess,&quot;加載路徑及模型名&quot;) 範例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import tensorflow as tfdef LinearRegression(): with tf.variable_scope(\"data_preparation\"): X = tf.random_normal([100,1],mean=1.75,stddev=0.5, name=\"x_data\") y_true = tf.matmul(X,[[0.7]]) + 0.8 with tf.variable_scope(\"LinearRegression_model_build\"): weight = tf.Variable(tf.random_normal([1,1],mean=0.0,stddev=1.0),name=\"w\") #必須用變量定義才能優化(改變) bias = tf.Variable(0.0,name=\"bias\") y_predict = tf.matmul(X,weight) + bias with tf.variable_scope(\"loss_calculate\"): loss = tf.reduce_mean(tf.square(y_true - y_predict)) with tf.variable_scope(\"optimize\"): train_op = tf.train.GradientDescentOptimizer(0.1).minimize(loss) tf.summary.scalar(\"Loss\",loss) tf.summary.histogram(\"Weight\",weight) tf.summary.scalar(\"Bias\",bias) merged = tf.summary.merge_all() init_var_op = tf.global_variables_initializer() # 定義一個 保存/加載 模型的物件 Saver = tf.train.Saver() with tf.Session() as sess: sess.run(init_var_op) print(\"起始初始化權重：%f, 初始化偏置：%f\"%(weight.eval(),bias.eval())) FileWriter = tf.summary.FileWriter(\"./summary/\",graph=sess.graph) for i in range(1000): sess.run(train_op) summary = sess.run(merged) FileWriter.add_summary(summary,i) if i%50 == 0: print(\"優化%d次後 權重：%f, 優化偏置：%f\" % (i,weight.eval(), bias.eval())) else: #訓練完成後保存模型 Saver.save(sess, \"/Volumes/MacData/MEGA/pythonwork/ML_study/tensorflow_tutorial/checkpoint_document/LinearRegressionModel\")if __name__ == '__main__': LinearRegression() Result在欲儲存的路徑下會多了四個文件分別如下 checkpoint文件中，只記載model儲存的位置及檔名 變量數據皆保存在 後綴名為.data-00000-of-00001的文件中 每次更新時會一直往後加1 data-00001-of-00002 data-00002-of-00003 加載模型 再次訓練之前應先加載模型 加載後會覆蓋graph中使用變量定義的參數，例如：權重(weight)，偏置(bias) 與儲存模型一樣須創建一個 加載/儲存的 saver物件，調用restore()方法加載 saver.restore(sess,&quot;加載路徑及模型名&quot;) 範例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import tensorflow as tfimport osdef LinearRegression(): with tf.variable_scope(\"data_preparation\"): X = tf.random_normal([100,1],mean=1.75,stddev=0.5, name=\"x_data\") y_true = tf.matmul(X,[[0.7]]) + 0.8 with tf.variable_scope(\"LinearRegression_model_build\"): weight = tf.Variable(tf.random_normal([1,1],mean=0.0,stddev=1.0),name=\"w\") #必須用變量定義才能優化(改變) bias = tf.Variable(0.0,name=\"bias\") y_predict = tf.matmul(X,weight) + bias with tf.variable_scope(\"loss_calculate\"): loss = tf.reduce_mean(tf.square(y_true - y_predict)) with tf.variable_scope(\"optimize\"): train_op = tf.train.GradientDescentOptimizer(0.1).minimize(loss) tf.summary.scalar(\"Loss\",loss) tf.summary.histogram(\"Weight\",weight) tf.summary.scalar(\"Bias\",bias) merged = tf.summary.merge_all() init_var_op = tf.global_variables_initializer() # 定義一個 加載/保存 模型的物件 Saver = tf.train.Saver() with tf.Session() as sess: sess.run(init_var_op) print(\"起始初始化權重：%f, 初始化偏置：%f\"%(weight.eval(),bias.eval())) FileWriter = tf.summary.FileWriter(\"./summary/\",graph=sess.graph) # 再次訓練之前先加載模型，覆蓋模型中利用變量定義的參數 if os.path.exists(\"/Volumes/MacData/MEGA/pythonwork/ML_study/tensorflow_tutorial/checkpoint_document/checkpoint\"): Saver.restore(sess,\"/Volumes/MacData/MEGA/pythonwork/ML_study/tensorflow_tutorial/checkpoint_document/LinearRegressionModel\") print(\"加載模型後 權重：%f, 偏置：%f\" % (weight.eval(), bias.eval())) # 從上次訓練結果的地方開始訓練 for i in range(1000): sess.run(train_op) summary = sess.run(merged) FileWriter.add_summary(summary,i) if i%50 == 0: print(\"優化%d次後 權重：%f, 優化偏置：%f\" % (i,weight.eval(), bias.eval())) else: #訓練完成後保存模型 Saver.save(sess, \"/Volumes/MacData/MEGA/pythonwork/ML_study/tensorflow_tutorial/checkpoint_document/LinearRegressionModel\")if __name__ == '__main__': LinearRegression() Result12345678910111213141516171819202122起始初始化權重：0.093984, 初始化偏置：0.000000加載模型後 權重：0.700002, 偏置：0.799997優化0次後 權重：0.700002, 優化偏置：0.799997優化50次後 權重：0.700001, 優化偏置：0.799998優化100次後 權重：0.700001, 優化偏置：0.799999優化150次後 權重：0.700001, 優化偏置：0.799999優化200次後 權重：0.700001, 優化偏置：0.799999優化250次後 權重：0.700001, 優化偏置：0.799999優化300次後 權重：0.700001, 優化偏置：0.799999優化350次後 權重：0.700001, 優化偏置：0.799999優化400次後 權重：0.700000, 優化偏置：0.799999優化450次後 權重：0.700000, 優化偏置：0.799999優化500次後 權重：0.700000, 優化偏置：0.799999優化550次後 權重：0.700000, 優化偏置：0.799999優化600次後 權重：0.700000, 優化偏置：0.799999優化650次後 權重：0.700000, 優化偏置：0.799999優化700次後 權重：0.700000, 優化偏置：0.799999優化750次後 權重：0.700000, 優化偏置：0.799999優化800次後 權重：0.700000, 優化偏置：0.799999優化850次後 權重：0.700000, 優化偏置：0.799999優化900次後 權重：0.700000, 優化偏置：0.799999優化950次後 權重：0.700000, 優化偏置：0.799999 可以看到加載後的模型就是上次訓練最後的結果，其又被繼續練，並儲存","categories":[{"name":"tensorflow深度學習","slug":"tensorflow深度學習","permalink":"http://www.taroballz.com/categories/tensorflow深度學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://www.taroballz.com/tags/tensorflow/"},{"name":"深度學習(Deep Learning)","slug":"深度學習-Deep-Learning","permalink":"http://www.taroballz.com/tags/深度學習-Deep-Learning/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"}]},{"title":"深度學習-tensorflow基礎-變量顯示","slug":"DL_Variable_display","date":"2018-12-09T10:27:00.000Z","updated":"2019-07-28T08:35:56.000Z","comments":true,"path":"2018/12/09/DL_Variable_display/","link":"","permalink":"http://www.taroballz.com/2018/12/09/DL_Variable_display/","excerpt":"Introduction 目的是為了觀察模型的參數(權重、偏置)，損失值等變量值的變化 觀察訓練情形如何，可以實時的於tensorboard中以圖形化的方式顯示 在大量資料且長時間的訓練能快速掌握目前訓練的情況 因此需添加變量在tensorboard中，觀察其變化狀況 收集變量 合併變量寫入事件文件中","text":"Introduction 目的是為了觀察模型的參數(權重、偏置)，損失值等變量值的變化 觀察訓練情形如何，可以實時的於tensorboard中以圖形化的方式顯示 在大量資料且長時間的訓練能快速掌握目前訓練的情況 因此需添加變量在tensorboard中，觀察其變化狀況 收集變量 合併變量寫入事件文件中 收集變量收集變量的代碼一般是寫在執行會話(Session)之前 scalar使用tf.summary.scalar(name=&#39;&#39;,tensor)收集對於損失函數、準確率等單值變量 name：變量的名字 (在tensorboard後台顯示的名字) tensor：欲蒐集哪個tensor變量 histogram使用tf.summary.histogram(name=&#39;&#39;,tensor)收集高維度的變量參數，權重(weight)、偏置(bias) 等 name：變量的名字 (在tensorboard後台顯示的名字) tensor：欲蒐集哪個tensor變量 image使用tf.summary.image(name=&#39;&#39;,tensor)收集輸入的圖片張量能顯示圖片 name：變量的名字 (在tensorboard後台顯示的名字) tensor：欲蒐集哪個tensor變量 合併變量寫入事件文件使用tf.summary.merge_all()，定義合併tensor的op，其會返回合併的op(於graph中定義) merged = tf.summary.merge_all() 固定寫法 必須運行op才能執行 運行合併：summary = sess.run(merged) 每次迭代都必須運行 返回一個事件文件的物件，用於添加到事件文件中 添加：FileWriter.add_summary(summary,i) i:表示第幾次的值 範例以之前使用的線性回歸範例代碼為例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import tensorflow as tfdef LinearRegression(): with tf.variable_scope(\"data_preparation\"): X = tf.random_normal([100,1],mean=1.75,stddev=0.5, name=\"x_data\") y_true = tf.matmul(X,[[0.7]]) + 0.8 with tf.variable_scope(\"LinearRegression_model_build\"): weight = tf.Variable(tf.random_normal([1,1],mean=0.0,stddev=1.0),name=\"w\") #必須用變量定義才能優化(改變) bias = tf.Variable(0.0,name=\"bias\") y_predict = tf.matmul(X,weight) + bias with tf.variable_scope(\"loss_calculate\"): loss = tf.reduce_mean(tf.square(y_true - y_predict)) with tf.variable_scope(\"optimize\"): train_op = tf.train.GradientDescentOptimizer(0.1).minimize(loss) #收集單值變量tensor tf.summary.scalar(\"Loss\",loss) #收集高維度變量tensor tf.summary.histogram(\"Weight\",weight) tf.summary.histogram(\"Bias\",bias) # 定義一個tensor合併的op merged = tf.summary.merge_all() init_var_op = tf.global_variables_initializer() with tf.Session() as sess: sess.run(init_var_op) print(\"起始初始化權重：%f, 初始化偏置：%f\"%(weight.eval(),bias.eval())) # 建立事件文件(指定存放文件夾及graph) FileWriter = tf.summary.FileWriter(\"./summary/\",graph=sess.graph) for i in range(1000): sess.run(train_op) # 運行tensor互相合併的op summary = sess.run(merged) # 將結果寫入事件文件 FileWriter.add_summary(summary,i) if i%50 == 0: print(\"優化%d次後 權重：%f, 優化偏置：%f\" % (i,weight.eval(), bias.eval()))if __name__ == '__main__': LinearRegression() ResultSCALARS 可以看到隨著迭代的次數增加loss值不斷地在下降，最後趨於收斂 HISTOGRAM weights及bias顯示不盡理想的原因是因為，histogram是以高維度去展示結果，而我們只有定一個值，使得其高斯分布的情性變得很奇怪 可以SCALARS蒐集只有單值的變量 DISTRIBUTIONS","categories":[{"name":"tensorflow深度學習","slug":"tensorflow深度學習","permalink":"http://www.taroballz.com/categories/tensorflow深度學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://www.taroballz.com/tags/tensorflow/"},{"name":"深度學習(Deep Learning)","slug":"深度學習-Deep-Learning","permalink":"http://www.taroballz.com/tags/深度學習-Deep-Learning/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"}]},{"title":"深度學習-tensorflow基礎-變量作用域(命名空間)","slug":"DL_Variable_scope","date":"2018-12-08T17:42:00.000Z","updated":"2019-07-27T07:31:34.000Z","comments":true,"path":"2018/12/09/DL_Variable_scope/","link":"","permalink":"http://www.taroballz.com/2018/12/09/DL_Variable_scope/","excerpt":"Introduction 目的是為了使代碼更清晰區分功能，使其作用分明 讓tensorboard更清晰顯示代碼運作的模式","text":"Introduction 目的是為了使代碼更清晰區分功能，使其作用分明 讓tensorboard更清晰顯示代碼運作的模式 創建作用域 使用tf.variable_scope()函數創建作用域 scope_name參數：創建指定的名字 其相當於是一種上下文環境 with tf.variable_scope(&quot;作用域名稱&quot;): 將相對應的操作放置到相對應的作用域中使graph更整齊 未使用作用域以上一篇文章所使用的線性回歸代碼作為例子12345678910111213141516171819202122232425262728293031323334import tensorflow as tfdef LinearRegression(): X = tf.random_normal([100,1],mean=1.75,stddev=0.5, name=\"x_data\") y_true = tf.matmul(X,[[0.7]]) + 0.8 weight = tf.Variable(tf.random_normal([1,1],mean=0.0,stddev=1.0),name=\"w\") #必須用變量定義才能優化(改變) bias = tf.Variable(0.0,name=\"bias\") y_predict = tf.matmul(X,weight) + bias loss = tf.reduce_mean(tf.square(y_true - y_predict)) train_op = tf.train.GradientDescentOptimizer(0.1).minimize(loss) init_var_op = tf.global_variables_initializer() with tf.Session() as sess: sess.run(init_var_op) print(\"起始初始化權重：%f, 初始化偏置：%f\"%(weight.eval(),bias.eval())) # 建立事件文件(指定存放文件夾及graph) FileWriter = tf.summary.FileWriter(\"./summary/\",graph=sess.graph) for i in range(1000): sess.run(train_op) if i%50 == 0: print(\"優化%d次後 權重：%f, 優化偏置：%f\" % (i,weight.eval(), bias.eval()))if __name__ == '__main__': LinearRegression() result 可以看到很多op裸露在外面較雜亂 使用作用域整理1234567891011121314151617181920212223242526272829303132333435import tensorflow as tfdef LinearRegression(): with tf.variable_scope(\"data_preparation\"): X = tf.random_normal([100,1],mean=1.75,stddev=0.5, name=\"x_data\") y_true = tf.matmul(X,[[0.7]]) + 0.8 with tf.variable_scope(\"LinearRegression_model_build\"): weight = tf.Variable(tf.random_normal([1,1],mean=0.0,stddev=1.0),name=\"w\") #必須用變量定義才能優化(改變) bias = tf.Variable(0.0,name=\"bias\") y_predict = tf.matmul(X,weight) + bias with tf.variable_scope(\"loss_calculate\"): loss = tf.reduce_mean(tf.square(y_true - y_predict)) with tf.variable_scope(\"optimize\"): train_op = tf.train.GradientDescentOptimizer(0.1).minimize(loss) init_var_op = tf.global_variables_initializer() with tf.Session() as sess: sess.run(init_var_op) print(\"起始初始化權重：%f, 初始化偏置：%f\"%(weight.eval(),bias.eval())) # 建立事件文件(指定存放文件夾及graph) FileWriter = tf.summary.FileWriter(\"./summary/\",graph=sess.graph) for i in range(1000): sess.run(train_op) if i%50 == 0: print(\"優化%d次後 權重：%f, 優化偏置：%f\" % (i,weight.eval(), bias.eval()))if __name__ == '__main__': LinearRegression() result 產生的graph比未整理過的清爽 graph理解性變高，結構調理清楚","categories":[{"name":"tensorflow深度學習","slug":"tensorflow深度學習","permalink":"http://www.taroballz.com/categories/tensorflow深度學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://www.taroballz.com/tags/tensorflow/"},{"name":"深度學習(Deep Learning)","slug":"深度學習-Deep-Learning","permalink":"http://www.taroballz.com/tags/深度學習-Deep-Learning/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"}]},{"title":"深度學習-tensorflow基礎-實現簡單線性回歸","slug":"DL_linearRegression","date":"2018-12-08T12:08:00.000Z","updated":"2019-07-27T08:46:19.000Z","comments":true,"path":"2018/12/08/DL_linearRegression/","link":"","permalink":"http://www.taroballz.com/2018/12/08/DL_linearRegression/","excerpt":"線性回歸定義：權重($w$)與特徵的乘積相加之和 一個樣本有多少特徵就有多少權重(構建模型)","text":"線性回歸定義：權重($w$)與特徵的乘積相加之和 一個樣本有多少特徵就有多少權重(構建模型) y_predict = w_1x_1 + w_2x_2 + .... + w_nx_n + bias(w_0x_0) 線性回歸是許多演算法的基礎 策略：構造損失函數 預測值與目標值相減平方的和之平均(均方誤差) 優化：梯度下降API 學習率(參數) 流程 準備數據(含有特徵值及目標值) 建立線性回歸模型 準備相對應特徵個數的權重變量(w) 建立一個偏置項(bias)變量 注意：權重(w)與偏置是在訓練過程中不斷改變的因此需用tf.Variable()來初始化並儲存 隨機初始化權重及偏置項 求損失值(loss)：真實值與預測值之誤差(均方誤差) 優化損失的過程：梯度下降，指定學習率 模型中的參數(權重、偏置需用 變量(variable) 定義) 矩陣運算API線性回歸最後的目標值(y_predict)應為 y_predict = w^Tx (n行,1列)矩陣 \\cdot (m行,n列)矩陣 + bias = (m行,1列)矩陣 矩陣相乘時必須為二維(請注意寫入代碼時注意維度) tf.matmul(a, b)用於矩陣相乘 tf.square(x)求平方值 tf.reduce_mean(input_tensor)相加求均值 梯度下降API使用tf.train.GradientDescentOptimizer(learning_rate)完成梯度下降優化 learning_rate：須手動指定一般介於0-1之間 返回一個梯度下降的op(於seesion中運行) 梯度下降op可調用的方法 minimize(loss)：最小化損失 loss參數填入要最小化的損失函數 實現一個線性回歸1234567891011121314151617181920212223242526272829303132333435363738import tensorflow as tfdef LinearRegression(): # 自實現的線性回歸預測 # 1. 準備數據 如:[100 sample,1 feature];[100 label] X = tf.random_normal([100,1],mean=1.75,stddev=0.5, name=\"x_data\") y_true = tf.matmul(X,[[0.7]]) # 矩陣相乘必須為二維的 y_true += 0.8 # bias(偏置項) # 2. 建立線性回歸模型 1個特徵，1個權重，1個偏置 y = kx + b # 隨機初始化 權重 及 偏置項 讓模型去計算損失然後優化 weight = tf.Variable(tf.random_normal([1,1],mean=0.0,stddev=1.0),name=\"w\") #必須用變量定義才能優化(改變) bias = tf.Variable(0.0,name=\"bias\") y_predict = tf.matmul(X,weight) + bias # 3. 建立損失函數(均方誤差) loss = tf.reduce_mean(tf.square(y_true - y_predict)) # 4. 優化損失函數，使用梯度下降 設置參數learning_rate 0 ~ 1之間 train_op = tf.train.GradientDescentOptimizer(0.1).minimize(loss) # 定義一個初始化變量(Variable)的op init_var_op = tf.global_variables_initializer() # 通過會話運行程序 with tf.Session() as sess: #初始化變量 sess.run(init_var_op) print(\"起始初始化權重：%f, 初始化偏置：%f\"%(weight.eval(),bias.eval())) #運行優化(優化不可能一次就完成，迭代的過程需不斷的循環訓練) for i in range(1000): sess.run(train_op) if i%50 == 0: print(\"優化%d次後 權重：%f, 優化偏置：%f\" % (i,weight.eval(), bias.eval())) Result123456789101112131415161718192021起始初始化權重：1.111157, 初始化偏置：0.000000優化0次後 權重：1.117272, 優化偏置：0.017270優化50次後 權重：0.926479, 優化偏置：0.370782優化100次後 權重：0.821177, 優化偏置：0.566434優化150次後 權重：0.768934, 優化偏置：0.670404優化200次後 權重：0.739766, 優化偏置：0.729816優化250次後 權重：0.720606, 優化偏置：0.761604優化300次後 權重：0.711568, 優化偏置：0.779086優化350次後 權重：0.706206, 優化偏置：0.788234優化400次後 權重：0.703404, 優化偏置：0.793436優化450次後 權重：0.701960, 優化偏置：0.796371優化500次後 權重：0.701060, 優化偏置：0.797973優化550次後 權重：0.700607, 優化偏置：0.798889優化600次後 權重：0.700331, 優化偏置：0.799383優化650次後 權重：0.700190, 優化偏置：0.799654優化700次後 權重：0.700104, 優化偏置：0.799809優化750次後 權重：0.700059, 優化偏置：0.799892優化800次後 權重：0.700033, 優化偏置：0.799939優化850次後 權重：0.700018, 優化偏置：0.799966優化900次後 權重：0.700010, 優化偏置：0.799981優化950次後 權重：0.700006, 優化偏置：0.799989 學習率與步數的設置學習率(learning_rate) 要是設置太大，會造成數值overload，跨過最小的loss值使得權重與偏置變得正負無窮大，稱之為梯度爆炸 在極端情況下，權重的值變得非常大，以至於溢出，導致Nan值 解決梯度爆炸(深度神經網路，如RNN當中更容易出現) 重新設計網路 調整學習率 使用梯度截斷(在訓練過程中檢查和限制梯度的大小) 要是在學習的過程中發現速度過快，去抑制進行變化 使用激活函數 神經網路常用到 要是設置過小，會造成損失函數很慢才會達到最小，使得學習的步數就必須增加","categories":[{"name":"tensorflow深度學習","slug":"tensorflow深度學習","permalink":"http://www.taroballz.com/categories/tensorflow深度學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://www.taroballz.com/tags/tensorflow/"},{"name":"深度學習(Deep Learning)","slug":"深度學習-Deep-Learning","permalink":"http://www.taroballz.com/tags/深度學習-Deep-Learning/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"演算法","slug":"演算法","permalink":"http://www.taroballz.com/tags/演算法/"}]},{"title":"Python-多任務執行-多線程(threading)","slug":"Threading","date":"2018-12-01T16:00:00.000Z","updated":"2018-12-01T18:26:54.000Z","comments":true,"path":"2018/12/02/Threading/","link":"","permalink":"http://www.taroballz.com/2018/12/02/Threading/","excerpt":"Preface: 要同時間執行兩個以上的函數，需用到多任務執行的模塊，例如threading模塊 線程(Thread)是實現多任務的一種手段 Introduction: python的thread模塊是比較底層的模塊,python的threading模塊是對thread做了一些包裝，可以更加方便的被使用","text":"Preface: 要同時間執行兩個以上的函數，需用到多任務執行的模塊，例如threading模塊 線程(Thread)是實現多任務的一種手段 Introduction: python的thread模塊是比較底層的模塊,python的threading模塊是對thread做了一些包裝，可以更加方便的被使用 Notice:Usage: threading模塊中有一個Thread類Example I:12345678910111213import threadingimport timedef sayHello(): print(\"Hello\") time.sleep(1)if __name__ == '__main__': for i in range(5): #創建一個線程的物件 t = threading.Thread(target=sayHello) #啟動線程 t.start() 主線程會等待子線程執行結束之後才會結束程序 查看線程信息(enumerate) 使用threading模塊下的enumerate可獲取當前程序所有線程信息(包括主線程)，返回一個列表 123456789101112131415161718192021222324import threadingfrom time import sleepdef sing(): print(\"I'm singing\") sleep(1)def dance(): print(\"I'm dancing\") sleep(1)if __name__ == '__main__': print(\"In the Main\") t1 = threading.Thread(target=sing) t2 = threading.Thread(target=dance) t1.start() t2.start() while True: length = len(threading.enumerate()) print(\"當前線程數為：%d\"%length) if length &lt;= 1: break sleep(0.5) 主線程會等到所有子線程都結束後才結束主線程 當調用Thread的時候，不會創建線程 使用Thread創建出來的線程物件(線程實例化對象)調用start方法的時候： 才會創建線程 並讓線程開始運行 result123456In the MainI&apos;m singingI&apos;m dancing當前線程數為：3當前線程數為：3當前線程數為：1 通過繼承Thread類創建線程1234567891011121314151617import threadingimport timeclass MyThread(threading.Thread): def run(self): for i in range(3): time.sleep(1) #Thread類中的name屬性保存了當前線程的名字 msg = \"I'm \" + self.name + \"@\" +str(i) print(msg)if __name__ == '__main__': #創建了一個線程物件(線程實例化對象) t = MyThread() t.start() 上面使用t = MyThread創建一個線程物件，其與使用threading.Thread()創建線程物件沒有差別 使用繼承的方法創建Thread，通常用於執行複雜操作時，也就是無法完全用threading.Thread(target=函數名)完整執行所有動作時使用 要執行的動作需寫在類的run方法中(必須定義) 線程物件執行start方法時，會調用run方法 run方法中內容是甚麼，線程就執行什麼 run方法執行完後，線程即結束 共享全局變量(重要) 多線程之間是共享全局變量的 共享全局變量遇到的問題 共享全局變量會遇到資源競爭的問題 兩個以上的線程對同一變量進行寫操作 線程同步(協同步調) 線程同步是解決資源競爭問題的方法 按預定的先後次序運行 可理解為線程A和B一塊配合，A執行到一定程度時要依靠B的某個結果，於是停下來，示意B運行，B執行 必須遵守原子性操作 牽涉到多線程的寫操作時，必須將以下三步全部執行完成，否則就不執行 獲取值 修改值 儲存值 互斥鎖 當多個線程幾乎同時修改某一個共享數據時，需要進行同步控制 最簡單的同步機制：引入互斥鎖 互斥鎖為資源引入一個狀態：鎖定/非鎖定 在執行時只允許一個線程進入獲取資源，別的線程無法進入 threading模塊中定義了Lock類 上鎖最好上越少代碼越好 需注意死鎖狀況發生 避免死鎖： 程序盡量避免使用計時的方式(銀行家演算法) 添加超時(timeout)時間等 12345678#創建鎖物件mutex = threading.Lock()#鎖定mutex.acquire()#釋放mutex.release() 如果鎖物件之前是未上鎖的，那麼調用acquire方法便不會堵塞 如果在調用acquire對鎖物件上鎖之前，已經被其他線程先行上鎖，會堵塞到鎖物件被release為止 未上鎖123456789101112131415161718192021222324import threadingnumber = 0def func1(n): for i in range(n): add_one()def func2(n): for i in range(n): add_one()def add_one(): global number number +=1if __name__ == '__main__': t1 = threading.Thread(target=func1,args=(1000000,)) t2 = threading.Thread(target = func2,args=(1000000,)) t1.start() t2.start() t1.join() #主線程等待線程完成再繼續往下執行 t2.join() print(\"in the main Thread, number=\",number) result 1in the main Thread, number= 1660809 1in the main Thread, number= 1594271 3.1in the main Thread, number= 1704507 有上鎖123456789101112131415161718192021222324252627import threadingnumber = 0def func1(n): for i in range(n): add_one()def func2(n): for i in range(n): add_one()def add_one(): global number Lock.acquire() number +=1 Lock.release()if __name__ == '__main__': Lock = threading.Lock() t1 = threading.Thread(target=func1,args=(1000000,)) t2 = threading.Thread(target = func2,args=(1000000,)) t1.start() t2.start() t1.join() t2.join() print(\"in the main Thread, number=\",number) result1in the main Thread, number= 2000000 傳遞參數 使用線程執行函數時傳遞參數(args) 指定將來創建線程物件時，傳遞什麼參數過去 threading.Thread(taget=函數名,args=(參數)) 請注意args參數接受必須為一元組(重要) 12345678910111213141516171819202122import threadingimport timedef func1(temp): temp.append(33) print(\"-----in test1 %s\"%temp)def func2(): print(\"----- in test2 Thread\")g_nums = [11,22]if __name__ == '__main__': t1 = threading.Thread(target=func1,args=(g_nums,)) t2 = threading.Thread(target = func2) t1.start() time.sleep(1) t2.start() time.sleep(1) print(\"int the main Thread\") result123-----in test1 [11, 22, 33]----- in test2 Threadint the main Thread","categories":[{"name":"Python模塊","slug":"Python模塊","permalink":"http://www.taroballz.com/categories/Python模塊/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"多線程","slug":"多線程","permalink":"http://www.taroballz.com/tags/多線程/"},{"name":"threading","slug":"threading","permalink":"http://www.taroballz.com/tags/threading/"}]},{"title":"Python基礎-反射","slug":"python_reflect","date":"2018-11-15T16:00:00.000Z","updated":"2018-11-15T17:32:01.000Z","comments":true,"path":"2018/11/16/python_reflect/","link":"","permalink":"http://www.taroballz.com/2018/11/16/python_reflect/","excerpt":"Introduction: 在python中執行反射的效率是非常高的 反射定義： 透過字符串的形式，獲取或操作(增、刪、改、查) 物件(object) 中的成員(函數、屬性)","text":"Introduction: 在python中執行反射的效率是非常高的 反射定義： 透過字符串的形式，獲取或操作(增、刪、改、查) 物件(object) 中的成員(函數、屬性) 案例1(獲取屬性)123456class foo: def __init__(self,name,age): self.name = name self.age = ageobj = foo(\"Taroballz\",26) 該如何使用”name”(字符串類型)取到”Taroballz”這個name屬性的值？ __dict__(類特殊成員)__dict__方法可查詢物件中的所有屬性，結果為一字典 取值1print(obj.__dict__[\"name\"]) 得到1Taroballz python內置函數使用getattr內置方法獲取物件的屬性 參數1：欲獲取屬性的物件 參數2：獲取何種屬性(字符串) 取值1print(getattr(obj,\"name\")) 得到1Taroballz Advanced可藉由用戶輸入獲取相對應屬性的值 ——&gt; 藉由輸入字符串形式拿取相對應屬性之值123choice = input('&gt;&gt;&gt;')value = getattr(obj,choice)print(value) 結果1234&gt;&gt;&gt;nameTaroballz&gt;&gt;&gt;age26 案例2(獲取方法並執行)getattr方法除了可以拿取物件的屬性外，也可拿取函數的返回值 12345678class foo: def __init__(self,name,age): self.name = name self.age = age def show(self): return \"%s-%s\" %(self.name,self.age)obj = foo(\"Taroballz\",26) 欲使用字符串”show”調用class中的show方法，使用getattr辦得到嗎？ 取值1print(getattr(obj,\"show\")) 結果1bound method foo.show of &lt;__main__.foo object at 0x0074E6B0 返回一個函數物件(可直接加括號執行) 執行函數物件123function = getattr(obj,\"show\")re_val = function()print(re_val) 結果1Taroballz-26 getattr方法針對類，不管是其屬性或是函數 皆可取得其對應值與返回值 其他針對反射的python內置方法hasattr檢測物件中有無其成員(包括屬性&amp;函數) 判斷屬性有無1print(hasattr(obj,'name')) 結果1True 判斷函數有無1print(hasattr(obj,\"show\")) 結果1True setattr設置 ( 創建 ) 物件中的屬性並賦予值 12setattr(obj,\"K1\",\"V1\")print(obj.K1) 結果1V1 delattr刪除物件中的屬性 12delattr(obj,'name')print(obj.name) 結果1AttributeError: &apos;foo&apos; object has no attribute &apos;name&apos; 類(class)亦為物件同樣的，有關反射的內置方法也適用於class(類)，因為類也是物件 getattr方法拿取靜態屬性 1234567class foo: VERSION = 1.0 DESCRIPTION = \"say something\"if __name__ == '__main__': print(getattr(foo,\"VERSION\")) print(getattr(foo,\"DESCRIPTION\")) 結果121.0say something 模塊(module)亦為物件在同級目錄下創建一個s2.py 寫上以下代碼，並導入(import)1234567NAME = 'Taroballz'def func(): return \"I am a function\"class foo: def __init__(self): self.test = 'It is a test' 在main文件中導入s2.py 並使用getattr獲取屬性 (s2此時亦為物件)123456import s2r1 = getattr(s2, \"NAME\")print(r1)r2 = getattr(s2, \"func\")result = r2()print(result) 結果12TaroballzI am function 獲取模塊中的類12get_class = getattr(s2,'foo')print(get_class) 結果(返回一個類)1class &apos;s2.foo&apos; 使用返回類創建一個物件，並獲取類中的資訊12obj = get_class()print(obj.test) 結果1It is a test","categories":[{"name":"Python基礎","slug":"Python基礎","permalink":"http://www.taroballz.com/categories/Python基礎/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"反射","slug":"反射","permalink":"http://www.taroballz.com/tags/反射/"}]},{"title":"深度學習-tensorflow基礎-tensorboard可視化","slug":"DL_Visualization_tensorboard","date":"2018-07-29T12:08:00.000Z","updated":"2019-07-22T16:12:12.000Z","comments":true,"path":"2018/07/29/DL_Visualization_tensorboard/","link":"","permalink":"http://www.taroballz.com/2018/07/29/DL_Visualization_tensorboard/","excerpt":"Introductiontensorboard是可視化的web介面tensorflow後台監控程序","text":"Introductiontensorboard是可視化的web介面tensorflow後台監控程序 將程序的garph結構 顯示在web界面 將程序的graph結構，經過序列化文件的動作，生成events事件文件 tensorboard會將events讀取出來顯示到web界面 將程序序列化成events文件tf.summary.FileWriter(logdir,graph=) summary模塊用於tensorboard後台管理使用 logdir：寫入events文件到何者路徑(不包含檔名)，最好使用絕對路徑，以提供給tensorflow使用 graph：把指定的graph寫入events文件 返回一個filewriter 注意：一般於Session中去執行此函數 Example123456789101112131415import tensorflow as tfconst = tf.constant([1,2,3,4,5])variable = tf.Variable(tf.random_normal([2,3], mean=0.0, stddev=1.0))variable_initialize = tf.global_variables_initializer()with tf.Session() as sess: sess.run(variable_initialize) # 把程序的圖結構寫入事件文件 filewriter = tf.summary.FileWriter(\"./summary\",graph=sess.graph) print(sess.run([const,variable])) 執行完後會在參數填入的文件夾中生成events文件 其名稱格式如下： events.out.tfevents.{timestamp}.{hotstname} 使用tensorboard開啟events文件1tensorboard --logdir=&quot;events存放的文件夾&quot; 路徑記得加上雙引號 使用瀏覽器打開localhost:6006 再修改程序後，在使用FileWriter保存一遍時會有新的事件文件，於tensorboard查看為最新的文件 選項(Inactive)在Inactive下拉可找到多個tensorboard的選單 SCALARS：顯示0維度之值(單純數值)用，例如準確率、損失 GRAPHS：顯示程序的結構 HISTOGRAMS：顯示高維度之值，例如權重($w$)、偏置(bias)等 我們在GRAPH中並沒有看到先前定義的名為const的張量，原因是要是我們沒有使用到該張量，則不會在GRAPH中顯示 name任何的op都可以在參數中指定name參數，會在tensorboard的GRAPH中顯示名字 亦可以讓相同op名字進行區分12345678910111213141516import tensorflow as tfa = tf.constant(1.0,name=\"a_const\")b = tf.constant(2.0,name=\"b_const\")result = tf.add(a,b,name=\"result\")variable = tf.Variable(tf.random_normal([2,3], mean=0.0, stddev=1.0),name=\"my_variable\")variable_initialize = tf.global_variables_initializer()with tf.Session() as sess: sess.run(variable_initialize) filewriter = tf.summary.FileWriter(\"./summary\",graph=sess.graph) print(sess.run([result,variable])) 圖中符號的意義來源https://www.tensorflow.org/programmers_guide/graph_viz?hl=zh-cn 增加變量顯示(後期補充)目的：觀察模型的參數，損失值等變量值的變化 SCALARS及HISTOGRAMS的選項是觀察變量的變化","categories":[{"name":"tensorflow深度學習","slug":"tensorflow深度學習","permalink":"http://www.taroballz.com/categories/tensorflow深度學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://www.taroballz.com/tags/tensorflow/"},{"name":"深度學習(Deep Learning)","slug":"深度學習-Deep-Learning","permalink":"http://www.taroballz.com/tags/深度學習-Deep-Learning/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"}]},{"title":"深度學習-tensorflow基礎-變量(Variable)","slug":"DL_Variance","date":"2018-07-28T15:27:00.000Z","updated":"2019-07-27T07:00:09.000Z","comments":true,"path":"2018/07/28/DL_Variance/","link":"","permalink":"http://www.taroballz.com/2018/07/28/DL_Variance/","excerpt":"Introduction變量(Variable)也是一種op，是一種特殊的張量，能夠進行存儲持久化(權重、係數等)，它的值就是張量，可被修改，預設被訓練","text":"Introduction變量(Variable)也是一種op，是一種特殊的張量，能夠進行存儲持久化(權重、係數等)，它的值就是張量，可被修改，預設被訓練 tf.placeholder, tf.constant皆不能被訓練 變量的創建使用tf.Variable(initial_value=None, name=None, trainable=True, collections=None)創建一個帶值為initial_value的新變量 initial_value：變量的初始值，可為隨機張量，固定張量等 name：表示變量的名字 trainable：為True時會隨著訓練過程不斷改變此值(會隨著梯度下降一起優化) collections： 新變量將添加到列出的圖的集合中collections，預設為\\[GraphKeys.GLOBAL_VARIABLES\\] trainable為True情況下，變量亦會被添加到圖集合中GraphKeys.TRAINABLE_VARIABLES 返回一個tensor類型的Variable 變量能調用的方法 assign(value) : 為變量分類一個新值，並返回新值 eval(session=None)：計算並返回此變量的值(須在有Session的上下文環境中運行) 變量類型12345678910import tensorflow as tfconst = tf.constant([1,2,3,4,5])rand = tf.random_normal([1,5],mean=0.0,stddev =1.0)variable = tf.Variable(tf.random_normal([2,3], mean=0.0, stddev=1.0))print(const, rand, variable,sep='\\n')with tf.Session() as sess: pass 123Tensor(&quot;Const:0&quot;, shape=(5,), dtype=int32)Tensor(&quot;random_normal:0&quot;, shape=(1, 5), dtype=float32)&lt;tf.Variable &apos;Variable:0&apos; shape=(1, 5) dtype=float32_ref&gt; 其為tf.Variable的op對象 變量初始化 變量在Session中使用時一定要先初始化 否則在Session中使用時會報錯：tensorflow.python.framework.errors_impl.FailedPreconditionError: Attempting to use uninitialized value Variable 顯示初始化的動作需先在graph中定義並在Session中完成 使用tf.global_variables_initializer() 添加一個初始化所有變量的operation，在graph中定義 在會話中啟動 Example123456789101112import tensorflow as tfconst = tf.constant([1,2,3,4,5])variable = tf.Variable(tf.random_normal([2,3], mean=0.0, stddev=1.0))# 必須完成顯示的初始化(定義)variable_initialize = tf.global_variables_initializer()with tf.Session() as sess: # 必須先運行初始化op sess.run(variable_initialize) print(sess.run([const,variable])) Result1[array([1, 2, 3, 4, 5], dtype=int32), array([[ 0.54134446, 0.8167209 , 0.5819898 ],[-1.5506644 , 0.05886701, 0.06756992]], dtype=float32)] tips 變量其實與其他Tensor幾乎無異，差異在於能持久化保存 普通的張量op是無法保存的 當程序當中有定義變量時，一定要在會話中完成運行初始化 在graph中定義顯示的初始化動作","categories":[{"name":"tensorflow深度學習","slug":"tensorflow深度學習","permalink":"http://www.taroballz.com/categories/tensorflow深度學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://www.taroballz.com/tags/tensorflow/"},{"name":"深度學習(Deep Learning)","slug":"深度學習-Deep-Learning","permalink":"http://www.taroballz.com/tags/深度學習-Deep-Learning/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"}]},{"title":"深度學習-tensorflow基礎-張量常用操作","slug":"DL_tensor_operation","date":"2018-07-25T20:00:00.000Z","updated":"2019-07-24T17:19:46.000Z","comments":true,"path":"2018/07/26/DL_tensor_operation/","link":"","permalink":"http://www.taroballz.com/2018/07/26/DL_tensor_operation/","excerpt":"生成固定值張量創建所有元素為零的張量 tf.zeros(shape,dtype=tf.float32,name=None) 此操作返回一個具dtype類型，形狀為shape和所有元素設置為零的張量","text":"生成固定值張量創建所有元素為零的張量 tf.zeros(shape,dtype=tf.float32,name=None) 此操作返回一個具dtype類型，形狀為shape和所有元素設置為零的張量 Example123456import tensorflow as tfzeros = tf.zeros(shape=[2,2],dtype=tf.float32)with tf.Session() as sess: print(sess.run(zeros)) Result12[[0. 0.] [0. 0.]] 創建與tensor相同shape的零張量 tf.zeros_like(tensor,dtype=None,name=None) 返回與tensor參數相同shape的零的張量 Example12345678import tensorflow as tf# tf.constant可用於創建一個常數陣列張量constant = tf.constant([[1,2,3],[4,5,6]])zeros = tf.zeros_like(constant)with tf.Session() as sess: print(sess.run(zeros)) Result12[[0 0 0] [0 0 0]] 創建所有元素為1的張量 tf.ones(shape,dtype=tf.float32,name=None) 此操作返回一個具dtype類型，形狀為shape和所有元素設置為1的張量 Example123456import tensorflow as tfones = tf.ones(shape=[3,3],dtype=tf.float32)with tf.Session() as sess: print(sess.run(ones)) Result123[[1. 1. 1.] [1. 1. 1.] [1. 1. 1.]] 創建與tensor相同shape的1張量 tf.ones_like(tensor,dtype=None,name=None) 返回與tensor參數相同shape的1的張量 Example1234567import tensorflow as tfconstant = tf.constant([[1,2,3,4],[4,5,6,7]])ones = tf.ones_like(constant)with tf.Session() as sess: print(sess.run(ones)) Result12[[1 1 1 1] [1 1 1 1]] 創建所有元素為自定義值的張量 tf.fill(dims, value, name=None) 返回一個shape為dims，且全部元素為value值的tensor Example1234fill = tf.fill([5,5],0.1)with tf.Session() as sess: print(sess.run(fill)) Result12345[[0.1 0.1 0.1 0.1 0.1] [0.1 0.1 0.1 0.1 0.1] [0.1 0.1 0.1 0.1 0.1] [0.1 0.1 0.1 0.1 0.1] [0.1 0.1 0.1 0.1 0.1]] 創建一個常數自定義值張量 tf.constant(value, dtype=None, shape=None, name=&quot;Const&quot;) 返回一個常數張量 Example123456import tensorflow as tfconstant = tf.constant([[1,2,3],[4,5,6],[7,8,9]])with tf.Session() as sess: print(sess.run(constant)) Result123[[1 2 3] [4 5 6] [7 8 9]] 創建隨機張量為了模擬現實生活中的數據分布狀態 生成隨機值矩陣 從高斯分布中輸出隨機值，再從此分布中取出數字組成矩陣並返回 tf.random_normal(shape, mean=0.0, stddev=1.0,dtype=float32, seed, name=None) mean：隨機值之平均值 stddev：隨機值的標準差 Example1234567import tensorflow as tfrandom = tf.random_normal([3,3],mean=175,stddev=3,) # 創建一個shape為[3,3]，平均值為175，標準差為3的的隨機矩陣with tf.Session() as sess: print(sess.run(random)) Result123[[176.29504 170.76894 174.0193 ] [168.04184 171.90128 179.24036] [170.96518 176.15288 172.40514]] 生成隨機值矩陣_2 與tf.random_normal()效果一樣，但是所有數字不會超過兩個標準差 tf.truncated_normal(shape, mean=0.0, stddev=1.0,dtype=float32, seed, name=None) tips 標準差越大，則數據越分散；標準差越小，則數據越集中 平均值大小改變波峰的位置 張量變換類型提供了如下改變張量中數值類型的函數 tf.string_to_number(string_tensor,out_type=None,name=None) 將字符串類型轉換成數字類型 tf.to_double(x, name=&#39;ToDouble&#39;) tf.to_float(x, nmae=&#39;ToFloat&#39;) tf.to_bfloat16(x, name=&#39;ToBFloat16&#39;) tf.to_int32(x, name=&#39;ToInt32&#39;) tf.to_int64(x, name=&#39;ToInt64&#39;) tf.cast(x, dtype, name=None) 萬能任意轉換類型12345678import tensorflow as tfconst = tf.constant([[1,2,3],[4,5,6]])print(\"const:\",const)new_const = tf.cast(const,dtype=tf.float32)print(\"new_const:\",new_const)with tf.Session() as sess: pass 12const: Tensor(&quot;Const:0&quot;, shape=(2, 3), dtype=int32)new_const: Tensor(&quot;Cast:0&quot;, shape=(2, 3), dtype=float32) tensor的擴展 將兩個矩陣按行或列合併 tf.concat(values,axis,name=&#39;concat&#39;) values：接受一個矩陣列表 axis：決定按行(0)或列(1)合併 按行(0)合併axis = 0123456a = [[1,2,3],[4,5,6]]b = [[7,8,9],[10,11,12]]concat = tf.concat([a,b],axis=0)with tf.Session() as sess: print(sess.run(concat)) Result1234[[ 1 2 3] [ 4 5 6] [ 7 8 9] [10 11 12]] 按列(1)合併axis = 1123456a = [[1,2,3],[4,5,6]]b = [[7,8,9],[10,11,12]]concat = tf.concat([a,b],axis=1)with tf.Session() as sess: print(sess.run(concat)) Result12[[ 1 2 3 7 8 9] [ 4 5 6 10 11 12]] 提供給tensor運算的數學函數包括 算數運算符 基本數學函數 矩陣運算 減少維度的運算 序列運算 減少維度的運算(tf.reduce_xxx)用於減少tensor的維度 tf.reduce_mean1234x = tf.constant([[1., 1.],[2., 2.]])tf.reduce_mean(x) # 1.5tf.reduce_mean(x,0) #[1.5, 1.5] ----&gt;第二個參數為0代表 按column 求值tf.reduce_mean(x,1) #[1., 2.] ----&gt;第二個參數為1代表 按行 求值 tf.reduce_all1234x = tf.constant([[True, True],[False, False]])tf.reduce_all(x) # False ----&gt;對全部求and運算 有一個false即返回falsetf.reduce_all(x,0) #[False, False] ----&gt;第二個參數為0代表 按column 求值tf.reduce_all(x,1) #[True, False] ----&gt;第二個參數為1代表 按行 求值 參考網址https://www.tensorflow.org/versions/r1.10/api_docs/python/","categories":[{"name":"tensorflow深度學習","slug":"tensorflow深度學習","permalink":"http://www.taroballz.com/categories/tensorflow深度學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://www.taroballz.com/tags/tensorflow/"},{"name":"深度學習(Deep Learning)","slug":"深度學習-Deep-Learning","permalink":"http://www.taroballz.com/tags/深度學習-Deep-Learning/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"}]},{"title":"深度學習-tensorflow基礎-張量(tensor)","slug":"DL_tensor","date":"2018-07-24T18:05:00.000Z","updated":"2018-07-24T18:11:47.000Z","comments":true,"path":"2018/07/25/DL_tensor/","link":"","permalink":"http://www.taroballz.com/2018/07/25/DL_tensor/","excerpt":"Introduction tensorflow依賴的是numpy庫 在tensorflow中張量(tensor)其實與numpy的陣列是差不多的","text":"Introduction tensorflow依賴的是numpy庫 在tensorflow中張量(tensor)其實與numpy的陣列是差不多的 陣列(ndarray) 矩陣 張量(tensor) 擁有無窮的維度 必須為二維 被封裝的陣列(亦擁有無窮維度) tensor是tensorflow中基本的數據格式 一個類型化的N維度數組(tf.Tensor) print時會包含名字，張量形狀，數據類型三部分 1Tensor(&quot;Add:0&quot;, shape=(), dtype=int32) 名字指的是op類型，：0並無意義 張量形狀可表示數據維度 tensor維度(階)tensor的維度通常用階表示 階 數學實例 Python Example 0 純量 只有大小 s = 483 1 向量 大小和方向 v = [1.1, 2.2, 3.3] 2 矩陣 數據表 m = [[1,2,3],[4,5,6],[7,8,9]] 3 三階張量 數據立體 … n n階 … tensor數據類型 數據類型 python類型 描述 DT_FLOAT tf.float32 32位浮點數 DT_DOUBLE tf.float64 64位浮點數 DT_INT64 tf.int64 64位有符號整型 DT_INT32 tf.int32 32位有符號整型 DT_INT16 tf.int16 16位有符號整型 DT_INT8 tf.int8 8位有符號整型 DT_UINT8 tf.uint8 8位無符號整型 DT_STRING tf.string 可變字節長度的字節array，每一個張量元素都是一個字節array DT_BOOL tf.bool 布爾型 DT_COMPLEX64 tf.complex64 由兩個32位浮點數組成的複數：實數和虛數 DT_QINT32 tf.qint32 用於量化Ops的32位有符號整型 DT_QINT8 tf.qint8 用於量化Ops的8位有符號整型 DT_QUINT8 tf.quint8 用於量化Ops的8位無符號整型 tensor屬性創建張量後可透過以下屬性查看狀態 graph：張量所屬的默認圖 op：張量的操作名 name：張量的字符串描述 shape：張量的形狀 0階為() 1階為(2,) 2階為(2,3) 要是無固定行或列則該值為? 3階為(2,3,4) 理解成2張3行4列的表 tensor形狀(shape)tensorflow中，張量具有靜態形狀和動態形狀 動態形狀和靜態形狀改變的差別：在於有沒有生成一個新的張量數據 在numpy中改變陣列的形狀使用reshape 把原來的數據通過reshape直接修改 靜態形狀若是沒有生成新的張量則稱為靜態形狀 tf.Tensor.get_shape:獲取靜態形狀 tf.Tensor.set_shape(shape):更新Tensor物件的靜態形狀 Example123456789101112131415import tensorflow as tf# 創建一個形狀不固定的placeholderplt = tf.placeholder(tf.float32,shape=[None,2])print(plt)# 固定形狀時使用 靜態形狀 設定# 不固定的行列(None)才能修改plt.set_shape(shape=[3,2]) # 沒有返回值接收，因此沒有產生新的張量print(plt)with tf.Session() as sess: pass 應用場景：在讀取數據時不確定樣本數需要使用None來抓取所有數據，讀進來後需要固定形狀方便計算 注意：set_shape不能跨維度修改 set_shape後，一旦張量固定，不能再次set_shape改變形狀 Result12Tensor(&quot;Placeholder:0&quot;, shape=(?, 2), dtype=float32)Tensor(&quot;Placeholder:0&quot;, shape=(3, 2), dtype=float32) 動態形狀若是生成新的張量則稱為動態形狀， 一種描述原始張量在執行過程中的一種形狀(動態變化) tf.reshpae(tensor,shape,name=None):創建一個具有不同動態形狀的新張量 其與numpy的reshape效果不一樣 Example123456789101112131415import tensorflow as tfplt = tf.placeholder(tf.float32,shape=[None,2])print(plt)plt.set_shape(shape=[3,2])# 透過reshape動態形狀修改，接收返回值得到新張量new_plt = tf.reshape(plt,[2,3])print(new_plt)with tf.Session() as sess: pass 注意：reshape前後的元素個數須一樣 跨維度reshape仍需注意元素數量需匹配 Result12Tensor(&quot;Placeholder:0&quot;, shape=(?, 2), dtype=float32)Tensor(&quot;Reshape:0&quot;, shape=(2, 3), dtype=float32) 得到新的操作名Resahpe","categories":[{"name":"tensorflow深度學習","slug":"tensorflow深度學習","permalink":"http://www.taroballz.com/categories/tensorflow深度學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://www.taroballz.com/tags/tensorflow/"},{"name":"深度學習(Deep Learning)","slug":"深度學習-Deep-Learning","permalink":"http://www.taroballz.com/tags/深度學習-Deep-Learning/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"}]},{"title":"深度學習-tensorflow基礎-會話(Session)","slug":"DL_tensorflow_session","date":"2018-07-22T09:50:00.000Z","updated":"2019-07-23T16:32:56.000Z","comments":true,"path":"2018/07/22/DL_tensorflow_session/","link":"","permalink":"http://www.taroballz.com/2018/07/22/DL_tensorflow_session/","excerpt":"Introductiontensorflow分為前端系統及後端系統 前端系統：定義程序的圖；定義程序的架構 後端系統：運算圖結構","text":"Introductiontensorflow分為前端系統及後端系統 前端系統：定義程序的圖；定義程序的架構 後端系統：運算圖結構 會話session會去解析使用者定義的graph，並進行運算 運行圖結構 分配資源(CPU, GPU)進行計算 掌握資源(變量, 隊列, 線程…等資源)，相當於總管，決定開啟或釋放資源 在tensorflow中是真正的多線程(numpy釋放了GIL) tf.Session()運行TensorFlow中操作圖的類，使用默認註冊的圖(但也可指定運行圖) 運行了指定的圖or默認的圖之後，不能去調用其他圖結構的任何op 會話資源會話可能擁有很多資源(如tf.Variable, tf.QueueBase和tf.ReaderBase等)，會話結束後需要進行資源釋放 Method I sess = tf.Session \\to sess.run(...) \\to sess.close() 須主動close() 12345678910import tensorflow as tfa = tf.constant(1.0)b = tf.constant(2.0)result = tf.add(a, b)sess = tf.Session()print(sess.run(result)) # run方法：啟動整個圖sess.close() # 釋放資源 Method II 使用上下文管理器(with)常用且方便，會自動釋放資源 123456789import tensorflow as tfa = tf.constant(1.0)b = tf.constant(2.0)result = tf.add(a, b)with tf.Session() as sess: print(sess.run(result)) 只要有上下文環境也能使用eval()函數(比起run更為方便) 12with tf.Session() as sess: print(result.eval()) 指定服務器地址運行(target)tf.Session(target=&#39;&#39;) 若target參數留空(預設值)，會話將僅使用本地電腦中的設備運行 可以指定 grpc://網址，以便指定Tensorflow服務器的地址 使得會話可以訪問該服務器控制的電腦上的所有設備 指定圖運行在tf.Session(graph=指定圖)12345678910111213141516import tensorflow as tfg = tf.Graph()print(\"g.graph:\",g)with g.as_default(): c = tf.constant(10.0) print(\"c.graph in g_graph\",c.graph)graph = tf.get_default_graph()print(\"get_default_graphL:\",graph)# 只能運行一個圖with tf.Session(graph=g) as sess: # 於Session()的graph參數決定運行的圖 print(sess.run(c)) print('sess.graph:',sess.graph) Result12345g.graph: &lt;tensorflow.python.framework.ops.Graph object at 0x100ff3780&gt;c.graph in g_graph &lt;tensorflow.python.framework.ops.Graph object at 0x100ff3780&gt;get_default_graphL: &lt;tensorflow.python.framework.ops.Graph object at 0x102830128&gt;10.0sess.graph: &lt;tensorflow.python.framework.ops.Graph object at 0x100ff3780&gt; 預設的圖和指定的圖內存位置不一樣，要是不從graph參數指定圖，默認會運行預設的 查看運行設備情況於Session中的參數config 可知道當前graph所使用的資源及設備 可知道當前graph使用到哪些tensor及operation tf.Session(config=tf.ConfigProto(log_device_placement=True)) 1234567891011import tensorflow as tfa = tf.constant(1.0)b = tf.constant(2.0)result = tf.add(a, b)with tf.Session(config=tf.ConfigProto(log_device_placement=True)) as sess: print(sess.run(result)) print('result.graph:',result.graph) print('sess.graph:',sess.graph) Result1234567Device mapping: no known devices.Add: (Add): /job:localhost/replica:0/task:0/device:CPU:0Const: (Const): /job:localhost/replica:0/task:0/device:CPU:0Const_1: (Const): /job:localhost/replica:0/task:0/device:CPU:03.0result.graph: &lt;tensorflow.python.framework.ops.Graph object at 0x101ebe160&gt;sess.graph: &lt;tensorflow.python.framework.ops.Graph object at 0x101ebe160&gt; 交互式Session 一般於命令行中進行操作 輸入tf.InteractiveSession()開啟交互式的會話(以含有上下文環境) 可在接下來內文中持續run圖結構；或是使用eval() Session的run方法run(fetches, feed_dict=None, graph=None) fetches：嵌套列表、元組、namedtuple、dict或OrderedDict，運行operator和計算tensor(重載的運算符也能運行) 主要參數，要運行的Tensor 或是 Operation 不能是一般float或是int類型，會報錯如：(報錯)12345var1 = 2.0var2 = 3.0sum = var1 + var2with tf.Session() as sess: print(sess.run(sum)) 若要是同時運行多個物件則要放入一個list，如[a,b,result] 有重載機制 當operation與一般類型進行計算時，預設會重載成operation類型如：(正常執行)12345var1 = 2.0a = tf.constant(3.0)sum = var1 + awith tf.Session() as sess: print(sess.run(sum)) feed_dict：允許調用者覆蓋graph中指定張量的值，結合placeholder使用 在程序執行的時候，不確定輸入的是甚麼，提前佔個位，再用feed_dict指定參數 placeholder提供佔位符 提供相對應數據shape大小的空間，但沒有具體數據 tf.placeholder(dtype, shape=None, name=None) dtype：為數據的類型 shape：輸入數據的shape name：暫不討論，於tensorboard中使用 在訓練模型時，傳進去的樣本數不一定都為固定值，因此需實時的提供數據去進行訓練 接收的為一個字典 參數fetches所接收的tf.placeholder變量 Example I 固定筆數的數據12345678import tensorflow as tfimport numpy as npplt = tf.placeholder(tf.float32,shape=[2,3]) #shape為兩行三列的數據with tf.Session() as sess: data = np.array([[1,2,3],[4,5,6]]) print(sess.run(plt, feed_dict=&#123;plt:data&#125;)) Result12[[1. 2. 3.] [4. 5. 6.]] Example II 不知道筆數的數據 往往實際的情況是，在固定特徵數的條件下，我們不知道樣本的數目 12345678910import tensorflow as tfimport numpy as npdata = np.array([[1,2,3],[4,5,6],range(3),range(4,7),range(9,12)])plt = tf.placeholder(tf.float32,shape=[None,3]) #shape不知道為多少列，但知道多少行(特徵)print(plt)with tf.Session() as sess: print(sess.run(plt, feed_dict=&#123;plt:data&#125;)) Result123456Tensor(&quot;Placeholder:0&quot;, shape=(?, 3), dtype=float32)[[ 1. 2. 3.] [ 4. 5. 6.] [ 0. 1. 2.] [ 4. 5. 6.] [ 9. 10. 11.]] Session異常返回值異常案例： RuntimeError：如果它Session處於無效狀態(例如已關閉) TypeError：如果fetches或feed_dict鍵不是合適類型 ValueError：如果fetches或feed_dict鍵無效，或引用Tensor不存在","categories":[{"name":"tensorflow深度學習","slug":"tensorflow深度學習","permalink":"http://www.taroballz.com/categories/tensorflow深度學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://www.taroballz.com/tags/tensorflow/"},{"name":"深度學習(Deep Learning)","slug":"深度學習-Deep-Learning","permalink":"http://www.taroballz.com/tags/深度學習-Deep-Learning/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"}]},{"title":"深度學習-tensorflow基礎-圖(graph)、operation與tensor","slug":"DL_tensorflow","date":"2018-07-22T02:50:00.000Z","updated":"2019-07-23T15:00:21.000Z","comments":true,"path":"2018/07/22/DL_tensorflow/","link":"","permalink":"http://www.taroballz.com/2018/07/22/DL_tensorflow/","excerpt":"Introduction 須把tensorflow當作一個全新的語言來看待，而非再是普通的python程序 整體就是tensor(張量；數據) + flow","text":"Introduction 須把tensorflow當作一個全新的語言來看待，而非再是普通的python程序 整體就是tensor(張量；數據) + flow 架構tensorflow框架的設計 數據在tensorflow裡可以稱為張量(tensor) 上圖一個個的節點為tensorflow中的operation(op) 專門進行運算的操作節點 所有操作都是一個op 上圖就為tensorflow 圖(graph)：在tensorflow中代表整個程序的結構或是欲執行的計算任務 圖(graph)需要會話(session)才能運作 Session：用於運算程序定義的graph 計算密集 vs. IO密集 相較於python其他框架例如django(web),scrapy(爬蟲)，tensorflow屬計算密集型的框架 計算密集型 IO密集型 tensorflow django,scrapy cpu計算 http請求, 磁盤(檔案)操作 實現一個加法運算1234567891011import tensorflow as tf# 定義圖(graph)a = tf.constant(1.0)b = tf.constant(2.0)result = tf.add(a, b)# 於會話(session)中執行with tf.Session() as sess: print(sess.run(result)) Result13.0 圖(Graph)圖在開始撰寫tensorflow程序時預設已經註冊了，一組表示tf.Operation計算單位的物件 和 tf.Tensor表示操作之間流動的數據單元的物件 獲取graph物件返回的是一個graph物件的地址12345678910111213141516import tensorflow as tf# 定義圖a = tf.constant(1.0)b = tf.constant(2.0)result = tf.add(a, b)# 獲取圖物件，預設的這張圖，相當於是給程序分配一段內存graph = tf.get_default_graph()print(\"get_default_graphL:\",graph)with tf.Session() as sess: print(sess.run(result)) print(\"a.graph:\",a.graph) print('result.graph:',result.graph) print('sess.graph:',sess.graph) result12345get_default_graphL: &lt;\\tensorflow.python.framework.ops.Graph object at 0x10f20e048&gt;3.0a.graph: &lt;\\tensorflow.python.framework.ops.Graph object at 0x10f20e048&gt;result.graph: &lt;\\tensorflow.python.framework.ops.Graph object at 0x10f20e048&gt;sess.graph: &lt;\\tensorflow.python.framework.ops.Graph object at 0x10f20e048&gt; 可以看見所有的operation包括session都在同一個內存地址中 圖的創建單獨的分配另一塊內存地址存儲另外一個程序的結構 使用tf.Graph()創建圖 圖與圖之間互不干擾 使用圖時都是使用上下文環境(with) 1234567891011121314151617181920212223import tensorflow as tfg = tf.Graph()print(g)# 上下文環境使用withwith g.as_default(): #as_default:作為預設圖使用 c = tf.constant(10.0) print(c.graph)a = tf.constant(1.0)b = tf.constant(2.0)result = tf.add(a, b)graph = tf.get_default_graph()print(\"get_default_graphL:\",graph)# 會話只能使用一張圖進行運算with tf.Session() as sess: print(sess.run(result)) print(\"a.graph:\",a.graph) print('result.graph:',result.graph) print('sess.graph:',sess.graph) result1234567g.graph: &lt;\\tensorflow.python.framework.ops.Graph object at 0x1069046d8&gt;c.graph in g_graph &lt;\\tensorflow.python.framework.ops.Graph object at 0x1069046d8&gt;get_default_graphL: &lt;\\tensorflow.python.framework.ops.Graph object at 0x10813ffd0&gt;3.0a.graph: &lt;\\tensorflow.python.framework.ops.Graph object at 0x10813ffd0&gt;result.graph: &lt;\\tensorflow.python.framework.ops.Graph object at 0x10813ffd0&gt;sess.graph: &lt;\\tensorflow.python.framework.ops.Graph object at 0x10813ffd0&gt; 可以看到兩張圖為不同的內存地址，彼此互不干擾 Operation(Op) 類型 示例 標量運算 add, sub, mul, div, exp, log, greater, less, equal 向量運算 concat, slice, splot, constant, rank, shape, shuffle 矩陣運算 matmul, matrix_inverse, matrix_determinant 帶狀態的運算 variable, assign, assign_add 神經網路組件 soft_max, sigmoid, ReLU, convolution2D, MaxPooling 存儲、恢復 save, restore 隊列及同步運算 enqueue, dequeue, mutex_acquire, mutex_release 控制流 merge, switch, enter, leave, next_iteration 只要使用tensorflow這個API定義的物件，全部都是op op為一個載體 tensor：指的就是數據，例如tf.constant(10.0) 有些op中加載的不是數據，那它就不是tensor 操作函數 &amp; 操作對象調用 操作函數 過程中會產生 操作對象 操作函數 操作對象 調用tf.constant(Tensor對象)函數 輸入Tensor對象 -&gt; Const-&gt; 輸出Tensor對象 調用tf.add(Tensor對象I, Tensor對象II)函數 輸入2個Tensor對象 -&gt; Add -&gt; 輸出1個Tensor對象 每一個OP指令(Const,Add)都對應了一個唯一的名稱 Const、Const_1 … 不同的圖(graph)命名空間是獨立的 創建OP時可通過name參數重新命名","categories":[{"name":"tensorflow深度學習","slug":"tensorflow深度學習","permalink":"http://www.taroballz.com/categories/tensorflow深度學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://www.taroballz.com/tags/tensorflow/"},{"name":"深度學習(Deep Learning)","slug":"深度學習-Deep-Learning","permalink":"http://www.taroballz.com/tags/深度學習-Deep-Learning/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"}]},{"title":"機器學習-非監督學習- K-means","slug":"ML_unsupervise_Kmeans","date":"2018-07-18T17:50:00.000Z","updated":"2019-07-22T14:42:55.000Z","comments":true,"path":"2018/07/19/ML_unsupervise_Kmeans/","link":"","permalink":"http://www.taroballz.com/2018/07/19/ML_unsupervise_Kmeans/","excerpt":"Introduction 非監督學習：dataset只有特徵值，沒有真實標籤(目標值) PCA降維算是無監督學習的一種 把具有相近特徵的數據歸為一個類別，稱為聚類(物以類聚，人以群分) 聚類演算法又叫做無監督分類 聚類通常在分類之前進行，才進行分類(預測類別) 聚類演算法又稱為無監督分類 可用於降維(decomposistion) 可用於矢量量化(vector quantization) 將高維特徵壓縮到一列當中 再不改變特徵數目及樣本數目的情況下，壓縮數據上的信息量大小 用於壓縮圖像、聲音、視頻等非結構化數據 主要方法：k-means 將一組N個樣本的特徵矩陣X劃分為K個無交集的簇(cluster)，直觀上來看是一組一組聚在一起的數據 在一個簇中的數據就認為是同一類，簇就是聚類的結果表現 簇中所有數據的均值$u_{ij}$通常稱為這個簇的質心(centroids) K:把數據劃分成多少個類別 為kmeans演算法的核心 知道類別的個數則設定K值後fit 不知道類別的個數時，則K為超參數","text":"Introduction 非監督學習：dataset只有特徵值，沒有真實標籤(目標值) PCA降維算是無監督學習的一種 把具有相近特徵的數據歸為一個類別，稱為聚類(物以類聚，人以群分) 聚類演算法又叫做無監督分類 聚類通常在分類之前進行，才進行分類(預測類別) 聚類演算法又稱為無監督分類 可用於降維(decomposistion) 可用於矢量量化(vector quantization) 將高維特徵壓縮到一列當中 再不改變特徵數目及樣本數目的情況下，壓縮數據上的信息量大小 用於壓縮圖像、聲音、視頻等非結構化數據 主要方法：k-means 將一組N個樣本的特徵矩陣X劃分為K個無交集的簇(cluster)，直觀上來看是一組一組聚在一起的數據 在一個簇中的數據就認為是同一類，簇就是聚類的結果表現 簇中所有數據的均值$u_{ij}$通常稱為這個簇的質心(centroids) K:把數據劃分成多少個類別 為kmeans演算法的核心 知道類別的個數則設定K值後fit 不知道類別的個數時，則K為超參數 流程前提：在知道為k個類別的情況下 隨機在數據當中抽取k個樣本當作k個類別的中心點 計算其餘的點到k個中心點的距離 其餘的每一個點都會存著k個與中心點之間的距離 從中選出距離最近的一個點作為自己類別的標記，形成k個族群 分別計算這k個族群的平均值 得到平均值點有可能不再數據類別中 把k個族群的平均值點 與 k個舊中心點進行比較 比較結果相同：兩點重合，結束聚類 比較結果不同：把這k個平均值點當作新的中心點，從第2步開始執行 sklearn中的聚類演算法 聚類算法都位於sklearn.cluster中 聚類算法中有各種類(class)及函數(function)的調用方法 類 在調用的時候有預設值，可直接使用 函數 最少有一個參數必須輸入，才可進行聚類 sklearn中k-means API 使用sklearn.cluster.KMeans KMeans(n_cluster=8, init=’k-means++’) n_clusters : 開始聚類的中心數量 將全部樣本分為多少個類別 Example12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from sklearn.cluster import KMeansfrom sklearn.datasets import load_irisimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3DX = load_iris().datadef cluster(): KM = KMeans(n_clusters=3) KM.fit(X) # 回傳標記的結果 predict_y = KM.predict(X) print(predict_y) # 多少n_clusters就使用多少顏色標記 color_list = [\"red\",\"blue\",\"green\"] point_color = [color_list[i] for i in predict_y] fig = plt.figure(figsize=(10,10)) ax = Axes3D(fig, rect=[0, 0, .95, 1], elev=48, azim=134) ax.scatter(X[:,3],X[:,0],X[:,2],color=point_color,edgecolor=\"k\",s=100) # 去除scale ax.w_xaxis.set_ticklabels([]) ax.w_yaxis.set_ticklabels([]) ax.w_zaxis.set_ticklabels([]) #設置不同軸的label ax.set_xlabel('Petal width') ax.set_ylabel('Sepal length') ax.set_zlabel('Petal length') ax.dist = 12 for name, label in [('Setosa', 0), ('Versicolour', 1), ('Virginica', 2)]: ax.text3D(X[predict_y == label, 3].mean(), X[predict_y == label, 0].mean(), X[predict_y == label, 2].mean() + 2, name, horizontalalignment='center', bbox=dict(alpha=.2, edgecolor='w', facecolor='w')) fig.show()if __name__ == '__main__': cluster() Result12345[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 2 2 2 2 1 2 2 2 2 2 2 1 1 2 2 2 2 1 2 1 2 1 2 2 1 1 2 2 2 2 2 1 2 2 2 2 1 2 2 2 1 2 2 2 1 2 2 1] Kmeans性能評估標準理想聚類目的效果如下圖所示 族群與族群之間的距離最大 族群內部各個樣本之間越相似越好 輪廓係數使用輪廓係數作為Kmeans性能評估標準 每一個樣本都有自己的輪廓係數 sc_i = \\frac {b_i-a_i}{max(b_i,a_i)} 對於每個點$i$為已聚類數據中的樣本 $b_i$為$i$到 其他族群的所有樣本的距離最小值 $a_i$為$i$到 本身簇其他點的距離之平均值 $sc_i$值介於$1$～$-1$之間 $b_i$ &gt;&gt; $a_i$ ： 會使$sc_i$趨近於1，聚類效果最好(分離度和內聚度相對較優) 通常超過0或是0.1以上聚類效果已經非常好 $b_i$ &lt;&lt; $a_i$ ： 會使$sc_i$趨近於-1，聚類效果不好 Kmeans性能評估指標API使用sklearn.metrics.silhouette_score silhouette_score(X, labels)計算所有樣本的平均輪廓係數 X：特徵值 labels: 被聚類標記的目標值 Example1234567891011121314151617181920from sklearn.cluster import KMeansfrom sklearn.datasets import load_irisfrom sklearn.metrics import silhouette_scoreX = load_iris().datadef cluster(): KM = KMeans(n_clusters=3) KM.fit(X) # 回傳標記的結果 predict_y = KM.predict(X) print(predict_y) # 輪廓係數計算 score = silhouette_score(X,predict_y) print(\"score = \",score) if __name__ == '__main__': cluster() Result123456[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 2 2 2 2 1 2 2 2 2 2 2 1 1 2 2 2 2 1 2 1 2 1 2 2 1 1 2 2 2 2 2 1 2 2 2 2 1 2 2 2 1 2 2 2 1 2 2 1]score = 0.5525919445213676 tips在不知道類別數目(n_clusters)的情況下，可使用silhouette_score評估，並把n_clusters作為超參數，進行多次驗證查看哪個輪廓係數最高 總結特點分析採用迭代算法，直觀易懂並且非常實用 缺點容易收斂到局部最優解，需多次隨機聚類找出最優解(API以內建)","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"演算法","slug":"演算法","permalink":"http://www.taroballz.com/tags/演算法/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"}]},{"title":"機器學習-邏輯回歸(Logistic Regression)","slug":"ML_LogisticRegression","date":"2018-07-17T17:00:00.000Z","updated":"2019-06-27T17:38:23.000Z","comments":true,"path":"2018/07/18/ML_LogisticRegression/","link":"","permalink":"http://www.taroballz.com/2018/07/18/ML_LogisticRegression/","excerpt":"Introduction 邏輯回歸是一種分類(classfication)演算法 一種廣泛使用於分類問題中的廣義回歸演算法 一種名為＂回歸＂的線性分類器 由線性回歸變化而來的 求解能夠讓模型對數據擬合程度最高的參數$w$的值 線性回歸(linear regression)的式子作為邏輯回歸的輸入 與linear regression一樣為一迭代演算法 存在cost function 不斷的迭代優化並更新權重$w$ 通過引入聯繫函數(link function)，將線性回歸方程$Z(x)$轉換為$g(z)$ 令$g(z)$的值分布在 0-1 之間，而得到分類模型 當$g(z)$接近0時樣本的label為0; $g(z)$接近1時樣本的label為1 此聯繫函數就是Sigmoid函數 只適用於二元分類的場景，邏輯回歸是解決二分類問題的利器 sklearn的邏輯回歸也可以做多分類的問題 一對多(One-vs-rest;OvR) 把某種分類看作1，剩下的分類類型都為0 在sklearn中為&quot;ovr&quot; 多對多(Many-vs-Many;MvM) 把好幾個分類劃為1，剩下的分類類型劃為0 在sklearn中為&quot;Multinominal&quot; 配合L1, L2正則項使用 也能得出具體的概率值 對邏輯回歸中過擬合的控制，通過正則化來實現","text":"Introduction 邏輯回歸是一種分類(classfication)演算法 一種廣泛使用於分類問題中的廣義回歸演算法 一種名為＂回歸＂的線性分類器 由線性回歸變化而來的 求解能夠讓模型對數據擬合程度最高的參數$w$的值 線性回歸(linear regression)的式子作為邏輯回歸的輸入 與linear regression一樣為一迭代演算法 存在cost function 不斷的迭代優化並更新權重$w$ 通過引入聯繫函數(link function)，將線性回歸方程$Z(x)$轉換為$g(z)$ 令$g(z)$的值分布在 0-1 之間，而得到分類模型 當$g(z)$接近0時樣本的label為0; $g(z)$接近1時樣本的label為1 此聯繫函數就是Sigmoid函數 只適用於二元分類的場景，邏輯回歸是解決二分類問題的利器 sklearn的邏輯回歸也可以做多分類的問題 一對多(One-vs-rest;OvR) 把某種分類看作1，剩下的分類類型都為0 在sklearn中為&quot;ovr&quot; 多對多(Many-vs-Many;MvM) 把好幾個分類劃為1，剩下的分類類型劃為0 在sklearn中為&quot;Multinominal&quot; 配合L1, L2正則項使用 也能得出具體的概率值 對邏輯回歸中過擬合的控制，通過正則化來實現 應用 廣告點擊率 用戶有點擊 用戶無點擊 是否為垃圾郵件 是否患病 金融詐騙 虛假帳號 評分卡製作 優點 邏輯回歸對線性關係的擬合效果極佳 若已知數據之間聯繫是非線性的，千萬不要應使用邏輯回歸進行分類 邏輯回歸計算快 計算效率優於SVM和隨機森林 邏輯回歸返回的分類結果不是固定的0,1，而是以小數形式呈現的類概率數字 可把回歸返回的結果當成連續型數據來利用 抗噪聲能力強 適合需要得到一個 二元分類概率 的場景，簡單，速度快 輸入 Z(x) = w_0 + w_1x_1 + w_2x_2 + ... + w_dx_d = w^Tx (x_0 = 1) 因邏輯回歸與線性回歸的式子是一樣的，因此邏輯回歸也有過擬合的問題 $w$被統稱為模型的參數，$w_0$為截距(intercept)，$w_1 ~ w_d$被稱為係數(coefficient) Sigmoid函數$\\require{AMScd}$\\begin{CD} \\text{線性回歸的輸入} @&gt;{\\text{sigmoid}}&gt;&gt; \\text{分類(邏輯回歸的核心)}\\end{CD} 能夠將輸入的值轉換，且最後輸出的值(y)一定會落在0-1之間(概率) 函數中間與y軸交叉的地方一定為0.5 其為一種歸一化(normalize)方法，與MinMaxScaler同理 Sigmoid函數只能無限趨近於0和1，所以仍與MinMaxScaler為不同的數據預處理方法 公式 h_{\\theta}(x) = g(z) = g(\\theta^Tx) = y(x) = \\frac{1}{1+e^{-\\theta^Tx}}整理完$g(z)$如下所示：sigmoid函數 g(z) = \\frac{1}{1+e^{-z}} $z$代表回歸的結果(輸入值) 輸出，也就是$g(z)$：為[0,1]區間的概率值，預設0.5為threshold $g(z)$ 小於 0.5 則歸為 0(False) $g(z)$ 大於 0.5 則歸為 1(True) 二元邏輯回歸的損失函數(cost function)其與linear regression原理相同，但由於是分類問題，損失函數固然不一樣，只能通過梯度下降求解 衡量參數$\\theta$($w$)重要的評估指標 用來求解最優參數$\\theta$($w$)的工具 衡量參數為$\\theta$($w$)的模型 擬訓練集時產生的信息損失大小 並以此衡量參數$\\theta$($w$)的優劣(損失越大，$\\theta$($w$)就越差；損失越小，$\\theta$($w$)就越好) 在求解參數$\\theta$($w$)時，追求損失函數最小，讓模型在訓練數據上的擬合效果最優 模型預測的準確率在訓練集上需盡量接近100% 旨在追求能夠讓損失函數最小化的$\\theta$($w$)的組合 注意！！ 沒有求解參數$\\theta$($w$)需求的模型就沒有損失函數 例如KNN，決策樹等模型 對數似然損失函數： cost(h_{\\theta}(x),y) = \\begin{cases} -\\log{h(x)}, & \\text{if y=1} \\\\\\\\ -\\log{(1-h(x))}, & \\text{if y=2} \\end{cases} $y$為目標類別為1(True)或是0(False) $h_{\\theta}(x)$為概率值 完整的cost function(類似信息熵計算) $\\theta$ or $w$:表示求解出來的一組參數(權重) $m$：樣本的個數 $y_i$：為樣本$i$上真實的Label $cost$損失的值越小，那麼預測類別的準確度會越高 優化邏輯回歸透過梯度下降求解 有可能存在多個局部最小值(linear regression只有一個全局最小值) 在梯度下降過程中，可能到達某個局部最低點，但不一定是全局函數的最低點 目前沒有有效的解決方式 多次的隨機初始化值來進行梯度下降，多次比較最後最小值的結果 求解過程中調整學習率 以上兩種方法都是盡量改善 儘管沒有達到全局最低點，仍維持一定不錯的效果 正則化 正則化是用來防止模型過擬合的過程 常用的有 L1正則化 及 L2正則化 兩種 分別通過在 損失函數 後面加上 參數向量(權重向量)$\\theta$($w$) 的 L1範式 和 L2範式 的倍數來實現 J(\\theta)_{L1} = C \\times J(\\theta) + \\sum_{j=1}^{n} \\mid \\theta_j \\mid (j \\geq 1) J(\\theta)_{L2} = C \\times J(\\theta) + \\sqrt{\\sum_{j=1}^{n} (\\theta_j)^2} (j \\geq 1) L1範式：參數$\\theta$($w$)向量中的每個參數的絕對值之和 L2範式：參數$\\theta$($w$)向量中的每個參數的平方和的開方值 $C$是用來控制正則化程度的 超參數 增加的範式被稱為正則項(懲罰項) 求解的參數$\\theta$($w$)取值必然改變，藉此來調節模型的擬合程度 L1正則化會將參數壓縮至0；L2正則化只會將參數壓縮盡量小，但不會到0 L1正則化的本質是一個特徵選擇的過程，掌管了參數的稀疏性 L1正則化越強，參數$\\theta$($w$)向量中就越多參數為0 參數越稀疏，選出來的特徵越少，以此防止過擬合 適用於數據維度很高的情況 其在特徵選擇時可以由嵌入法(Embedded)來完成 L2正則化，會盡量讓每個特徵對模型都有一些微小貢獻 攜帶信息少，對模型貢獻度不大的特徵參數會非常接近0 為防止過擬合，通常使用L2正則化就足夠 若還是過擬合，再使用L1正則化 sklearn邏輯回歸API 使用sklearn.linear_model.LogisticRegression 雖然為分類演算法，但卻在linear_model中 LogisticRegression12345class sklearn.linear_model.LogisticRegression(penalty=’l2’, dual=False, tol=0.0001, C=1.0, fit_intercept=True, intercept_scaling=1, class_weight=None, random_state=None, solver=’warn’, max_iter=100, multi_class=’warn’, verbose=0, warm_start=False, n_jobs=None, l1_ratio=None) 重要參數penalty正則化方法 可輸入l1及l2，預設為l2正則化 若選擇l1正則化，參數solver僅能使用&quot;liblinear&quot; 和 &quot;saga&quot; l2正則化參數solver中所有求解方式都可以使用 解決回歸造成過擬合的情況 C正則化力度的倒數，必須是一個大於0的浮點數 預設為1.0 正則項與損失函數的比值為1:1 C越小則損失函數會越小，模型對損失函數的懲罰越重，正則化的效力越強 參數$\\theta$($w$)會逐漸壓縮得越來越小 不同正則化方法，C的取值，使用學習曲線最優化 C為一 超參數 可調用coef_屬性查看訓練後的權重($w$) max_iter梯度下降所使用的限制步數(最大迭代次數) 預設為100 用來代替步長 其值越大，代表步長越小，模型迭代時間越長 其值越小，代表步長越大，模型迭代時間越短 使用屬性 estimator.n_iter_ 來查看真正實現的迭代次數 solver&quot;liblinear&quot;:座標下降法 支持的懲罰項：L1, L2 為預設的solver 只支持 一對多ovr分類 與 單純二分類 邏輯回歸 參考https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html solver項查看其他選項 multi_class告知模型，預測標籤 屬於何種分類問題的類型，常用於多元回歸 預設為&quot;ovr&quot;：二分類問題，或使用一對多形式來處理多分類問題 當標籤為多分類時才會使用一對多的形式 &quot;multinomial&quot;：表示處理多分類問題，使用 多對多(MvM) 形式來處理多分類問題 但在參數solver為&quot;liblinear&quot;時不可用 &quot;liblinear：是用來處理二分類的 &quot;auto&quot;:表示根據數據的分類情況和其他參數來確定模型要處理的分類問題的類型 class_weight 處理樣本不平衡問題 標籤的某個類別佔有很大的比例 新客戶違約 誤分類代價很高 分類失敗會付出慘痛代價，例如：潛在犯罪者誤識別成普通人；有癌症徵兆情況被判斷為沒有癌症 誤分類：捕捉某種特定分類，但是非常困難的情況 寧願錯殺一百也不放過一個 給少量的標籤更多的權重 讓模型更偏向少數類 向捕獲少數類的方向建模 預設為None 自動給予數據集中所有的標籤相同的權重 &quot;balanced&quot;：解決樣本不均衡問題，對少數類進行加權 重要屬性coef_查看訓練後每個特徵所對應的參數$\\theta$($w$) n_iter_返回求解中真正實現的迭代次 Example使用logistic regression檢測良/惡性乳腺癌數據數據網址https://www.kaggle.com/uciml/breast-cancer-wisconsin-data 12345678910111213141516171819202122232425262728293031323334353637383940414243from sklearn.linear_model import LogisticRegressionfrom sklearn.model_selection import train_test_splitfrom sklearn.preprocessing import StandardScalerfrom sklearn.metrics import confusion_matrix,classification_reportimport matplotlib.pyplot as pltimport pandas as pdimport seaborn as snscancer_data = \"./Kaggle Dataset/breastcancer/data.csv\"def Logistic_Test(): # 讀取數據 data = pd.read_csv(cancer_data) target = data[\"diagnosis\"] data = data.drop([\"diagnosis\",\"id\",\"Unnamed: 32\"], axis=1) X_train,X_test,y_train,y_test = train_test_split(data,target) # 標準化處理 Std = StandardScaler() X_train = Std.fit_transform(X_train) X_test = Std.transform(X_test) Rg = LogisticRegression(C=1.0) Rg.fit(X_train,y_train) y_predict = Rg.predict(X_test) # 查看confusion matrix mat = confusion_matrix(y_test,y_predict) print(\"score:\",Rg.score(X_test,y_test)) # 查看recall，及f1-score print(\"report:\\n\",classification_report(y_test,y_predict,labels=[\"B\",\"M\"],target_names=[\"良性\",\"惡性\"])) # target_names可自定義，但要對應label傳入的目標值的順序 # 顯示confusion matrix sns.heatmap(mat,square=True,annot=True,cbar=False) plt.xlabel(\"predict value\") plt.ylabel(\"true value\") plt.show()if __name__ == '__main__': Logistic_Test() 邏輯回歸中會將數量比較少的樣本視為True，假設數據中的良性data較少，則良性就為True，惡性則為False Result12345678score: 0.993006993006993report: precision recall f1-score support 良性 0.99 1.00 0.99 92 惡性 1.00 0.98 0.99 51avg / total 0.99 0.99 0.99 143 缺點 缺點 不好處理多分類的問題 softmax方法 - 邏輯回歸在多分類問題上的推廣(神經網路) - 用於圖像識別 比較naive bayes以下兩種演算法皆透過概率計算，得到的最後分類的結果 naive bayes 屬生成模型 須提前在數據集中去獲取不同樣本屬於各個類別的概率(先驗概率) 先驗概率 ： 需要從歷史數據中總結出概率信息 非常仰賴歷史訓練集得到的概率進行計算 適合解決多分類問題(常用於文本分類) 沒有超參數 logistic regression 屬判別模型 不需先得出先驗概率 適合解決二元分類問題 應用在二分類需要概率的場景(癌症有無) 超參數：正則化力度(C)","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"演算法","slug":"演算法","permalink":"http://www.taroballz.com/tags/演算法/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"}]},{"title":"機器學習-Ridge回歸","slug":"ML_overfit","date":"2018-07-16T09:16:00.000Z","updated":"2018-07-16T10:14:37.000Z","comments":true,"path":"2018/07/16/ML_overfit/","link":"","permalink":"http://www.taroballz.com/2018/07/16/ML_overfit/","excerpt":"Introduction對線性模型進行訓練學習會變成複雜的模型數據的特徵和目標值之間的關係，若不僅僅是線性關係，為了不斷地去擬合訓練集，會導致模型複雜度提高","text":"Introduction對線性模型進行訓練學習會變成複雜的模型數據的特徵和目標值之間的關係，若不僅僅是線性關係，為了不斷地去擬合訓練集，會導致模型複雜度提高 過擬合與欠擬合 檢驗欠擬合或是過擬合：透過結果的現象判斷並通過交叉驗證得知訓練結果 若再訓練過後結果不好，測試也不好：欠擬合 若再訓練過後結果為非常好(99%-100%)，測試卻只有80-90%：過擬合 欠擬合(underfitting)一個假設在訓練數據上不能獲得更好的擬合，但是在訓練數據外的數據集上也不能很好的擬合數據，此時認為這個假設出現了欠擬合現象(模型過於簡單) 學習的特徵太少(訓練集與測試集皆表現不好) 解決辦法：增加特徵的數量 過擬合(overfitting)一個假設在訓練數據上能夠獲得比其他假設更好的擬合，但是在訓練數據外的數據集上卻不能很好的擬合數據，此時認為這個假設出現了過擬合現象(模型過於複雜) 原始特徵過多，存在一些noise特徵，使其複雜化，因為模型會嘗試去兼顧各個測試數據點 線性回歸(linearRegression)容易出現過擬合的情況，原因就是為了把訓練集的數據表現更好 解決辦法 進行特徵選擇，消除關聯性大的特徵(較難做) 正則化 (在機器學習-特徵工程-降維 有提過) 正則化在訓練過程中不同特徵的權重($w_1, w_2, …$)會持續更新正則化便是不斷地調整，透過減少高次項特徵之權重$w$(趨近於0)，將回歸的結果不斷的smooth w_0 + w_1x_1 + w_2x_2^2 + \\fbox{$w_3$}x_3^3 + \\fbox{$w_4$}x_4^4 ; \\text{減少高次項特徵之權重使其趨近於0} 可使得$w$變小，使其與高次項特徵相乘時接近於0 優點 越小的參數說明模型越簡單 越簡單的模型越不容易發生過擬合的現象 Ridge使用Ridge回歸 解決過擬合的問題 一種帶有L2正則化的線性回歸 使用sklearn.linear_model.Ridge Ridge(alpha=1.0) 具有L2正則化的線性最小二乘法 alpha : 正則化力度($\\lambda$, 超參數) 通常介於0～1 or 1~10 之間 力度越大的情況下，權重會趨向於0，model簡單化 調用coef_屬性，查看最後回歸的權重 Example123456789101112131415161718192021222324252627from sklearn.linear_model import Ridgefrom sklearn.datasets import load_bostonfrom sklearn.model_selection import train_test_splitfrom sklearn.preprocessing import StandardScalerfrom sklearn.metrics import mean_squared_errorboston = load_boston()def Ridge_test(): X_train, X_test, y_train, y_test = train_test_split(boston.data,boston.target,test_size=0.25) StdS = StandardScaler() X_train = StdS.fit_transform(X_train) X_test = StdS.transform(X_test) Rg = Ridge(alpha = 1.0) Rg.fit(X_train,y_train) print(\"權重\\n\",Rg.coef_) y_predict = Rg.predict(X_test) print(\"預測結果：\\n\",y_predict) print(\"均方誤差為：\",mean_squared_error(y_test,y_predict))if __name__ == '__main__': Ridge_test() Result1234567891011權重 [-0.82177747 1.20950534 0.06552334 0.60526014 -2.25725199 2.49725259 0.00725436 -3.40161807 2.66837018 -2.28422927 -2.12014388 0.56002103 -3.65238349]預測結果： [16.96844917 20.71311538 15.5034732 23.45319042 21.04674699 24.9338077 20.91414999 29.09249464 11.53948481 30.18469936 14.37130082 44.67833472 ... ... 22.40497723]均方誤差為： 19.432609045304503 tips 藉由Ridge得到的回歸係數更符合實際，且更可靠 能讓估計參數的波動範圍變小，變得更穩定 在存在異常數據偏多的研究中，有較大的實用價值","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"},{"name":"過擬合(overfitting)","slug":"過擬合-overfitting","permalink":"http://www.taroballz.com/tags/過擬合-overfitting/"}]},{"title":"機器學習-線性回歸分析(linear regression)","slug":"ML_LinearRegression","date":"2018-07-15T18:00:00.000Z","updated":"2018-07-15T18:51:36.000Z","comments":true,"path":"2018/07/16/ML_LinearRegression/","link":"","permalink":"http://www.taroballz.com/2018/07/16/ML_LinearRegression/","excerpt":"Introduction 數據集的目標值(target)是一個連續型的值，便是一個回歸問題 回歸問題應用於房價分析、銷售額預測、貸款額度 回歸：在具有線性關係的點中，尋找一種能預測的趨勢 回歸演算法為迭代演算法(訓練結果會使預測結果越來越好) 訓練時會產生誤差且知道誤差，在訓練的過程中不斷地減少誤差","text":"Introduction 數據集的目標值(target)是一個連續型的值，便是一個回歸問題 回歸問題應用於房價分析、銷售額預測、貸款額度 回歸：在具有線性關係的點中，尋找一種能預測的趨勢 回歸演算法為迭代演算法(訓練結果會使預測結果越來越好) 訓練時會產生誤差且知道誤差，在訓練的過程中不斷地減少誤差 線性關係模型一個通過屬性的線性組合來進行預測的函數： f(x) = w_1x_1 + w_2x_2 + ... + w_dx_d + b w 為權重 b 稱為偏置項(截距)，可以理解為：$w_0 \\times 1$ 線性回歸(linear regression)線性回歸通過一個或者多個自變量(特徵) 與 因變量(目標值) 之間進行建模的回歸分析，其中可以為一個或多個 自變量(特徵) 與 權重 的 線性組合 一元線性回歸：涉及到的變量只有一個 多元線性回歸：涉及到的變量有兩個或兩個以上 公式 h(w) = w_0 + w_1x_1 + w_2x_2 + ... = w^Tx 其中w,x皆為一維矩陣： w = \\begin{bmatrix} w_0 \\\\ w_1 \\\\ w_2 \\\\ \\end{bmatrix} x = \\begin{bmatrix} 1 \\\\ x_1 \\\\ x_2 \\\\ \\end{bmatrix}損失函數(誤差大小, cost function)在回歸演算法中都是會有屬於自己的cost function 定義：(又稱最小二乘法，對誤差求平方和) J(\\theta) = (h_w(x_1) - y_1)^2 + (h_w(x_2) - y_2)^2 + ... + (h_w(x_m)-y_m)^2 = \\sum_{i=1}^m (h_w (x_i) - y_i)^2 $y_i$為第$i$個訓練樣本的真實值 $h_w(x_i)$為第$i$個訓練樣本特徵值組合預測結果 損失越少越好 優化迭代(學習)的過程就是優化w權重的過程；求模型中的w值，使得損失為最小 正規方程可直接求cost function的最小值，但較不適用於樣本非常多的情況 w = (X^{T}X)^{-1}X^{T}y X 為特徵值矩陣 y 為目標值矩陣 當特徵過於複雜，求解速度慢 梯度下降(Gradient descent) 沿著這個函數下降的方向找，最後能找到山谷的最低點，每次跨出一步都會更新w值 通常使用在面對訓練數據規模十分龐大的任務 以單變量中的w1,w0作為例子 w_1 := -w_1 - \\alpha \\frac{\\partial}{\\partial w_1} J(w_0,w_1) w_0 := -w_0 - \\alpha \\frac{\\partial}{\\partial w_1} J(w_0,w_1) $\\alpha$：為學習速率，需要手動指定 $\\alpha$後面的計算結果為梯度下降的方向 w值在訓練的過程中會不斷地更新，使得cost function越來越小 回歸性能評估通常使用均方誤差(Mean Squared Error,MSE)評價機制 MSE = \\frac{1}{m} \\sum_{i=1}^{m} (y^i - \\widetilde{y})^2 $y^i$為預測值 $\\widetilde{y}$為真實值 sklearn中正規方程與梯度下降API 正規方程使用sklearn.linear_model.LinearRegression 可通過coef_屬性查看最後w值(權重)；回歸係數 梯度下降使用sklearn.linear_model.SGDRegressor 可通過coef_屬性查看最後w值(權重)；回歸係數 sklearn中已將學習率$\\alpha$封裝，因此不需指定學習率 使用線性回歸model時數據需經過標準化處理 深怕某個特徵值特別大而影響目標值 特徵值(x)須標準化處理 目標值(y)是否標準化處理看需求 回歸性能評估計算均方誤差使用sklearn.metrics.mean_squared_error(y_true, y_pred) 計算均方誤差回歸損失 y_true: 真實值 y_pred: 預測值 return: float類型數值，越小越好 注意：真實值與預測值均為標準化之前的值 Example LinearRegression1234567891011121314151617181920212223242526272829303132333435from sklearn.linear_model import LinearRegressionfrom sklearn.datasets import load_bostonfrom sklearn.model_selection import train_test_splitfrom sklearn.preprocessing import StandardScalerfrom sklearn.metrics import mean_squared_error# 獲取數據boston = load_boston()def LinearRegression_test(): #分割訓練集及測試集 X_train,X_test,y_train,y_test = train_test_split(boston.data,boston.target,test_size=0.25) #數據標準化處理 X_Stdscaler = StandardScaler() X_train = X_Stdscaler.fit_transform(X_train) X_test = X_Stdscaler.transform(X_test) y_Stdscaler = StandardScaler() y_train = y_Stdscaler.fit_transform(y_train.reshape(-1,1)) # estimatorm預測 LR = LinearRegression() LR.fit(X_train,y_train) print(\"w權重：\\n\", LR.coef_) y_predict = LR.predict(X_test) y_predict = y_Stdscaler.inverse_transform(y_predict) print(\"預測的房價：\\n\",y_predict.reshape(1,-1)) # MeanSquaredError print(\"均方誤差為：\",mean_squared_error(y_test,y_predict))if __name__ == '__main__': LinearRegression_test() sklearn中的任何transformer或是estimator用來fit或是transform的數據必須是一個二維的陣列，因此需要reshape Result123456789101112w權重： [[-0.10758616 0.06812624 0.07253587 0.07240224 -0.21829879 0.33539411 -0.03115752 -0.29252316 0.27082133 -0.21269287 -0.24595448 0.09319976 -0.39137572]]預測的房價： [[27.19703402 -0.3840721 20.25271244 26.82856768 18.68858977 12.58656872 24.88169586 20.35108225 17.49560551 33.10084889 34.46248469 24.78596238 ... ... 16.91419754 22.38796794 10.94529887 12.72310632 22.87812591 18.91468558 22.79921829]]均方誤差為： 25.70783805560611 數據較簡單的情況下建議就直接使用LinearRegression Example GradientDescent1234567891011121314151617181920212223from sklearn.linear_model import SGDRegressorfrom sklearn.datasets import load_bostonfrom sklearn.model_selection import train_test_splitfrom sklearn.preprocessing import StandardScalerfrom sklearn.metrics import mean_squared_errorboston = load_boston()def SGD_test(): X_train,X_test,y_train,y_test = train_test_split(boston.data,boston.target,test_size=0.25) X_Stdscaler = StandardScaler() X_train = X_Stdscaler.fit_transform(X_train) X_test = X_Stdscaler.transform(X_test) SGD = SGDRegressor() SGD.fit(X_train,y_train) print(\"w權重：\\n\", SGD.coef_) y_predict = SGD.predict(X_test) print(\"預測的房價：\\n\",y_predict) print(\"均方誤差為：\",mean_squared_error(y_test,y_predict)) SGDRegressor的參數learning_rate不是一個具體的數值，內部已經有封裝，詳情請看文檔 Result123456789101112w權重： [-0.68801761 0.33828819 -0.32654615 1.09123264 -0.59907588 3.12320933 -0.24405887 -1.86075997 0.74936682 -0.24540297 -1.89584165 1.14755048 -3.55851847]預測的房價： [13.59250283 21.1141011 13.46418833 12.12910793 32.15773134 30.42992058 37.16422439 15.07917749 19.87894082 19.6978997 30.42347672 22.04216396 ... ... 36.10743071 19.64863248 29.92243733 19.50016195 23.00034865 11.65818568 33.69281417]均方誤差為： 18.33685522657918 數據量較大的情況下通常用梯度下降 tips 梯度下降(GradientDescent) 正規方程(LinearRegression) 需要選擇學習速率$\\alpha$ 不需要 需要多次迭代(學習)過程 一次運算可得出結果 當特徵數量非常多時也能適用 需要計算$(X^{T}X)^{-1}$，如果特徵數量大時，運算代價較大 適用於各種類型模型(為一種通用的求解方式) 只適用於線性模型，不適合邏輯回歸模型等其他模型 LinearRegression 不能解決過擬合、欠擬合等問題","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"演算法","slug":"演算法","permalink":"http://www.taroballz.com/tags/演算法/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"}]},{"title":"機器學習-演算法-隨機森林(random forest)","slug":"ML_RandomForest","date":"2018-07-14T10:15:00.000Z","updated":"2019-05-22T02:25:38.000Z","comments":true,"path":"2018/07/14/ML_RandomForest/","link":"","permalink":"http://www.taroballz.com/2018/07/14/ML_RandomForest/","excerpt":"隨機森林(random forest)在機器學習中，隨機森林是一個包含多個決策樹的分類器，並且其輸出的類別是由個別樹輸出的類別的眾數而定 如果訓練了五個樹其中有四個樹的結果為True，一個的結果為False，那麼最終的結果為True(投票決定)","text":"隨機森林(random forest)在機器學習中，隨機森林是一個包含多個決策樹的分類器，並且其輸出的類別是由個別樹輸出的類別的眾數而定 如果訓練了五個樹其中有四個樹的結果為True，一個的結果為False，那麼最終的結果為True(投票決定) 建立多個決策樹的過程假設有一匹N個樣本，M個特徵的數據集 隨機在N個樣本當中抽取一個樣本(會放回)，重複N次 有可能會抽到重複的樣本 bootstrap抽樣 隨機在M個特徵當中選取m個特徵 m &lt; M 重複N次建立每顆決策樹 每個決策樹基於的樣本特徵大多不是一樣的 為何要隨機抽樣訓練集如果不進行隨機抽樣，每棵樹的訓練集都一樣，那最終訓練出的樹的分類結果也是完全一樣的 為什麼要有放回的抽樣如果不是有放回的抽樣，那麼每棵樹的訓練樣本都是不同的，都是沒有交集的，也就是說每：棵樹訓練出來都是有很大差異的；而隨機森林最後分類取決於多棵樹(弱分類器)的投票表決 調用隨機森林API使用sklearn.ensemble.RandomForestClassifier(n_estimators=10, criterion=&quot;gini&quot;, max_depth=None, bootstrap=True, random_state=None) 調用隨機森林分類器 n_estimators: int，森林裡樹木的數量，預設為10，為超參數 criterion: string，分類依據(分割特徵的測量方法)，預設為根據gini係數分類 max_depth: int或None，樹的最大深度，預設為None，為超參數 bootstrap:是否隨機抽樣，默認為True max_features: 每個決策樹最大的特徵數量，預設為”auto” “auto”: max_features = sqrt(n_features) “sqrt”: max_features = sqrt(n_features) 與”auto”一樣 “log2”: max_features = log2(n_features) None : max_features = n_features min_samples_split : min_samples_leaf : bootstrap : boolean，預設為True，是否在構建樹時使用放回抽樣 Example隨機森林搭配超參數優化(GridSearchCV)12345678910111213141516171819202122232425262728293031323334from sklearn.ensemble import RandomForestClassifierfrom sklearn.model_selection import train_test_split,GridSearchCVfrom sklearn.feature_extraction import DictVectorizerimport pandas as pddatapath = \"/Volumes/MacData/MEGA/pythonwork/jupyter_project/Kaggle Dataset/Titanic/train.csv\"def RandomForestTest(): data = pd.read_csv(datapath) X = data[[\"Pclass\",\"Sex\",\"Age\"]] Y = data[\"Survived\"] X[\"Age\"].fillna(X[\"Age\"].mean(),inplace=True) X_train,X_test,y_train,y_test = train_test_split(X,Y,test_size=0.25) DV = DictVectorizer(sparse=False) X_train = DV.fit_transform(X_train.to_dict(orient=\"records\")) X_test = DV.transform(X_test.to_dict(orient=\"records\")) # 實例化隨機森林分類器 RF = RandomForestClassifier() # 測試超參數優化 RF_param = &#123;\"n_estimators\":[10,50,100,150,200],\"max_depth\":[5,10,15,20]&#125; GSCV = GridSearchCV(RF,param_grid=RF_param,cv=5) GSCV.fit(X_train,y_train) print(\"accuracy score\",GSCV.score(X_test,y_test)) print(\"The best model param :\",GSCV.best_params_)if __name__ == '__main__': RandomForestTest() Result12accuracy score 0.8071748878923767The best model param : &#123;&apos;max_depth&apos;: 5, &apos;n_estimators&apos;: 150&#125; 優缺點 優點 在當前所有演算法中，具有極好的準確率，也是使用最多的 數據量越大或越複雜相對於其他演算法優勢越明顯，能夠有效的運行在大數據集上 能夠處理具有高維特徵的輸入樣本，而且不需要降維 能夠評估各個特徵在分類問題上的重要性 缺點 在選到合適的參數時須不斷地進行測試","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"演算法","slug":"演算法","permalink":"http://www.taroballz.com/tags/演算法/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"},{"name":"集成學習方法","slug":"集成學習方法","permalink":"http://www.taroballz.com/tags/集成學習方法/"}]},{"title":"機器學習-演算法-決策樹(decision tree)","slug":"ML_decision_tree","date":"2018-07-13T20:21:00.000Z","updated":"2019-04-28T09:02:45.000Z","comments":true,"path":"2018/07/14/ML_decision_tree/","link":"","permalink":"http://www.taroballz.com/2018/07/14/ML_decision_tree/","excerpt":"Introduction程序設計中的條件分支結構就是if-else結構，最早的決策樹就是利用這類結構分割數據的一種分類學習方法 去找到高效的決策順序 特徵的先後順序","text":"Introduction程序設計中的條件分支結構就是if-else結構，最早的決策樹就是利用這類結構分割數據的一種分類學習方法 去找到高效的決策順序 特徵的先後順序 信息 消除隨機不定性的東西 信息熵 衡量消除的不確定性有多少在選擇64個數字中，誰會是終極密碼的信息量應該為6bit(二分法往下尋找)且在開放某些信息的情況下，信息熵(代價)會比6bit少準確的信息量應為: H = -(p1\\log(p1) + p2\\log(p2) + ... + p64log(p64)) H為信息熵單位為(bit) 公式 H(X) = - \\sum P(x_i) \\log(P(x_i)) 當上面64個數字選取的機率相同時，對應的信息熵等於6bit 信息熵越大，不確定性亦越大 決策樹作為決策樹越前面的決策，通常是為了大幅的減少不確定性(大幅降低信息熵)因此作為越前面的決策，它減少的信息熵一定會比接下來的決策大 常見的決策樹演算法 ID3 信息增益 (最大作為決策優先) C4.5 信息增益比 (最大作為決策優先) CART 回歸樹：平方誤差 (最小作為決策優先) 分類樹：基尼係數 (最小作為決策優先) 在sklearn中決策樹演算法的默認原則 相對信息增益而言 劃分更加仔細 信息增益 為決策樹劃分的依據之一 定義：當得知一個特徵條件X之後，使得類別Y信息的不確定性減少的程度(信息熵減少程度)，程度越大則為越前面的決策 公式特徵$A$對訓練數據集$D$的信息增益，記作 $g(D,A)$定義為 集合$D$ 的信息熵為 $H(D)$ 與 給定特徵$A$的條件下 $D$的條件信息熵記作$H(D|A)$ 之差 g(D,A) = H(D) - H(D|A) $H(D)$：初始信息熵大小 $H(D|A)：條件熵的大小 sklearn決策樹API 為一種estimator 使用sklearn.tree.DecisionTreeClassifier(criterion=&quot;gini&quot;, max_depth=None, random_state=None) criterion：預設是使用”gini”係數進行分類，選擇信息增益的熵作為分類依據則使用”entropy” max_depth：樹的深度大小 (為超參數 可調優) 不設置的話會去擬合所有數據，使得決策樹非常的大 泛化能力差 過擬合 random_state：隨機數seed 樹的結構可視化 Example12345678910111213141516171819202122232425262728293031from sklearn.model_selection import train_test_splitfrom sklearn.feature_extraction import DictVectorizerfrom sklearn.tree import DecisionTreeClassifierimport pandas as pddatapath = \"../Kaggle Dataset/Titanic/train.csv\"def Decision(): data = pd.read_csv(datapath) X = data[[\"Pclass\",\"Sex\",\"Age\"]] Y = data[\"Survived\"] # 填補缺失值 X[\"Age\"].fillna(X[\"Age\"].mean(),inplace=True) # inplace是否直接替換 X_train,X_test,y_train,y_test = train_test_split(X,Y,test_size=0.25) # 特徵為類別使用one-hot編碼(性別、船艙...等) DV = DictVectorizer(sparse=False) # DictVectorizer需使用字典形式，使用to_dict轉換為字典形式 X_train = DV.fit_transform(X_train.to_dict(orient=\"records\")) # orient為records為一行行轉換 X_test = DV.transform(X_test.to_dict(orient=\"records\")) D_tree = DecisionTreeClassifier() D_tree.fit(X_train,y_train) score = D_tree.score(X_test,y_test) print(\"score:\",score)if __name__ == '__main__': Decision() result1score: 0.8251121076233184 樹的特性estimator.feature_importances_ 可列出各feature的重要性程度，越大的數表示該屬性越重要 為0表示並沒有用到該特徵進行分類 可使用zip進行合併 [*zip(feature_name,estimator.feature_importances_)] 決策樹可視化 使用sklearn.tree.export_graphviz()導出dot格式 export_graphviz tree.export_graphviz(estimator, out_file=”./tree.dot”, feature_names=[“”,””],class_names=[“”,””]) estimator : 實例化的estimator物件 out_file : 輸出文件名 feature_names : 樹的劃分是按特徵進行劃分的，將他的get_featurenames貼上 [“Age”,”pclass=1st”,”pclass=2nd”,”pclass=3rd”,”sex=female”,”sex_male”] class_names：最後的target_name [“cat”,”dog”] filled：是否將葉子節點進行塗色(True or False),方便查看不同target怎麼進行分類 顏色越淺代表不純度越高 rounded：方塊是否圓滑(True or False) 1234567import graphvizdot_data = tree.export_graphviz(D_tree, feature_names=data.get_featurenames, class_names=[\"survied\",\"unsurvied\"], fileed=True, rounded=True)graph = graphviz.Source(dot_data) 工具graphviz可視化 brew install graphviz 轉成圖片使用dot -Tpng tree.dot -o tree.png 優缺點 優點： 簡單的理解和解釋，樹木可視化 可解釋能力強 數據的前處理很少，其他技術通常需要歸一化或標準化處理 缺點： 一開始學習決策樹演算法時，常常創建不能很好的分類數據過於複雜的樹被稱之為過擬合 複雜的決策樹雖在訓練集中100%擬合，但在測試數據時往往表現不好 改進： 使用剪枝cart算法(在決策樹的API當中已實現)，減少過擬合的情況發生 在實例化決策樹DecisionTreeClassifier時有兩個參數為min_samples_split及min_samples_leaf可控制分支數 min_samples_split min_samples_leaf 隨機森林 tips 企業重要決策，由於決策樹很好的分析能力，在決策過程應用較多","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"演算法","slug":"演算法","permalink":"http://www.taroballz.com/tags/演算法/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"}]},{"title":"機器學習-模型的選擇與調校參數","slug":"ML_Model_Select_optimize","date":"2018-07-09T17:18:00.000Z","updated":"2019-05-21T17:16:00.000Z","comments":true,"path":"2018/07/10/ML_Model_Select_optimize/","link":"","permalink":"http://www.taroballz.com/2018/07/10/ML_Model_Select_optimize/","excerpt":"交叉驗證(cross validation) 目的：為了讓被評估的模型更加準確可信 觀察模型穩定性的一種方法 交叉驗證通常搭配網格搜索一起使用 將訓練數據分成n等分，以下圖為例：讓其中一等分當作驗證集 其他則為訓練集，總共驗證5次(組)，每次更換不同的驗證集，得到5組模型的結果，求出準確率的平均值作為最終結果，又稱5折交叉驗證","text":"交叉驗證(cross validation) 目的：為了讓被評估的模型更加準確可信 觀察模型穩定性的一種方法 交叉驗證通常搭配網格搜索一起使用 將訓練數據分成n等分，以下圖為例：讓其中一等分當作驗證集 其他則為訓練集，總共驗證5次(組)，每次更換不同的驗證集，得到5組模型的結果，求出準確率的平均值作為最終結果，又稱5折交叉驗證 cross_val_score 其位於sklearn.model_selection中，直接導入即可 sklearn.model_selection.cross_val_score(estimator, X, y=None, groups=None, scoring=None, cv=’warn’) estimator：任何實例化後的estimator X：完整的特徵矩陣 不需要劃分訓練集及測試集 y：完整的標籤矩陣 不需要劃分訓練集及測試集 cv：指定幾折交叉驗證 scoring：使用scoring指定的參數來衡量模型 如果不指定：對回歸模型來說，預設會返回$R^2$之值 仍可進行判斷 $R^2$其越接近1越好 但在進行回歸模型評估時一般較常使用$MSE(mean squared error)$來衡量模型的表現 MSE越接近0越好 scoring = “neg_mean_squared_error” Example12345678from sklearn.model_selection import cross_val_scorefrom sklearn.tree import DecisionTreeRegressorfrom sklearn.datasets import load_bostonboston = load_boston()regTree_clf = DecisionTreeRegressor(random_state=0)cross_val_score(regTree_clf,boston.data,boston.target,cv=10,scoring=\"neg_mean_squared_error\") Result123array([-16.41568627, -10.61843137, -18.30176471, -55.36803922, -16.01470588, -44.70117647, -12.2148 , -91.3888 , -57.764 , -36.8134 ]) Ref : https://github.com/curtis992250/MachineLearning_StudyNote/blob/master/1.%20DecisionTree%20Code/crossval.ipynb 網格搜索(超參數搜索) 通常情況下，有很多參數需要手動指定(如：K Neighbors Classifier的K值)，稱之為超參數 調整參數的用意是希望model所表現的預測效果越好 手動過程繁雜，所以需要對模型預設幾種超參數組合，且每組超參數都採用交叉驗證來進行評估，最後選出最優的參數組合建立模型 當同一個演算法，超參數不止一個時會進行交叉測試 使用sklearn.model_selection.GridSearchCV (網格搜索並同時交叉驗證) 能夠幫助我們同時調整一個模型的多個參數的技術(枚舉技術) 返回最優參數的組合 GridSearchCV與使用演算法estimator的方法是一樣的 對估計器(estimator)指定的參數進行詳盡的搜索 sklearn.model_selection.GridSearchCV(estimator, param_grid, cv=None) estimator : 估計器object param_grid : 估計器參數(dict)，如：{&quot;n_neighbors&quot;:[1,3,5]} 我們希望網格搜索來搜索的參數及其取值範圍 cv : 指定幾折交叉驗證 最常使用10折交叉驗證 返回的就是一個新的做好驗證的estimator object，仍可以調用fit, predict, score等方法 可調用結果分析方法： bestparams：從我們輸入的參數和參數取值的列表中，返回最佳參數組合 bestscore : 在交叉驗證中驗證的最好結果 其為網格搜索後的模型評判標準 bestestimator : 最好的參數模型 cvresults : 每次交叉驗證後的驗證集準確率結果和訓練集準確率結果 Example I1234567891011121314151617181920212223from sklearn.model_selection import GridSearchCV,train_test_splitfrom sklearn.datasets import load_irisfrom sklearn.neighbors import KNeighborsClassifierfrom sklearn.metrics import accuracy_scoreiris_data = load_iris()def GridSearchCV_test(): knn = KNeighborsClassifier() K_value = &#123;\"n_neighbors\":[3,5,7,10]&#125; GS_CV = GridSearchCV(knn, param_grid=K_value, cv=3) x_train, x_test, y_train, y_test = train_test_split(iris_data.data,iris_data.target) GS_CV.fit(x_train,y_train) y_predict = GS_CV.predict(x_test) score = accuracy_score(y_test,y_predict) print(\"準確率：\",score) print(\"在交叉驗證中驗證的最好結果:\",GS_CV.best_score_) print(\"最好的參數模型:\\n\",GS_CV.best_estimator_) print(\"每次交叉驗證後的驗證集準確率結果和訓練集準確率結果:\\n\",GS_CV.cv_results_)if __name__ == '__main__': GridSearchCV_test() 結果1234567891011準確率： 0.9473684210526315在交叉驗證中驗證的最好結果: 0.9910714285714286最好的參數模型: KNeighborsClassifier(algorithm=&apos;auto&apos;, leaf_size=30, metric=&apos;minkowski&apos;, metric_params=None, n_jobs=1, n_neighbors=10, p=2, weights=&apos;uniform&apos;)每次交叉驗證後的驗證集準確率結果和訓練集準確率結果: &#123;&apos;mean_fit_time&apos;: array([0.00023023, 0.0001897 , 0.00018748, 0.00018843]), &apos;std_fit_time&apos;: array([5.71920846e-05, 8.99132768e-07, 1.38109105e-06, 4.49566384e-07]), &apos;mean_score_time&apos;: array([0.00042526, 0.00037464, 0.00037185, 0.00038997]), &apos;std_score_time&apos;: array([7.77299011e-05, 4.85630548e-06, 8.77806426e-07, 7.62525420e-06]), &apos;param_n_neighbors&apos;: masked_array(data=[3, 5, 7, 10], mask=[False, False, False, False], fill_value=&apos;?&apos;, dtype=object), &apos;params&apos;: [&#123;&apos;n_neighbors&apos;: 3&#125;, &#123;&apos;n_neighbors&apos;: 5&#125;, &#123;&apos;n_neighbors&apos;: 7&#125;, &#123;&apos;n_neighbors&apos;: 10&#125;], &apos;split0_test_score&apos;: array([0.97368421, 0.97368421, 0.97368421, 0.97368421]), &apos;split1_test_score&apos;: array([1. , 0.97297297, 0.97297297, 1. ]), &apos;split2_test_score&apos;: array([0.97297297, 0.97297297, 0.97297297, 1. ]), &apos;mean_test_score&apos;: array([0.98214286, 0.97321429, 0.97321429, 0.99107143]), &apos;std_test_score&apos;: array([0.01254582, 0.00033675, 0.00033675, 0.01245966]), &apos;rank_test_score&apos;: array([2, 3, 3, 1], dtype=int32), &apos;split0_train_score&apos;: array([1. , 1. , 1. , 0.98648649]), &apos;split1_train_score&apos;: array([0.98666667, 0.98666667, 0.98666667, 0.98666667]), &apos;split2_train_score&apos;: array([0.98666667, 0.98666667, 0.98666667, 0.98666667]), &apos;mean_train_score&apos;: array([0.99111111, 0.99111111, 0.99111111, 0.98660661]), &apos;std_train_score&apos;: array([6.28539361e-03, 6.28539361e-03, 6.28539361e-03, 8.49377515e-05])&#125; Example II1234567891011121314151617181920212223242526272829303132import numpy as npimport pandas as pdfrom sklearn.tree import DecisionTreeClassifierfrom sklearn.model_selection import GridSearchCV,train_test_splitdata = pd.read_csv(\"./Taitanic_data/data.csv\")def Taitanic_survived_predict_with_GridSearchCV(): gini_threshold = np.linspace(0,0.5,50).tolist() # entropy_thresholds = np.linspace(0,1,50) tree_clf = DecisionTreeClassifier(random_state=20) parameters = &#123;\"criterion\":[\"gini\",\"entropy\"] ,\"splitter\":[\"best\",\"random\"] ,\"max_depth\":[x for x in range(1,10)] ,\"min_samples_leaf\":[x for x in range(1,50,5)] ,\"min_impurity_decrease\":gini_threshold &#125; x = data.iloc[:,data.columns != \"Survived\"] y = data.iloc[:,data.columns == \"Survived\"] Xtrain,Xtest,ytrain,ytest = train_test_split(x,y,test_size=0.3) GS_CV = GridSearchCV(tree_clf,param_grid=parameters,cv=10) GS_CV.fit(Xtrain,ytrain) print(\"最好的參數模型:\\n\",GS_CV.best_params_) print(\"在交叉驗證中驗證的最好結果:\",GS_CV.best_score_) if __name__ == '__main__': Taitanic_survived_predict_with_GridSearchCV() 結果1234567最好的參數模型: &#123;&apos;criterion&apos;: &apos;entropy&apos;, &apos;max_depth&apos;: 8, &apos;min_impurity_decrease&apos;: 0.0, &apos;min_samples_leaf&apos;: 6, &apos;splitter&apos;: &apos;best&apos;&#125;在交叉驗證中驗證的最好結果: 0.8327974276527331","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"}]},{"title":"機器學習-分類模型評估","slug":"ML_Classifier_Model","date":"2018-07-08T18:42:00.000Z","updated":"2018-07-10T08:11:15.000Z","comments":true,"path":"2018/07/09/ML_Classifier_Model/","link":"","permalink":"http://www.taroballz.com/2018/07/09/ML_Classifier_Model/","excerpt":"Introduction 前面對兩種分類模型皆調用score()方法查看準確率，其就是一種對模型的評估， 返回預測結果正確的百分比 sklearn還存在許多對預測模型評估的方法皆收錄在sklearn.metrics中 這一章節只著重在對分類模型的評估 還有其他對分類模型評估的指標包括 精確率(precision) 與 召回率(recall)","text":"Introduction 前面對兩種分類模型皆調用score()方法查看準確率，其就是一種對模型的評估， 返回預測結果正確的百分比 sklearn還存在許多對預測模型評估的方法皆收錄在sklearn.metrics中 這一章節只著重在對分類模型的評估 還有其他對分類模型評估的指標包括 精確率(precision) 與 召回率(recall) 混淆矩陣(confusion matrix)在分類任務下，預測結果(predicted condition)與正確標記(true condition)之間存在四種不同的組合，構成所謂的混淆矩陣(適用於多分類) 可使用sklearn.metrics.confusion_matrix搭配matplotlib及seaborn.heatmap來繪製 Example12345678910111213141516171819202122232425262728from sklearn.datasets import load_irisfrom sklearn.neighbors import KNeighborsClassifierfrom sklearn.model_selection import train_test_splitfrom sklearn.metrics.classification import accuracy_scorefrom sklearn.metrics import confusion_matriximport matplotlib.pyplot as pltimport seaborn as sns iris_data = load_iris()def ConfusinMatrix(): x_train, x_test, y_train, y_test = train_test_split(iris_data.data, iris_data.target) KNN = KNeighborsClassifier(n_neighbors=5) KNN.fit(x_train, y_train) y_predict = KNN.predict(x_test) mat = confusion_matrix(y_test,y_predict) print(\"accuracy score:\", accuracy_score(y_test, y_predict)) sns.heatmap(mat,square= True, annot=True, cbar= False) plt.xlabel(\"predicted value\") plt.ylabel(\"true value\") plt.show()if __name__ == '__main__': ConfusinMatrix() 要是使用jupyter notebook進行繪製可在導入matplotlib.pyplot後添加以下code，取代plt.show()1%matplotlib inline 可讓圖形不會在新視窗呈現 Result1accuracy score: 0.9736842105263158 其他評估方法精確率(precision)預測值為True情況下真實值仍為True所佔的比例(查得準) 一般較少使用精確率來評估模型 召回率(recall)真實值為True的情況下預測值仍為True所佔的比例(查得全，對正樣本的區分能力) 例如癌症的分析，寧願錯估沒有癌症的人得癌，也不能將得癌症的人錯估成沒有癌症 上述案例我們會希望召回率越高越好甚至100%，而沒有那麼在乎準確率 F1-score 是一種用來評估模型穩健程度的標準 其公式如下 F1 = \\frac {2TP} {2TP+FN+FP} = \\frac {2 \\cdot Precision \\cdot Recall} {Precision + Recall} 其反應的是再提高召回率的同時是不是有維持一定的準確率 仍是越大越好，是一個綜合的評判標準 分類模型評估的API 使用sklearn.metrics.classification_report classification_report 調用classification_report(y_true,y_pred,target_names=None) y_true: 真實目標值 y_pred: estimator預測的目標值 target_names : 目標不同類別的名稱 返回每個類別precision及recall Example1234567891011121314151617181920from sklearn.datasets import load_irisfrom sklearn.naive_bayes import GaussianNBfrom sklearn.model_selection import train_test_splitfrom sklearn.metrics.classification import accuracy_scorefrom sklearn.metrics import classification_reportiris_data = load_iris()def model_metrics(): x_train,x_test,y_train,y_test = train_test_split(iris_data.data,iris_data.target) NB = GaussianNB() NB.fit(x_train,y_train) y_predict = NB.predict(x_test) print(\"accuracy score:\", accuracy_score(y_test,y_predict)) print(\"report:\\n\",classification_report(y_test,y_predict,target_names=iris_data.target_names))if __name__ == '__main__': model_metrics() 結果123456789accuracy score: 0.8947368421052632report: precision recall f1-score support setosa 1.00 1.00 1.00 16 versicolor 0.77 0.91 0.83 11 virginica 0.89 0.73 0.80 11avg / total 0.90 0.89 0.89 38","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"}]},{"title":"機器學習-演算法-Naive Bayes Classifier","slug":"ML_Naive_Bayes_Classifier","date":"2018-07-08T10:11:00.000Z","updated":"2019-05-19T07:28:17.000Z","comments":true,"path":"2018/07/08/ML_Naive_Bayes_Classifier/","link":"","permalink":"http://www.taroballz.com/2018/07/08/ML_Naive_Bayes_Classifier/","excerpt":"Introductionnaive：假設特徵與特徵之間是相互獨立的較常用於文檔的分類，求出一個文本佔不同類別的概率多少，並找出最大的概率 例如在獲得一文檔時，文檔為科技類別的概率 使用sklearn.naive_bayes.MultinomialNB","text":"Introductionnaive：假設特徵與特徵之間是相互獨立的較常用於文檔的分類，求出一個文本佔不同類別的概率多少，並找出最大的概率 例如在獲得一文檔時，文檔為科技類別的概率 使用sklearn.naive_bayes.MultinomialNB 概率概率定義為一件事情發生的可能性 $P(x)$介於0至1之間 聯合概率包含多個條件，且所有條件同時成立的概率記作 P(A,B) P(A,B) = P(A)P(B) 上述條件要是成立，則稱事件A與事件B相互獨立 條件概率事件A在另外一個事件B已經發生的條件下發生的概率記作 P(A|B)特性： P(A1,A2|B) = P(A1|B)P(A2|B) 在B條件下，A1條件成立及A2條件成立的概率 注意：上述條件概率的成立，須建立在A1與A2必須互相獨立(條件之間互不相影響) 在使用naive bayes演算法時也需確保條件獨立 Bayes EquationBackground當你在獲得一文檔時，會進行分詞，得到詞1、詞2……等詞，這些詞彙會有不同的重要性因此便不是像上述 條件概率 所提到的 在單個條件B下發生A1及A2事件的概率而是得到詞1、詞2……等詞的多個條件下，這些詞屬於單一類別的概率 例如：得到一篇文檔重要性較高的詞為 “雲計算”、”大數據”、”機器學習”，其為科技類別的概率可寫成如下： P(科技|雲計算, 大數據, 機器學習) 公式因此我們需要Bayes Equation來幫我們計算 P(C|W) = \\frac {P(W|C)P(C)} {P(W)} W為給定文檔的特徵值(不同詞的頻數統計) C為文檔類別 可以理解成 P(C|F1,F2,....) = \\frac {P(F1,F2,...|C) P(C)}{P(F1,F2,...)} $F$為不同的詞彙 $C$為類別 在比較不同類別時，分母的$P(W)$是可以忽略的 從上述的式子可以簡單的分為三部分來看 $P(C)$：每個文檔類別的概率 \\frac {某文檔類別數}{總文檔數量} $P(W|C)$：給定類別下特徵的概率(特徵：被預測文檔中所出現的詞) 計算方法： P(F1|C) = \\frac {Ni} {N} $Ni$為該$F1$詞在$C$類別所有文檔中出現的次數 $N$為所屬類別$C$下的文檔 所有詞出現的次數和 $P(F1,F2,…)$：預測文檔中每個詞的概率 Laplace Smoothing但在預測文檔中的詞彙 有可能出現在某一類別時概率為0的情況我們也並不能說此篇文檔與該類別完全沒有關係(不合理)而是應該說該篇預測文檔屬於該類別的概率較低要解決分類造成零概率的問題，可使用Laplace Smoothing如下所示 P(F1|C) = \\frac {Ni + \\alpha} {N + \\alpha m} $\\alpha$：為指定係數一般為1 $m$：為訓練文檔中統計出的特徵詞個數 naive_bayes.MultinomialNB(alpha=1.0) 為naive bayes的一種分類演算法 alpha：為Laplace Smoothing係數(並非超參數，對結果不會有影響) Example12345678910111213141516171819202122232425from sklearn.naive_bayes import MultinomialNBfrom sklearn.model_selection import train_test_splitfrom sklearn.feature_extraction.text import TfidfVectorizerfrom sklearn.datasets import fetch_20newsgroupsdef naive_bayes_test(): # 實例化數據集 news = fetch_20newsgroups(subset=\"all\") x_train, x_test, y_train, y_test = train_test_split(news.data,news.target,test_size=0.25) # 使用tf-idf方法找出代表性的詞彙，並標與權重 tf = TfidfVectorizer() x_train = tf.fit_transform(x_train) x_test = tf.transform(x_test) # 使用naive bayes進行分類 mlt = MultinomialNB(alpha=1.0) mlt.fit(x_train,y_train) y_predict = mlt.predict(x_test) print(\"預測的文章類別為：\\n\",y_predict) print(\"準確率：\",mlt.score(x_test,y_test))if __name__ == '__main__': naive_bayes_test() result123預測的文章類別為： [14 2 4 ... 10 14 14]準確率： 0.8582342954159593 tips 訓練集的誤差大(詞彙並沒有精準的反應文章主題)，預測效果也會低落 使用naive bayes算法不需進行調參 優缺點 優點 其模型發源於古典數學理論，有較穩定的分類效率 對缺失數據不太敏感，算法也比較簡單易懂，常用於文本分類 文章中缺少某部分句子影響文意，也不會造成太大影響 分類準確度高，速度快 缺點 由於使用了樣本屬性皆獨立的假設，所以如果樣本屬性有關聯時其效果不好 文章當中具代表性詞彙彼此之間是沒有關係的(假設) 由於是在訓練集當中進行統計詞頻，要是使用含有多樣性內容的文章做訓練集就會對預測造成干擾 挑選類別準確性或代表性較強的文章作為訓練集","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"演算法","slug":"演算法","permalink":"http://www.taroballz.com/tags/演算法/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"}]},{"title":"機器學習-演算法-K Neighbors Classifier","slug":"ML_KNeighbors_Classifier","date":"2018-07-07T20:10:00.000Z","updated":"2019-04-14T15:40:10.000Z","comments":true,"path":"2018/07/08/ML_KNeighbors_Classifier/","link":"","permalink":"http://www.taroballz.com/2018/07/08/ML_KNeighbors_Classifier/","excerpt":"Introduction 透過鄰居(離自己最近的點)來推斷所屬的類別 比較樣本之間的特徵遠近；相似的樣本，特徵之間的值應該都是相近的","text":"Introduction 透過鄰居(離自己最近的點)來推斷所屬的類別 比較樣本之間的特徵遠近；相似的樣本，特徵之間的值應該都是相近的 定義：如果一個樣本在特徵空間中 與K個最相似(即特徵空間中最鄰近)的樣本中的大多數屬於同一個類別，則該樣本也屬於這個類別 兩個樣本的距離可以通過如下公式計算，又稱歐式距離，比如a(a1,a2,a3), b(b1,b2,b3) distance = \\sqrt{(a1-b1)^2+(a2-b2)^2+(a3-b3)^2} 在計算兩個樣本的距離時，會因為某些特徵值本就屬於非常大的數值，在求其距離時會直接影響最後的結果 使用KNN算法時需將數據集做標準化或是歸一化處理(無量綱化) 使用標準化較為穩定 使用sklearn.neighbors.KNeighborsClassifier() 調用此演算法的API K Neighbors Classifier 於sklearn.neighbors.KNeighborsClassifier(n_neighbors=5, algorithm=&#39;auto&#39;)中 n_neighbors：為int類型，可選，預設值為5，選擇查詢的鄰居數 algorithm：有&#39;auto&#39;,&#39;ball_tree&#39;,&#39;kd_tree&#39;,&#39;brute&#39;幾種選擇，可選用於計算最近鄰居的算法，&#39;auto&#39;將嘗試根據傳遞給fit()方法的值來決定最合適的算法 metric：預設為&quot;minkowski&quot;(明可夫斯基距離) 其為歐式距離及曼哈頓距離兩種計算距離的延伸 其實例化KNN算法時參數p預設為2 p為2時所使用的是曼哈頓距離：兩點絕對值距離 p為1時所使用的是歐式距離 Example12345678910111213141516171819202122from sklearn.datasets import load_irisfrom sklearn.neighbors import KNeighborsClassifierfrom sklearn.model_selection import train_test_splitfrom sklearn.preprocessing import StandardScaler# 1)獲取數據iris_data = load_iris()# 2)數據集劃分X_train,X_test,y_train,y_test = train_test_split(iris_data.data,iris_data.target)# 3)特徵工程 --- 標準化transfer = StandardScaler()X_train = transfer.fit_transform(X_train)X_test = transfer.transform(X_test)# 4)KNN estimator流程KNN = KNeighborsClassifier()KNN.fit(X_train,y_train)KNN.predict(X_test)# 5)模型評估print(\"score = \",KNN.score(X_test,y_test)) result1score = 1.0 tips 須考慮k值須取多大 k值取太小容易受異常點的影響 k值如果取得太大容易受到鄰近點(類別)結果比例影響 訓練集的各類別樣本不均衡時造成誤判 因為每個點都需計算距離造成性能低落 優缺點 優點 簡單 易於理解及實現 無須估計參數(演算法所需參數)，無須訓練(不是迭代，而是單純的計算距離) 缺點 對測試樣本分類時計算量大 內存開銷大 必須指定k值，且k值選擇不當分類精確度不能保證 使用場景 小數據(幾千～幾萬樣本)","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"演算法","slug":"演算法","permalink":"http://www.taroballz.com/tags/演算法/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"}]},{"title":"機器學習-轉換器&估計器(Transformer & Estimator)","slug":"ML_Transformer_Estimator","date":"2018-07-07T09:00:00.000Z","updated":"2019-04-14T11:43:26.000Z","comments":true,"path":"2018/07/07/ML_Transformer_Estimator/","link":"","permalink":"http://www.taroballz.com/2018/07/07/ML_Transformer_Estimator/","excerpt":"轉換器(transformer) 從原數據集經過轉換器轉為預處理數據集 為一實現特徵工程的APIIntroduction之前所使用數據轉換的流程如下 實例化(實例化的就是一個轉換器類(transformer)) 調用fit_transsform(X)方法","text":"轉換器(transformer) 從原數據集經過轉換器轉為預處理數據集 為一實現特徵工程的APIIntroduction之前所使用數據轉換的流程如下 實例化(實例化的就是一個轉換器類(transformer)) 調用fit_transsform(X)方法 方法一般轉換器的方法較常使用的為： fit_transform() 將輸入的數據直接轉換返回 其作用等於fit()方法 + transform()方法 fit() 輸入數據，但不做轉換(轉換交給transform) 計算平均值、方差等值 歸一化時則統計 transform() 進行數據的轉換 轉換時須在輸入同樣的數據，才會根據fit()方法的結果進行轉換 也可以拿原數據fit()的結果，對其他數據進行轉換 Example I (fit_transform = fit + transform)12345678910111213from sklearn.preprocessing import StandardScalerdata = [[1,2,3], [4,5,6]]fit_transform_test = StandardScaler()DATA = fit_transform_test.fit_transform(data)print(\"fit_transform result:\\n\",DATA)fit_then_transform = StandardScaler()fit_then_transform.fit(data)DATA = fit_then_transform.transform(data)print(\"fit_then_transform result:\\n\",DATA) result123456fit_transform result: [[-1. -1. -1.] [ 1. 1. 1.]]fit_then_transform result: [[-1. -1. -1.] [ 1. 1. 1.]] 可以看到其結果是一樣的 Example II (fit的結果對其他數據transform)123456789101112from sklearn.preprocessing import StandardScalerdata = [[1,2,3], [4,5,6]]data2 = [[11,12,13], [14,15,16]]fit_then_transform = StandardScaler()fit_then_transform.fit(data)DATA = fit_then_transform.transform(data2)print(\"fit_then_transform result:\\n\",DATA) result123456fit_transform result: [[-1. -1. -1.] [ 1. 1. 1.]]fit_then_transform result: [[5.66666667 5.66666667 5.66666667] [7.66666667 7.66666667 7.66666667]] 拿對第一組數據(data)fit的結果對第二組數據(data2)transform tips 對同組數據進行轉換可直接調用fit_transform() 若還有數據要使用fit_transform()結果進行轉換，直接調用transform()對新數據進行轉換 估計器(estimator)在sklearn中，估計器(estimator)是一類實現了演算法的API Introduction演算法是機器學習的核心，數據和計算是基礎 用於分類的演算法： sklearn.neighbors KNN演算法 sklearn.naive_bayes sklearn.linear_model.LogisticRegression 邏輯回歸 sklearn.tree 決策樹與隨機森林 用於回歸的演算法： sklearn.linear_model.LinearRegression 線性回歸 sklearn.linear_model.Ridge 流程 將轉換器處理後的數據集分為訓練集及測試集 實例化estimator 調用fit()方法，並傳入參數及訓練集 estimator.fit(X_train,y_train) 調用完畢後，生成模型 進行測試 調用predict()方法，返回預測的目標值 調用score()方法，返回預測的準確率","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"},{"name":"轉換器(Transformer)","slug":"轉換器-Transformer","permalink":"http://www.taroballz.com/tags/轉換器-Transformer/"},{"name":"估計器(Estimator)","slug":"估計器-Estimator","permalink":"http://www.taroballz.com/tags/估計器-Estimator/"}]},{"title":"機器學習-數據集(dataset)","slug":"ML_SklearDataSet","date":"2018-07-06T15:22:00.000Z","updated":"2019-04-03T17:38:42.000Z","comments":true,"path":"2018/07/06/ML_SklearDataSet/","link":"","permalink":"http://www.taroballz.com/2018/07/06/ML_SklearDataSet/","excerpt":"Introduction在對model進行訓練及評估時不能使用同樣的數據集即便是同一數據集也需劃分成訓練集與測試集 訓練集與測試集的比例為75%：25% （仍可隨自己的需求自由劃分） 訓練集用於訓練構建模型 測試數據則用於模型檢驗使用，用於評估模型是否有效","text":"Introduction在對model進行訓練及評估時不能使用同樣的數據集即便是同一數據集也需劃分成訓練集與測試集 訓練集與測試集的比例為75%：25% （仍可隨自己的需求自由劃分） 訓練集用於訓練構建模型 測試數據則用於模型檢驗使用，用於評估模型是否有效 學習階段可用的數據集：sklearn, kaggle, UCI UCI:http://archive.ics.uci.edu/ml/index.php sklearn數據集於sklearn.datasets中 sklearn.datasets加載此模塊獲取幾個流行的數據集 datasets.load_*() 將*替換成數據集的名字 獲取小規模數據集，數據包含在datasets裡 分類數據集 datasets.load_iris() 加載並返回鳶尾花數據集 datasets.load_digits() 回歸數據集 datasets.load_boston()：波士頓房價數據集 datasets.load_diabetes()：糖尿病數據集 datasets.fetch_*(data_home=None) 將*替換成數據集的名字 獲取大規模數據集，需要從網路上下載 data_home參數表示數據集下載的目錄，預設是 ~/scikit_leaern_data/ datasets.fetch_20newgroups(data_home=None,subset=’train’) 為一用於分類的大型數據集 為一新聞數據集(文章)，共有20個類別 subset: ‘train’ , ‘test’ , ‘all’ 可選 選擇要加載的數據集 一般都選擇’all’在使用train_test_split劃分 datasets.clear_data_home(data_home=None)清除目錄下的所有數據 數據集返回的類型load* 和 fetch 返回的數據類型為*datasets.base.Bunch(字典格式) 可用字典的方式去查看屬性：dict[&quot;key&quot;] --&gt; value 可用類屬性的方式(.)查看：class.property --&gt; value 以下為數據集可調用的屬性： data: 返回特徵值array；是[n_samples x nfeatures]的二維numpy.ndarray陣列 target: 返回目標值array；是n_samples的一維numpy.ndarray陣列 DESCR: 數據描述 feature_names: 特徵名(新聞數據、手寫數字、回歸數據集沒有) target_names: 目標名 數據集分割 將數據集畫分成訓練集及測試集 訓練集：用於訓練，構建模型 測試集：在模型檢驗時使用，用於評估模型是否有效 使用sklearn.model_selection.train_test_split train_test_split( *arrays **options)返回的為亂序的結果 X : 數據集的特徵值array y : 數據集的目標值array test_size : 測試集的大小，一般為float類型，表示百分比 random_state : 隨機數Seed，不同的Seed會造成不同的隨機採樣結果。相同Seed採樣結果相同 return ： 訓練集特徵值(X_train)、測試集特徵值(X_test)、訓練集目標值(y_train)、測試集目標值(y_test) Example12345678from sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitiris_data = load_iris()data = iris_data.datatarget = iris_data.targetX_train, X_test, y_train, y_test = train_test_split(data, target, test_size=0.25)","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"},{"name":"數據集(dataset)","slug":"數據集-dataset","permalink":"http://www.taroballz.com/tags/數據集-dataset/"}]},{"title":"機器學習-特徵工程-降維","slug":"ML_DecreaseFeature","date":"2018-07-05T16:10:00.000Z","updated":"2019-06-21T17:18:25.000Z","comments":true,"path":"2018/07/06/ML_DecreaseFeature/","link":"","permalink":"http://www.taroballz.com/2018/07/06/ML_DecreaseFeature/","excerpt":"Introduction降維不是將array的維度減少(3D陣列-&gt;2D陣列)，而使指將特徵的數量減少 有些特徵與目標值較無關係，會選擇將此特徵剃除，稱之為降維 拋棄掉對模型帶來負面影響的特徵 得到一組＂特徵間相互獨立(不相關)＂主變量的過程","text":"Introduction降維不是將array的維度減少(3D陣列-&gt;2D陣列)，而使指將特徵的數量減少 有些特徵與目標值較無關係，會選擇將此特徵剃除，稱之為降維 拋棄掉對模型帶來負面影響的特徵 得到一組＂特徵間相互獨立(不相關)＂主變量的過程 數據降維通常有兩種方式： 特徵選擇 主成分分析 特徵選擇(feature_selection)從所有的特徵中，選擇出有意義的或對模型有幫助的特徵，通常須人為的挑選，同時也必須了解相關業務知識 避免必須將所有特徵都導入模型進行訓練的窘境 重要！！：必須與數據提供者討論 選擇後的特徵維數肯定比選擇前小，特徵在選擇和選擇後可以改變值 冗餘特徵：部份特徵相關度高，容易消耗計算性能 噪聲特徵(不需要的特徵)：對預測結果造成影響 主要方法 Filter(過濾式)：VarianceThreshold 透過特徵本身的方差來篩選特徵 主要探究特徵本身特點、特徵和目標值之間關聯 方差選擇法：低方差特徵過濾 相關係數：得知特徵與特徵之間的相關程度 Embedded(嵌入式)：算法自動選擇特徵(特徵與目標之間的關聯) 正則化：L1、L2 決策樹：信息熵、信息增益 深度學習：巻積等 Wrapper(包裹式) -&gt; 較不常使用 VarianceThreshold(方差門檻) 將方差較小的特徵刪除：樣本間特徵集中(相似)，較不易影響最後結果 特徵方差小：某個特徵大多樣本的值比較相近；表示此特徵在此數據集上幾乎沒有差異 此特徵對於區分樣本沒有貢獻(可能須刪除) 優先消除方差為0的特徵 特徵方差大：某個特徵大多樣本的值都有差別 使用sklearn.feature_selection.VarianceThreshold VarianceThreshold(threshold = 0.0)刪除所有低方差的特徵 threshold:指定方差小於多少則刪除特徵，預設為0 fit_transform(X) X: numpy array格式的數據[n_sample, n_features] 返回值： 訓練集差異低於threshold的特徵將被刪除 預設值是保留所有非零方差的特徵，即刪除所有樣本中具有相同值的特徵 流程 初始化VarianceThreshold 指定方差的threshold 調用fit_transform Example12345678910111213141516from sklearn.feature_selection import VarianceThresholdUnFS_data = [[90,2,1000,0.8,1], [120,5,2500,0.75,1], [45,10,1800,0.38,1], [45, 10, 1800, 0.38,1], [30, 7, 3500, 0.11,1], [75, 8, 2700, 0.29,1],]def featureSelect_VT(): VT = VarianceThreshold(threshold=0.0) FS_data = VT.fit_transform(UnFS_data) print(FS_data)if __name__ == '__main__': featureSelect_VT() 根據自己的需求設置threshold之值，默認為0 特徵篩選後123456[[9.0e+01 2.0e+00 1.0e+03 8.0e-01] [1.2e+02 5.0e+00 2.5e+03 7.5e-01] [4.5e+01 1.0e+01 1.8e+03 3.8e-01] [4.5e+01 1.0e+01 1.8e+03 3.8e-01] [3.0e+01 7.0e+00 3.5e+03 1.1e-01] [7.5e+01 8.0e+00 2.7e+03 2.9e-01]] tips 如果一開始已經明確知道要多少特徵，方差(VarianceThreshold)也可以一步到位進行處理 希望留下一半特徵： 找到全部特徵列的方差，將各特徵列的方差其中位數作為threshold參數的值即可 .var()可查詢各列特徵的方差 利用np.median()尋找中位數 特徵為二分類當特徵為二分類時，特徵的取值就是伯努利分布(取值非0即1) 其分布的方差可以計算： Var[X] = p(1-p) 假設 $p$ = 0.8 ，表示二分類特徵中某種分類佔到80%以上時就刪除特徵 12x_bvar = VarianceThreshold(.8*(1-.8)).fit_transform(Binary_UnFS_data)x_bvar.shape #查看刪除結果 結論 方差過濾法適用於需要遍歷特徵或升維的演算法，包括KNN，SVM等等 會大幅度的減少計算成本 對隨機森林較無效果 隨機森林是隨機選取特徵 主要目的：在維持演算法表現的前提下，幫助算法降低計算成本 其他特徵選擇方法 神經網路 相關係數降維的目的在於得到一組＂特徵間相互獨立(不相關)＂主變量的過程，因此得知特徵之間的相關性是極重要的 相關係數可以知道特徵之間的相關程度 較常用皮爾遜相關係數(Pearson Correlation Coefficient) 反應變量之間相關關係密切程度的統計指標 r = \\frac{n\\sum xy-\\sum x \\sum y }{\\sqrt{n\\sum x^2 - (\\sum x )^2} \\sqrt{n\\sum y^2 - (\\sum y )^2}}特點相關係數(r)值介於-1 至 1 之間，即-1 ≤ r ≤ 1，其性質如下： 當 r &gt; 0 時，表示兩變量正相關；r &lt; 0 時，兩變量為負相關 當 |r| = 1 時，表示兩變量為完全相關； r = 0 時，表示兩變量間無相關關係 當 0 &lt; |r| &lt; 1 時，表示兩變量存在一定程度相關，且|r|越接近1，兩變量間線性關係越密切；且|r|越接近0，兩變量間線性相關越弱 一般分為三個等級： |r| &lt; 0.4 為低度相關 0.4 ≤ |r| &lt; 0.7 為顯著性相關 0.7 ≤ |r| &lt; 1 為高度線性相關 Example計算年廣告費投入與月均銷售額之間的關係 有10個樣本數 最終計算的結果為0.9942 API其位於scipy.stats中的pearsonr函數，其有兩個參數 x : 特徵x數據，為array_like形式 y : 特徵y數據，為array_like形式 返回一元組，第一個值為r值 123456789101112131415161718from scipy.stats import pearsonrdata = [[12.5,21.2], [15.3,23.9], [23.2,32.9], [26.4,34.1], [33.5,42.5], [34.4,43.2], [39.4,49.0], [45.2,52.8], [55.4,59.4], [60.9,63.5]]X = [x[0] for x in data]Y = [x[1] for x in data]r_value = pearsonr(X,Y)print(\"Relation Coefficient : %s\"%r_value[0]) Result1Relation Coefficient : 0.9941983762371883 tips 特徵與特徵相關性很高的情況下，可在進行其處理 選取其中一個特徵作為代表，刪除另一個特徵 按一定權重求和作為新特徵 X特徵50% + Y特徵50% 主成分分析 主成分分析(PCA)定義：高維度數據化為低維度數據的過程，在此過程中可能會捨棄原有數據，創造新的變量；是一種分析、簡化數據集的技術。雖然主要用於減少維度，但仍希望信息盡可能的表示完整，不會損耗太多目的：使數據維數壓縮，盡可能降低原數據的維度(複雜度)，但損失最少量信息作用：可以削減回歸分析或者聚類分析中特徵的數量應用場景：當特徵數量達到上百時，才會考慮用PCA去簡化數據 使用sklearn.decomposition import PCA 高維度數據的問題 特徵之間容易出現一些相關的特徵 重要參數n_components=None降維後所需要的維度(即降維後需要保留的特徵數量) 為一超參數 可以有三種形式： 浮點數形式(介於0-1)：保留多少百分比的信息(例如0.9為90%)，人為可控參數，建議90%-95% 當使用n_components為浮點數形式時，必須要指定svd_solver參數為&quot;full&quot;，否則效果會不佳 PCA(n_components=0.97,svd_solver=&quot;full&quot;) 整數形式：減少到多少特徵數量(一般較少使用) 其介於0 - min(X.shape) 可使用這種輸入方式畫出 累計可解釋方差貢獻曲線，以此選擇最好的n_components整數取值 降維後的特徵個數 為 橫坐標；降維後新特徵矩陣捕捉到的累加可解釋方差貢獻率 為 縱座標 可搭配numpy.cumsum()方法一起使用 numpy.cumsum(pca_lin_object.explained_variance_ratio_) &quot;mle&quot;:使用 最大似然估計(maximum likehood estimation) 自選超參數的方法 計算量非常大，謹慎使用 要是其不填任何值，則為min(X.shape)個特徵 svd_solver奇異值分解器；共有四種不同的模式 sklearn將降維流程拆分成兩部份： 計算特徵空間$V$ 由奇異值分解完成 利用SVD的性質減少計算量，但是信息量的評估指標仍為PCA所使用的方差 映射數據 及 求解新特徵矩陣 由主成分分析完成 雖是PCA降維方法(使用CPCA本身特徵值分解)，但是可以透過使用奇異值分解來減少計算量 預設為&quot;auto&quot;：基於X.shape和n_components的預設策略來選擇分解器 如果輸入的數據大於$500\\times500$；且欲提取的特徵數**小於數據最小維度(min(X.shape))的80%，啟用效率更高的&quot;randomized&quot;方法 否則精確完整的SVD($U{(m,m)},\\sum{m,n},V^T_{(n,n)}$) 完整三個矩陣將被計算(同&quot;full&quot;模式) &quot;full&quot;：從scipy.linalg.svd中調用標準的LAPACK分解器來生成精確完整的SVD 適合數據量比較適中，計算時間充足的情況使用 &quot;arpack&quot;：從scipy.sparse.linalg.svds調用標準的ARPACK分解器來運行截斷奇異值分解(SVD truncated) 分解時救將特徵數量降到n_components中輸入的值 分解時同時降維 可以加快運算速度 適合特徵矩陣很大的時候 一般用於特徵矩陣為稀疏矩陣的情況 過程包含一定的隨機性 &quot;randomized&quot;：生成多個隨機向量，一一檢測隨機向量中是否有符合分解需求的，如果有，則保留此隨機向量 基於保留的隨機向量方向構建向量空間 比full模式快，且能保證運行效果 適合特徵矩陣巨大，計算量龐大的情況 random_state此參數只在svd_solver為&quot;arpack&quot; 或 &quot;randomized&quot;時生效，可控制兩個SVD模式中的隨機模式 方法fit_transform(X)X: numpy array格式的數據[n_sample, n_features]返回值： 轉換後指定維度的array inverse_transform inverse_transform後並非原圖片信息 PCA降維過程中刪除掉的信息無法復原 並不是完全可逆 應用：可在不完全恢復原始數據的情況下，將降維後的數據返回原本的維度，達到降噪效果 保證維度，但去掉方差很小特徵所帶的信息 流程 初始化PCA轉換器 指定減少後的維度(整數) 或 保留多少%信息(浮點數) 調用fit_transform Example1234567891011121314151617from sklearn.decomposition import PCAUnDD_data = [[90,2,1000,0.8,1], [120,5,2500,0.75,1], [45,10,1800,0.38,1], [45, 10, 1800, 0.38,1], [30, 7, 3500, 0.11,1], [75, 8, 2700, 0.29,1],]# 主成分分析進行特徵降維def DecreaseDimension_PCA(): pca = PCA(n_components=0.95) DD_data = pca.fit_transform(UnDD_data) print(DD_data)if __name__ == '__main__': DecreaseDimension_PCA() 降維結果123456[[-1216.836117 ] [ 282.78600381] [ -416.41490377] [ -416.41490377] [ 1283.6463807 ] [ 483.23354004]] 重要屬性explainedvariance查看降維後每個新特徵所帶的信息量大小(可解釋性方差的大小) pca實例.explained_variance_ 第一個特徵的信息量(方差)通常最大(數據會被壓縮在盡量少的特徵上) 因此會盡量壓縮在第一個特徵 後面特徵所帶的信息量會越來越少 explainedvariance_ratio查看降維後每個新特徵向量所占的信息量占原始數據總信息量的百分比 又稱可解釋方差貢獻率 pca實例.explained_variance_ratio_ pca實例.explained_variance_ratio_.sum() 其代表矩陣降維後的特徵向量貢獻率加和，為原始數據信息量的百分比 components_查看降維過後的新特徵空間$V(k,n)$ $V(k,n)$：是要將原始數據進行映射的那些 新特徵向量 組成的矩陣 當$V(k,n)$是數字時，無法判斷$V(k,n)$和原有的特徵的聯繫 但是如果原特徵矩陣為圖像；且$V(k,n)$此空間矩陣可以被可視化 可通過原圖及空間矩陣兩張圖比較，知道新特徵空間$V(k,n)$從原始數據中提取什麼信息 運用於人臉識別 $k$：n_components 輸入的整數 $n$：原特徵矩陣的feature數目 pca實例.components_ pca實例.somponents_.shape tips 通常會對擁有高維度的數據進行降維處理 通常在能進行PCA降維的情況下，不會進行特徵選擇 無法使用PCA降維的情況下才會做特徵選擇","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"},{"name":"特徵預處理","slug":"特徵預處理","permalink":"http://www.taroballz.com/tags/特徵預處理/"},{"name":"特徵工程","slug":"特徵工程","permalink":"http://www.taroballz.com/tags/特徵工程/"},{"name":"降維","slug":"降維","permalink":"http://www.taroballz.com/tags/降維/"}]},{"title":"機器學習-特徵工程-特徵預處理","slug":"ML_FeaturePreProcessing","date":"2018-07-05T10:34:00.000Z","updated":"2019-06-03T16:55:08.000Z","comments":true,"path":"2018/07/05/ML_FeaturePreProcessing/","link":"","permalink":"http://www.taroballz.com/2018/07/05/ML_FeaturePreProcessing/","excerpt":"Introduction 特徵預處理通常是對數據進行處理 通過特定的統計方法(數學方法) 將數據轉換成演算法要求的數據 特徵預處理 數值型數據：採用標準縮放 分為歸一化(normalization) 及 標準化(standardization) 兩種,通常也要同時處理缺失值類別型的數據：one-hot編碼時間類型數據：對時間進行切分 使用sklearn自帶的特徵預處理API進行處理","text":"Introduction 特徵預處理通常是對數據進行處理 通過特定的統計方法(數學方法) 將數據轉換成演算法要求的數據 特徵預處理 數值型數據：採用標準縮放 分為歸一化(normalization) 及 標準化(standardization) 兩種,通常也要同時處理缺失值類別型的數據：one-hot編碼時間類型數據：對時間進行切分 使用sklearn自帶的特徵預處理API進行處理 數據無量綱化 不同規格的數據轉換到同一規格的需求 例如：希望所有數據服從標準正態分佈 不同分佈的數據轉換到某個特定分佈的需求 例如：希望所有值位於1-0之間以上兩種需求統稱為無量綱化 效果 梯度和矩陣為核心模型：邏輯回歸，SVM，神經網路等，無量綱化可加快求解速度 距離類模型：KNN，K-means聚類等，無量綱化可提升模型經度 決策樹和樹的集成演算法們，不需無量綱化 sklearn特徵預處理所有特徵預處理的方法皆收錄在sklearn.preprocessing 歸一化(normalize) 通常對原始數據進行變換把數據映射至預設為[0,1]之間 應用場景：在數萬筆數據中某些特徵都是同等重要時，就需將這幾種特徵歸一化處理，不會使單一特徵完全的影響最終結果 公式： X' = \\frac {x-mean} {max-min} X\" = X'\\times (mx-mi)+mi $max$為一系列的最大值；$min$為一系列的最小值 $X^”$為最終結果 $mx$,$mi$分別為指定區間的預設值,$mx$為1,$mi$為0 使用sklearn.preprocessing.MinMaxScaler MinMaxScalar(feature_range=(0,1)…) 每個特徵縮放到給定的範圍內(預設[0,1]) 可自己更改normalize的範圍(feature_range(最小值，最大值)) fit_transform(X) X: numpy array格式的數據[n_samples, n_features] 返回值：轉換後的同shape的array inverse_transform(X) X: numpy array格式的數據（歸一化後的數據） 返回值： 歸一化前的數據 流程 實例化MinMaxScalar 通過fit_transform轉換 Example123456789101112131415161718from sklearn.preprocessing import MinMaxScalerdata = [[90,2,1000,0.8],[120,5,2500,0.75],[45,10,1800,0.38]]#Normalizedef MMScale(): # 實例化 MM = MinMaxScaler() # 調用fit_transform scale_data = MM.fit_transform(data) print(scale_data)if __name__ == '__main__': MMScale() 返回normalize的結果123[[0.6 0. 0. 1. ] [1. 0.375 1. 0.88095238] [0. 1. 0.53333333 0. ]] tips Normalize方法對於異常點的處理效果不好 異常點可能會改變最大值與最小值造成結果整體大幅的改動，因此穩定性較差 較適合傳統精確小數據的場景 當X中特徵數量非常多時候，fit會報錯並表示數據量太大無法計算 使用partial_fit(X)方法作為訓練的接口 標準化(standardization) 標準化相對歸一化較常見也較常使用 又稱 Z-score normalization 數據x按均值($mean$)中心化後，再按標準差($\\sigma$)縮放平均值不容易受到異常點的影響 特點：通過對原始數據進行變換把數據變換到均值為0，標準差為1的範圍內 公式： var = \\frac {x-mean} {\\sigma} $\\sigma$ 為標準差 $\\sigma = \\sqrt{var}$ 使用sklearn.preprocessing.StandardScaler 方差 var = \\frac {(X1-mean)^2 + (X2-mean)^2 + ...} {n(每個特徵樣本數)} 方差小代表數據叫集中；反之則數據比較離散 如果出現異常點，由於原本就具有一定數據量，少量的異常點對於平均值的影響並不大，使得方差改變較小 StandardScaler(…) 處理之後每列的數據都聚集在$mean$為0附近且$\\sigma$標準差為1 fit(X)生成均值及方差 X: numpy array格式的數據[n_samples, n_features] fit_transform(X) X: numpy array格式的數據[n_samples, n_features] 返回值：轉換後同shape的array mean_ 查看原始數據中每列特特徵的平均值 var_ 查看原始數據中每列特徵的方差 流程 實例化StandardScaler 通過fit_transform轉換 Example12345678910111213141516from sklearn.preprocessing import StandardScalerdata = [[90,2,1000,0.8],[120,5,2500,0.75],[45,10,1800,0.38]]def StdScale(): # 實例化 SS = StandardScaler() # 調用fit_transform scale_data = SS.fit_transform(data) print(\"Result: \\n\",scale_data) print(\"Mean: \\n\",SS.mean_)if __name__ == '__main__': StdScale() 返回標準化後的矩陣123456Result: [[ 0.16222142 -1.1111678 -1.25103507 0.83635719] [ 1.13554995 -0.20203051 1.19664225 0.56943468] [-1.29777137 1.31319831 0.05439283 -1.40579187]]Mean: [8.50000000e+01 5.66666667e+00 1.76666667e+03 6.43333333e-01] tips在以有樣本足夠多的情況下比較穩定，適合現代嘈雜大數據的場景 缺失值處理缺失值只有兩種方法 刪除 如果每列或者行數據缺失值達到一定的比例，建議放棄整行或整列 如果本身數據量少，較不適合直接刪除 插補 可以通過每行或者每列的平均值或者中位數來填充(一般都是使用列填補) 使用sklearn.preprocessing.Imputer Imputer(missing_values=’Nan’,strategy=’mean’,axis=0)完成缺失值插補 missing_values: 對什麼進行填補，預設為Nan值 strategy: 填補策略，預設使用平均值 axis: 針對行或列進行填補，預設使用列 fit_transform(X) X: numpy array格式的數據[n_samples, n_features] 返回值：轉換後同shape的array 缺失值類型應為np.nan類型，才能填補 流程 初始化Imputer 指定missing_values 指定填補策略(strategy) 指定針對行或列填補 注意：缺失值也可以是別的指定要替換的值，不一定為Nan 調用fit_transform Example12345678910111213from sklearn.preprocessing import Imputerimport numpy as npHasNanData = [[np.nan,2,1000,0.8],[120,5,np.nan,0.75],[45,10,1800,0.38]]# 缺失值處理def fill_nan(): fill = Imputer() Data = fill.fit_transform(HasNanData) print(Data)if __name__ == '__main__': fill_nan() 填補結果123[[8.25e+01 2.00e+00 1.00e+03 8.00e-01] [1.20e+02 5.00e+00 1.40e+03 7.50e-01] [4.50e+01 1.00e+01 1.80e+03 3.80e-01]] tips np.nan numpy的陣列中可以使用np.nan/np.Nan來代替缺失值 np.nan屬於float類型 如果是文件中的缺失值，可以替換成nan，通過np.nan轉化為float型的陣列即可","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"},{"name":"特徵預處理","slug":"特徵預處理","permalink":"http://www.taroballz.com/tags/特徵預處理/"},{"name":"特徵工程","slug":"特徵工程","permalink":"http://www.taroballz.com/tags/特徵工程/"},{"name":"缺失值","slug":"缺失值","permalink":"http://www.taroballz.com/tags/缺失值/"}]},{"title":"機器學習-特徵工程-字典特徵抽取(feature extraction)","slug":"ML_DictFeatureExtraction","date":"2018-07-04T16:00:00.000Z","updated":"2019-04-07T05:28:24.000Z","comments":true,"path":"2018/07/05/ML_DictFeatureExtraction/","link":"","permalink":"http://www.taroballz.com/2018/07/05/ML_DictFeatureExtraction/","excerpt":"機器學習機器學習是從數據(data)中自動分析獲得模型(model)，並利用規律對未知的數據進行預測(predict) 數據和特徵決定了機器學習的上限，而模型和算法只是逼近這個上限而已","text":"機器學習機器學習是從數據(data)中自動分析獲得模型(model)，並利用規律對未知的數據進行預測(predict) 數據和特徵決定了機器學習的上限，而模型和算法只是逼近這個上限而已 one-hot 編碼 不讓不同的特徵(皮膚顏色：黃、黑、白, 性別：男、女)之間有優先級之分 把不同類別的特徵轉換為以下形式，利於進行分析 Sample\\皮膚顏色 黑 黃 白 1 0 1 0 2 1 0 0 3 0 0 1 特徵抽取/提取(feature extraction)特徵抽取是對任意數據(文本or圖像)等數據進行特徵值化便于機器學習 特徵值化是為了計算機更好的去理解數據 sklearn特徵抽取API 使用sklearn.feature_extraction 字典特徵抽取對字典數據進行特徵值化 把字典中一些類別的數據，分別轉換成特徵 應用場景： 數據集中有很多的類別特徵(性別，人員乘坐的船艙…等) 將數據集的特徵轉換成字典類型 DictVectorizer轉換 本身拿到的數據就是字典類型即直接使用字典特徵抽取 使用sklearn.feature_extraction.DictVectorizer DictVectorizer(sparse=True,…)實例化了一個字典向量化的實例(轉換器類) sparse矩陣(節約內存，方便讀取處理) sparse=False時則返回一般矩陣(ndarray type) fit_transform(X)使用此方法就能將一個字典數據化 X: 字典或者包含字典的迭代器 返回值: 返回sparse矩陣 inverse_transform(X) X: array陣列或者sparse矩陣 返回值: 轉換之前的數據格式(將陣列轉回原本的字典，形式會改變) 1234[&#123;&apos;city=Taipei&apos;: 1.0, &apos;temperature&apos;: 35.0&#125;, &#123;&apos;city=Tainan&apos;: 1.0, &apos;temperature&apos;: 32.0&#125;, &#123;&apos;city=Nantou&apos;: 1.0, &apos;temperature&apos;: 30.0&#125;, &#123;&apos;city=Chiayi&apos;: 1.0, &apos;temperature&apos;: 31.0&#125;] get_feature_names() 返回類別的名稱 12345[&apos;city=Chiayi&apos;, &apos;city=Nantou&apos;, &apos;city=Tainan&apos;, &apos;city=Taipei&apos;, &apos;temperature&apos;] transform(X) 按照原先的標準轉換 流程 實例化類DictVectorizer 調用fit_transform方法輸入數據並轉換 注意返回格式為sparse矩陣 Example12345678910111213141516171819202122from sklearn.feature_extraction import DictVectorizerdictData = [ &#123;\"city\":\"Taipei\",\"temperature\":35&#125;, &#123;\"city\":\"Tainan\",\"temperature\":32&#125;, &#123;\"city\":\"Nantou\",\"temperature\":30&#125;, &#123;\"city\":\"Chiayi\",\"temperature\":31&#125;,]#字典數據抽取def dictvec(): # 實例化 字典轉換器類 dict = DictVectorizer() # 調用fit_transform trans_data = dict.fit_transform(dictData) print(trans_data)if __name__ == '__main__': dictvec() sparse = True(預設)結果返回稀疏(sparse)矩陣12345678(0, 3) 1.0(0, 4) 35.0(1, 2) 1.0(1, 4) 32.0(2, 1) 1.0(2, 4) 30.0(3, 0) 1.0(3, 4) 31.0 sparse矩陣較節約內存，提高加載數據的效率 前面的元組為第幾行，第幾列，後面的數字為值 sparse = FalseDictVectorizer(sparse=False)，返回ndarray(一般矩陣)1234[[ 0. 0. 0. 1. 35.] [ 0. 0. 1. 0. 32.] [ 0. 1. 0. 0. 30.] [ 1. 0. 0. 0. 31.]]","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"},{"name":"特徵工程","slug":"特徵工程","permalink":"http://www.taroballz.com/tags/特徵工程/"},{"name":"特徵抽取(feature extraction)","slug":"特徵抽取-feature-extraction","permalink":"http://www.taroballz.com/tags/特徵抽取-feature-extraction/"}]},{"title":"機器學習-特徵工程-文本特徵抽取","slug":"ML_TextFeatureExtraction","date":"2018-07-04T16:00:00.000Z","updated":"2019-04-07T06:47:32.000Z","comments":true,"path":"2018/07/05/ML_TextFeatureExtraction/","link":"","permalink":"http://www.taroballz.com/2018/07/05/ML_TextFeatureExtraction/","excerpt":"文本特徵抽取 對文本數據進行特徵值化 把單詞出現的次數作為特徵對文本進行特徵值化 使用sklearn.feature_extraction.text.CountVectorizer 應用場景：文本分類、情感分析","text":"文本特徵抽取 對文本數據進行特徵值化 把單詞出現的次數作為特徵對文本進行特徵值化 使用sklearn.feature_extraction.text.CountVectorizer 應用場景：文本分類、情感分析 CountVectorizer(stop_words=[]) 統計每個樣本特徵詞出現的個數 返回詞頻矩陣 可統計中文(但以空格作為分詞的依據)，但不支持單個中文字 需自己將詞跟詞之間以空格分開 進行自動分詞處理(jieba) stop_words：停用詞 對文本分類沒有好處的單詞列表 stop_words = [is,am,are,to] 可google停用詞表 fit_transform(X)X: 文本或者包含文本字符串的可迭代對象返回值： 返回sparse矩陣 使用效果： 統計所有文本中所有的詞，重複的只看作一次(單個字母不統計 [沒有分類依據]) 對每篇文章，在此的列表裡進行統計每個詞的出現次數並返回矩陣 get_feature_names()返回值: 為一列表存放文章所出現的單詞 12345[&apos;an&apos;, &apos;apple&apos;, &apos;away&apos;, &apos;bird&apos;, &apos;bridge&apos;, &apos;bush&apos;, &apos;come&apos;, &apos;cross&apos;, &apos;day&apos;, &apos;doctor&apos;, &apos;hand&apos;, &apos;in&apos;, &apos;is&apos;, &apos;it&apos;, &apos;keeps&apos;, &apos;that&apos;, &apos;the&apos;, &apos;to&apos;, &apos;two&apos;, &apos;we&apos;, &apos;when&apos;, &apos;worth&apos;] inverse_transform(X)X: array陣列或者sparse矩陣返回值： 轉換之前數據格式 流程 實例化類CountVectorizer 調用fit_transform方法輸入數據並轉換 注意返回格式,利用toarray()進行sparse矩陣轉換array陣列 Example123456789101112131415161718192021from sklearn.feature_extraction.text import CountVectorizertextData = [ \"an apple a day keeps the doctor away\", \"a bird in the hand is worth two the bush\", \"cross that bridge when we come to it\"]#對文本進行特徵值化def countvec(): # 實例化 cv = CountVectorizer() # 調用fit_transform cv_data = cv.fit_transform(textData) print(cv_data)if __name__ == '__main__': countvec() 返回sparse矩陣12345678 (0, 2) 1 (0, 9) 1 (0, 16) 1 (0, 14) 1 (0, 8) 1......... 得到一般矩陣 須調用sparse矩陣的toarray()方法 —-&gt; cv_data.toarray()123[[1 1 1 0 0 0 0 0 1 1 0 0 0 0 1 0 1 0 0 0 0 0] [0 0 0 1 0 1 0 0 0 0 1 1 1 0 0 0 2 0 1 0 0 1] [0 0 0 0 1 0 1 1 0 0 0 0 0 1 0 1 0 1 0 1 1 0]] 中文分詞處理(jieba)須對中文文本進行特徵抽取的前處理 下載1pip3 install jieba 使用12import jiebanew_text = jieba.cut(\"我熱愛機器學習\") tips返回值：詞語產生器(generator) 用list()方法得到分詞的結果 new_text = list(new_text) 再用join()方法拼出整句 new_text = &quot; &quot;.join(new_text) tf-idf分析在進行文章分類時，不管是那種類型的文章常常會出現一些比較中性的詞語，例如：所以 就是 我們 明天…等當這些中性詞語頻繁出現在幾篇文章時，我們不能說文章的性質是一樣的因此要解決此問題會需要用到tf-idf分析(term frequency–inverse document frequency) TF-IDF的主要思想：如果某個詞或短語在一篇文章中出現的概率較高，並且在其他文章中很少出現，則認為此詞或者短語具有很好的類別區分能力，適合用來分類 作用用以評估一字詞對於一個文件集或一個語料庫中的其中一份文件的重要程度其所做的事情如下 統計每個詞出現的次數(詞頻[tf], term frequency) 逆文檔頻率[inverse document frequency] \\log(總文檔數量/該詞出現的文檔數) 是一個詞語普遍重要性的度量 其值越小代表此單詞越接近中性 計算詞重要性程度：tf x idf (其值越高表示 單詞代表此文章分類的意義越大) 文本特徵抽取-Tfidf 應用場景：自然語言處理、情感分析等 使用sklearn.feature_extraction.text.TfidfVectorizer TfidfVectorizer(stop_words=None,…) 返回詞的重要性權重矩陣 fit_transform(X) X: 文本或者包含文本字符串的可迭代物件 返回值： 返回sparse矩陣 inverse_transform(X) X: array數組或者sparse矩陣 返回值： 轉換之前的數據格式 get_feature_names() 返回值：單詞列表 Example1234567891011121314151617181920212223242526272829import jiebafrom sklearn.feature_extraction.text import TfidfVectorizerText_Data = [\"ㄧ個人的快樂， 不是因為他擁有的多，而是因為他計較得少。\", \"人的心地是一畦田，土地沒有播下好種子，也長不出好的果實。\", \"人生的煩惱，是不分貧富貴賤的，透過煩惱轉成智慧，這個煩惱才有意義。\", \"真正的快樂是施捨後的那份清靜、安慰與喜悅。\"]NewTextData = []def jieba_cut(): for text in Text_Data: split_result = list(jieba.cut(text)) sentence = \" \".join(split_result) NewTextData.append(sentence)def tfidfvec(): # 實例化 tfidf = TfidfVectorizer() # 調用fit_transform trans_data = tfidf.fit_transform(NewTextData) print(trans_data)if __name__ == '__main__': jieba_cut() tfidfvec() 返回sparse矩陣12345678910 (0, 9) 0.2685092134645423 (0, 2) 0.34056989045654285 (0, 5) 0.6811397809130857 (0, 11) 0.34056989045654285 (0, 21) 0.34056989045654285 (0, 22) 0.34056989045654285 (1, 8) 0.3535533905932738 (1, 18) 0.3535533905932738...... 得到一般矩陣 trans_data.toarray() 1234567891011[[0. 0. 0.34056989 0. 0. 0.68113978 0. 0. 0. 0.26850921 0. 0.34056989 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.34056989 0.34056989 0. 0. 0. 0. 0. 0. ] [0.35355339 0. 0. 0. 0. 0. ... ... 0. 0.42176478 0. 0. 0. 0. 0. 0. 0. 0. 0.42176478]]","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"},{"name":"特徵工程","slug":"特徵工程","permalink":"http://www.taroballz.com/tags/特徵工程/"},{"name":"特徵抽取(feature extraction)","slug":"特徵抽取-feature-extraction","permalink":"http://www.taroballz.com/tags/特徵抽取-feature-extraction/"}]},{"title":"(補充)修復bug分支","slug":"Git_fixbug","date":"2018-07-01T16:00:00.000Z","updated":"2018-07-02T13:52:41.000Z","comments":true,"path":"2018/07/02/Git_fixbug/","link":"","permalink":"http://www.taroballz.com/2018/07/02/Git_fixbug/","excerpt":"保存當前分支的工作區狀態(stash)當你接到修復一個代號001的bug任務時，但是當前在dev分支上的工作還沒完成，也不能進行提交git提供了一個stash功能，可將當前的工作現場＂保存＂起來，待以後恢復現場再繼續工作","text":"保存當前分支的工作區狀態(stash)當你接到修復一個代號001的bug任務時，但是當前在dev分支上的工作還沒完成，也不能進行提交git提供了一個stash功能，可將當前的工作現場＂保存＂起來，待以後恢復現場再繼續工作 1git stash 此時git status會變乾淨 列出保存的工作區1git stash list 恢復工作現場1git stash pop git status查看修改狀況已經恢復 修復bug分支軟體開發中，有了bug就需要修復，在git中，每個bug都可以通過建立一個新的臨時分支來修復，修復後合併分支，並將臨時分支刪除 修復bug流程 保存當前開發分支的工作區狀態(git stash) 切換到bug所在的分支 創建此bug分支的臨時分支，並切換到此臨時分支 修復bug並提交 切換回原bug分支並完成合併(注意：勿使用快速合併，否則將不記錄bug修復狀態，推薦使用git merge --no-ff -m) 刪除臨時分支 回到開發分支 恢復工做區狀態","categories":[{"name":"Git","slug":"Git","permalink":"http://www.taroballz.com/categories/Git/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Git","slug":"Git","permalink":"http://www.taroballz.com/tags/Git/"}]},{"title":"Git基礎使用2","slug":"GitNote2","date":"2018-06-26T16:00:00.000Z","updated":"2018-07-02T16:00:04.000Z","comments":true,"path":"2018/06/27/GitNote2/","link":"","permalink":"http://www.taroballz.com/2018/06/27/GitNote2/","excerpt":"返回過去版本在我們不斷更新原代碼的過程中，有可能還未完成，但是項目必須本機持續work，因此只能先運行過去的版本，必須將本機的專案返回到過去的狀態","text":"返回過去版本在我們不斷更新原代碼的過程中，有可能還未完成，但是項目必須本機持續work，因此只能先運行過去的版本，必須將本機的專案返回到過去的狀態 reset強制返回(—hard) 後面須填入參數為返回的版本版本：HEAD：上一次commit版本HEAD~ (HEAD^)：上上次commit的版本 (HEAD版本-1)HEAD~n：前N代的版本 HEAD^^(前二代版本);HEAD^^^(前三代版本) 依此類推 git log —oneline 所顯示的版本號 12345git reset --hard HEADgit reset --hard HEAD~git reset --hard HEAD~4 # 返回前四個版本git reset --hard b4f2d74 # 返回到指定版本號(即使是比當前版本更新的版本號也可以，只要還記得版本號就可以) 因為此命令會修改本地文件 使用時務必做好備份 reflog要是沒有記住特定的版本號可使用reflog查看做了那些移動HEAD的操作來推估版本號再搭配reset一起使用12git reflog git reflog -4 #指定顯示前四條操作 使用分支(branch)查看分支狀態1git branch *所指向的分支為當前所在分支 如要列出包含遠程庫的所有分支須加 -a 參數1git branch -a 建立分支123git branch 分支名git branch 分支名 分支點基礎git branch dev remotes/origin/dev #以遠程的remotes/origin/dev分支，作為興建本地dev分支的基礎 如果只填入分支名，默認以本地主分支(master)作為興建分支的基礎 切換分支(checkout)1git checkout 分支名 建立分支的同時切換到該分支(-b)1git checkout -b 分支名 切換過去的分支狀態與主分支狀態是一樣的 再次使用git branch確認*所指向的分支 刪除分支(-d)1git branch -d 分支名 合併分支(merge)將開發分支的內容合併到主分支(合併成最新版本)1git merge 分支名 切換到主分支底下操作 合併完後記得刪除分支 tips 通常合併分支時，git會用快速合併(fast forward)模式，但是有些快速合併不能成功，但是合併並沒有發生衝突，git會在此時合併之後幫忙進行新的提交 要是要禁止使用快速合併1git merge --no-ff -m &quot;信息備註&quot; 分支名1022222今天他透視嗎與可喔嗎耨黑獄 分支衝突當團隊中多人同時編輯一個文件的時候，難免會出現源碼合併時產生衝突問題在merge之後會產生衝突conflict，需手動修改衝突代碼，再重新提交 使用tag標籤任何軟體或是應用程序在發布時都應該給一個版本號，來管理每次的發布內容，便於今後的管理 顯示tag狀態1git tag 為當前git庫的狀態打tag12git tag 版本號git tag v1.0.0 #將當前的git庫狀態作為1.0.0版本 查看不同tag的狀態12git show tag名git show v1.0.1 #查看tag為v1.0.1的狀態 連接遠程伺服器將編寫完成的代碼提交到服務器端，其他開發人員可從服務器拉取你推送的代碼，完成團隊的協同開發 把遠程庫拷貝到本地(clone)1git clone 網址 生成ssh-key1ssh-keygen -t rsa &quot;郵件地址&quot; 連接服務器信息(remote)1git remote -v 用作確認pull或是fetch是對哪個遠程庫載入 push是對哪個遠程庫進行推送 本地推送至服務器(push)1git push origin 分支名稱 要是遠程庫上沒有此分支名稱，遠程庫會建立一個新的分支 本地的分支跟蹤遠程的分支本地的提交與遠程的提交記錄要是不一致，會給出提示1git branch --set-upstream-to=origin/分支名 本地分支名 如果有不一致的地方可用git status查看 且如果設置跟蹤遠程分支git push時可不加任何參數,將自己目前所在的庫往遠程庫推送 從遠程分支拉取代碼(pull)1git pull origin 分支名稱 將遠程分支上的代碼下載並合併到本地的所在分支","categories":[{"name":"Git","slug":"Git","permalink":"http://www.taroballz.com/categories/Git/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Git","slug":"Git","permalink":"http://www.taroballz.com/tags/Git/"}]},{"title":"Git基礎使用","slug":"GitNote1","date":"2018-06-24T16:00:00.000Z","updated":"2018-07-01T14:43:30.000Z","comments":true,"path":"2018/06/25/GitNote1/","link":"","permalink":"http://www.taroballz.com/2018/06/25/GitNote1/","excerpt":"建立git庫在當前的文件夾下建立git庫(初始化一個git數據庫)1git init 使用此命令後當前文件夾下的所有文件均能進行版本管理 當前文件夾下會多一個.git文件夾","text":"建立git庫在當前的文件夾下建立git庫(初始化一個git數據庫)1git init 使用此命令後當前文件夾下的所有文件均能進行版本管理 當前文件夾下會多一個.git文件夾 git設置查看當前git設置1git config -l 全局用戶名設置用戶名1git config --global user.name &quot;用戶名&quot; 信箱1git config --global user.email &quot;E-mail&quot; 設置高亮顯示1git config --global color.ui true git config幫助文檔查看1git config --help or1git help config 提交通常會遵循以下步驟 在以初始化git庫的文件夾下建立文件 追加文件 提交文件 查看當前文件夾的狀態1git status 未被放到索引區及經過修改的文件為紅色顯示 被放入索引區的文件會顯示綠色 文件增加至索引區(add)加入單文件1git add 文件 加入多文件1git add 文件1 文件2 .... 加入當前文件夾中所有文件1git add . 提交文件至本地庫(commit)1git commit -m &quot;備註&quot; 提交時不允許無備註的提交 提交後git寄存了一個新的版本 更新最後的提交(—amend)場景：以修改過的文件已經commit，不小心又需要修改某個小地方，不想在重新commit一條記錄，可加入—amend參數，將修改後的文件記錄合併在上一條的提交1git commit --amend 輸入此命令後會跳出編輯器，可編輯上一條的備註(可不修改直接退出) 提交記錄(log)查看提交的記錄信息1git log 含有各種文件提交時的信息及備註 指定條數顯示12git log -數字git log -2 #顯示前面兩條記錄 單行顯示一條提交記錄併作一行顯示12git log --onelinegit log --oneline -4 #一行模式顯示前面四條提交記錄 詳細顯示包含對文件做了哪些修改、新增那些文件等等1git log -p 顯示統計信息顯示提交文件數的統計信息1git log --stat 幫助文檔查看git log幫助文檔1git log --help 恢復文件未git add未使用git add加入索引區之前使用git checkout恢復上次文件加入索引區的狀態1git checkout -- 文件名 已git add若以使用git add加入索引區使用git reset退出索引區，再使用git checkout恢復文件1git reset HEAD 文件名 比較修改內容(diff)比較當前文件夾中文件 與 索引區文件 的差異1git diff 修改內容會高亮顯示 比較當前文件夾與git庫HEAD的差異1git diff HEAD -- 文件名 比較不同版本文件的差異12git diff 版本1 版本2 -- 文件名git diff HEAD HEAD^ -- index.html 比較git庫文件的差異比較索引區的文件 與 git庫文件 的差異須加入 --cached參數 1git diff --cached 文件操作刪除文件從索引區中刪除文件 1git rm --cahed 文件名 更名(移動)文件用於更名文件居多1git mv 原文件名 更名文件名 忽略管理(.gitignore)設置Git忽略文件，這些文件不參與Git庫的提交和管理(例如：python執行時產生的pycache) 於.gitignore文件中設置不需要管理的文件 .gitignore須參與版本管理 詳細設置請參考https://git-scm.com/docs/gitignore 忽略管理文件1echo *.tmp &gt; .gitignore #忽略管理.tmp後綴的文件 編輯.gitignore加入條件 子文件夾下的.tmp文件仍會忽略管理","categories":[{"name":"Git","slug":"Git","permalink":"http://www.taroballz.com/categories/Git/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Git","slug":"Git","permalink":"http://www.taroballz.com/tags/Git/"}]},{"title":"MongoDB學習筆記-文檔的方法(持續新增...)","slug":"MongoDB_Document_Method","date":"2018-05-28T16:43:00.000Z","updated":"2018-05-28T16:46:35.000Z","comments":true,"path":"2018/05/29/MongoDB_Document_Method/","link":"","permalink":"http://www.taroballz.com/2018/05/29/MongoDB_Document_Method/","excerpt":"文檔的排序(sort)只要對象是文檔(Document)，就能調用.sort()方法進行排序 調用方法使用. 語法：1文檔對象.sort(&#123;字段:1/-1&#125;); 參數為一json對象 按照字段之值進行文檔排序並返回 1為升序排列，-1為降序排列 example:123db.class.find( &#123;&#125;,&#123;_id:0&#125;).sort(&#123;\"studentID\":1&#125;);","text":"文檔的排序(sort)只要對象是文檔(Document)，就能調用.sort()方法進行排序 調用方法使用. 語法：1文檔對象.sort(&#123;字段:1/-1&#125;); 參數為一json對象 按照字段之值進行文檔排序並返回 1為升序排列，-1為降序排列 example:123db.class.find( &#123;&#125;,&#123;_id:0&#125;).sort(&#123;\"studentID\":1&#125;); 限制返回結果的文檔數量(limit)文檔對象調用limit方法，則按照默認的順序，返回限制數量的文檔 語法：1文檔對象.limit(數量) 參數為返回的數量 example:123456789//返回math字段之值為９０以上的前三筆文檔db.class.find( &#123;\"math\":&#123;$gte:90&#125;&#125;).limit(3);//亦可搭配前面的sort方法使用，先排序後取出db.class.find( &#123;\"math\":&#123;$gte:90&#125;&#125;).sort(&#123;\"math\":-1&#125;).limit(3); 只返回一條文檔(findOne)其為集合的方法，find()是返回全部文檔，findOne()則返回一條文檔 用於單一文檔定位非常好用 語法：1集合名.findOne(); 使用方法與find一致 相當於db.集合名.find().limit(1);，但使用findOne較為簡潔 跳過返回結果的文檔數量(skip)跳過指定的文檔數量，並返回之後的結果 語法：12345//1.文檔對象.skip(數量);//2.文檔對象.skip(數量).limit(數量); 第二種方法可實現分頁的功能 example12345//先顯示十條信息db.class.find().sort(&#123;\"studentID\":1&#125;).limit(10)//當用戶切換第二頁時，接著顯示另外十條信息db.class.find().sort(&#123;\"studentID\":1&#125;).skip(10).limit(10) Reference:http://komavideo.com/mongodb/index.html","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://www.taroballz.com/categories/MongoDB/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://www.taroballz.com/tags/MongoDB/"}]},{"title":"MongoDB學習筆記-文檔更新(update)","slug":"MongoDB_update","date":"2018-05-28T16:43:00.000Z","updated":"2018-05-28T18:17:15.000Z","comments":true,"path":"2018/05/29/MongoDB_update/","link":"","permalink":"http://www.taroballz.com/2018/05/29/MongoDB_update/","excerpt":"文檔更新 update()方法為集合對象所調用(同find及findOne) 其功能較為複雜可參考官方文檔：https://docs.mongodb.com/manual/reference/method/db.collection.update/ 語法12345db.集合名.update( &#123;filter&#125;, &#123;update&#125;, option,); filter(過濾器)：更新前的文檔定位，相當於 關係型數據庫的WHERE update：更新哪些字段，做了哪些更新操作 option: 其他更新選項","text":"文檔更新 update()方法為集合對象所調用(同find及findOne) 其功能較為複雜可參考官方文檔：https://docs.mongodb.com/manual/reference/method/db.collection.update/ 語法12345db.集合名.update( &#123;filter&#125;, &#123;update&#125;, option,); filter(過濾器)：更新前的文檔定位，相當於 關係型數據庫的WHERE update：更新哪些字段，做了哪些更新操作 option: 其他更新選項 example I12 Reference:http://komavideo.com/mongodb/index.html","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://www.taroballz.com/categories/MongoDB/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://www.taroballz.com/tags/MongoDB/"}]},{"title":"MongoDB學習筆記-依條件搜尋文檔","slug":"MongoDB_func_find","date":"2018-05-27T16:00:00.000Z","updated":"2018-05-28T04:49:40.000Z","comments":true,"path":"2018/05/28/MongoDB_func_find/","link":"","permalink":"http://www.taroballz.com/2018/05/28/MongoDB_func_find/","excerpt":"條件搜尋文檔 find({字段:條件})括號中輸入的參數為json對象，為取文檔之條件","text":"條件搜尋文檔 find({字段:條件})括號中輸入的參數為json對象，為取文檔之條件 判斷字段名example123456//查找categories字段名為golang的結果db.Articles.find( &#123; \"categories\":\"golang\" &#125;) 條件判斷 語法 符號 $gte >= $gt > $lte &lt;= $lt &lt; $eq == $ne != 須遵守以上語法規則進行查詢 語法12345db.集合名.find( &#123; 字段:&#123;條件判斷語法 : 條件&#125; &#125;); example123456// 查找rank值大於等於４的結果db.Articles.find( &#123; \"rank\":&#123;$gte:4&#125; &#125;); 正則判斷查找字段中含有某些字元的結果 語法12345db.集合名.find( &#123; 字段: /正則條件/ &#125;); example:123456789//查找title字段中含有18的結果db.Articles.find( &#123;\"title\":/18/&#125;);//查找title字段中開頭為This的結果db.Articles.find( &#123;\"title\":/^This/&#125;); 多條件搜尋and 運算12345678db.集合名.find( &#123; 字段1 : 條件1, 字段2 : 條件2, ... ... &#125;); 條件之間以,分隔 返回滿足各個條件的結果 example12345678//查詢tag字段為food，且title字段含有beef，且rank字段大於等於5之結果db.Articles.find( &#123; \"tag\":\"food\", \"title\":/beef/, \"rank\":&#123;$gte:5&#125;, &#125;); or運算($or)12345678db.集合名.find( &#123; $or:[&#123;字段1:條件1&#125;, &#123;字段2:條件2&#125;, &#123;...&#125;, &#123;...&#125;,] &#125;); 各個條件放在一個列表中 條件{}放在大括號裡，表示條件之間互不相干 不同條件以 ,(逗號)區隔 example12345678//查找math大於６０,或science大於９０，或gender為female的結果db.Class.find( &#123; $or:[&#123;math:&#123;$gte:60&#125;&#125;, &#123;science:&#123;$gte:90&#125;&#125;, &#123;gender:\"female\"&#125;,] &#125;); $in 及 $nin $in 返回查詢字段之值位於條件列表中的結果 $nin 返回查詢字段之值不位條件於列表中的結果 1234567891011db.集合名.find( &#123; \"字段名\":&#123;$in:[條件列表]&#125; &#125;);db.集合名.find( &#123; \"字段名\":&#123;$nin:[條件列表]&#125; &#125;); example12345db.restaurant.find( &#123; \"food_material\":&#123;$in:[\"fish\",\"pork\",\"chicken\"]&#125; &#125;); 抽出指定字段在實際業務開發中，使用上述的方法查詢到特定的文檔時，不可能將整份的文檔所含的字段全部抽取出來，即便查詢的結果只有一個文檔，他也有可能包含數十甚至上百個字段通常只會需要結果的特定某些字段，因此就需要對查詢結果的字段進行過濾 語法1db.集合名.find(&#123;查詢器&#125;,&#123;篩選器&#125;) 查詢器：如同前面所提到的各個查詢條件 篩選器：指定抽出的字段，亦為ㄧjson對象 篩選器的格式為：{字段1:true,字段2:1,_id:0} 選擇特定的字段其值要是為true或1則被抽取出 _id字段默認會被抽取出，若不抽取則設為0(但文檔在更新時需要_id,所以不推薦將其設為0) example12345678910111213db.Class.find( &#123; $or:[ &#123;\"math\":&#123;$gte:60&#125;&#125;, &#123;\"science\":&#123;$gte:80&#125;&#125;, ] &#125;, &#123; \"name\":true, \"StudentID\":1, \"_id\":0, &#125;); 查找特定字段(鍵)所有的值(distinct)1db.集合名.distinct(&quot;字段(鍵)名&quot;); 返回一個列表,裡面含有所有的值 example1db.Articles.distinct(&quot;categories&quot;); result12345[ python, golang, mongodb,] 查找特定字段(鍵)是否存在的文檔($exists)123db.restaurant.find( &#123;字段名 : &#123; $exists : true/false &#125; &#125;); example1234//查詢restaurant集合中存在CanSmoke鍵的所有文檔db.restaurant.find( &#123;\"CanSmoke\" : &#123;$exists:true&#125;&#125;); Reference:http://komavideo.com/mongodb/index.html","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://www.taroballz.com/categories/MongoDB/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://www.taroballz.com/tags/MongoDB/"}]},{"title":"MongoDB學習筆記-集合及文檔的簡易操作","slug":"MongoDB_operation","date":"2018-05-27T05:00:00.000Z","updated":"2018-05-28T16:50:53.000Z","comments":true,"path":"2018/05/27/MongoDB_operation/","link":"","permalink":"http://www.taroballz.com/2018/05/27/MongoDB_operation/","excerpt":"集合(collection)相關操作修改集合名1db.原集合名.renameCollection(&quot;修改集合名&quot;); 將原集合名改為修改後的集合名 刪除集合1db.集合名.drop(); 將選定的集合名刪除","text":"集合(collection)相關操作修改集合名1db.原集合名.renameCollection(&quot;修改集合名&quot;); 將原集合名改為修改後的集合名 刪除集合1db.集合名.drop(); 將選定的集合名刪除 文檔(document)相關操作 文檔相當於關係型數據庫的數據紀錄(record) 於集合中插入文檔(insert)於當前數據庫的特定集合名中插入文檔 插入單筆文檔1db.集合名.insert(文檔); 文檔為標準的json格式 example:1234567891011121314db.Articles.insert( &#123; &quot;_id&quot;:&quot;001&quot;, &quot;title&quot;:&quot;My First Article&quot; &#125; );db.Articles.insert( &#123; &quot;_id&quot;:&quot;002&quot;, &quot;title&quot;:&quot;My Second Article&quot; &quot;tag&quot;:[&quot;None&quot;] &#125; ); 同一個集合中插入文檔的字段名不一定要一樣 批量插入文檔搭配javascript語法，使用for循環批量插入文檔 example:12345678for (var i = 1; i &lt;= 10; i++)&#123; db.Articles.insert( &#123; &quot;_id&quot;: i, &quot;title&quot;:&quot;It&apos;s my &quot; + i + &quot; article&quot;, &#125; );&#125; 查詢集合中的所有文檔(find) 相當於在關係數據庫中的SELECT操作 1db.集合名.find(); find()方法未填入任何參數則查詢集合中的所有文檔 查詢文檔數量(count) 相當於在關係數據庫中的SELECT COUNT操作 1db.集合名.count(); 返回集合中 文檔數量 刪除所有文檔(remove)1db.集合名.remove(&#123;&#125;); 於remove方法的參數中填入{}，代表刪除全部文檔 Reference:http://komavideo.com/mongodb/index.html","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://www.taroballz.com/categories/MongoDB/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://www.taroballz.com/tags/MongoDB/"}]},{"title":"MongoDB學習筆記-初識MongoDB","slug":"MongoDB_introduction","date":"2018-05-27T02:00:00.000Z","updated":"2018-05-28T16:50:53.000Z","comments":true,"path":"2018/05/27/MongoDB_introduction/","link":"","permalink":"http://www.taroballz.com/2018/05/27/MongoDB_introduction/","excerpt":"Introduction MongoDB是一個面向文檔的免費數據庫 多用於數據採集和分布式處理(Map/Reduce)，特別是在大數據處理方面比較擅長 數據庫排名： https://db-engines.com/en/ranking MongoDB為唯一一個排名前五的文檔存取型的數據庫","text":"Introduction MongoDB是一個面向文檔的免費數據庫 多用於數據採集和分布式處理(Map/Reduce)，特別是在大數據處理方面比較擅長 數據庫排名： https://db-engines.com/en/ranking MongoDB為唯一一個排名前五的文檔存取型的數據庫 基本概念關係型數據庫(Relational DBMS)如 Oracle,MySQL,SQL Server,PostgreSQL…等 數據庫 (Database) 數據表 (Table) 紀錄 (Record) 文檔存取型數據庫(Document Store)如 MongoDB 數據庫 (Database) 集合 (Collection) 文檔 (Document) NoSQL 在NoSQL的數據庫中，操作數據都是通過指令或程序語言完成的 MongoDB中使用Javascript和JSON數據結構，來操作及管理數據 數據庫的使用步驟 建立數據庫 —&gt; Blog 建立數據集合 —&gt; Article, Categories, Tags 建立數據 架構：1234567891011* Blog * Article * &#123;&quot;_id&quot;:&quot;001&quot;,&quot;title&quot;:&quot;My First Article&quot;&#125; * &#123;&quot;_id&quot;:&quot;002&quot;,&quot;title&quot;:&quot;My Second Article&quot;&#125; * &#123;&quot;_id&quot;:&quot;003&quot;,&quot;title&quot;:&quot;My Third Article&quot;,&quot;delflag&quot;:1&#125; * Categories * &#123;&quot;_id&quot;:&quot;001&quot;,&quot;type&quot;:&quot;diary&quot;&#125; * &#123;&quot;_id&quot;:&quot;002&quot;,&quot;type&quot;:&quot;note&quot;&#125; * Tags * &#123;&quot;_id&quot;:&quot;001&quot;,&quot;year&quot;:&quot;2018&quot;&#125; * &#123;&quot;_id&quot;:&quot;002&quot;,&quot;year&quot;:&quot;2017&quot;&#125; 可以發現在Blog-Article-_id為003的表字段名可與其他數據不一樣(與關係型數據庫最大的不同之處) 使其靈活度比關係型數據庫更高 簡單命令請先於於終端上鍵入1$ mongo 進入mongodb命令行工具，或稱mongodb客戶端 查看幫助文檔1&gt; help 查看可輸入哪些指令 查看所有數據庫1&gt; show dbs; 切換(創建)數據庫1&gt; use 庫名; 切換到 庫名 數據庫; 若是當前無此數據，則會建立此數據庫 當前數據庫1&gt; db 查看當前位於何者數據庫 建立數據集合(表)1&gt; db.createCollection(&quot;集合名稱&quot;); 使用.(點)調用當前數據庫的方法createCollection() 參數為 欲建立數據集合名稱 相當於表名 查看集合於當前數據庫查看有哪些集合1&gt; show collections; 當前數據庫狀態1&gt; db.stats(); 返回當前數據庫各種信息 刪除當前數據庫1db.dropDatabase(); Reference:http://komavideo.com/mongodb/index.html","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://www.taroballz.com/categories/MongoDB/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://www.taroballz.com/tags/MongoDB/"}]},{"title":"Golang網路編程-day29-socket-TCP編程","slug":"Go_Tcp","date":"2018-05-24T16:00:00.000Z","updated":"2019-03-17T16:02:32.000Z","comments":true,"path":"2018/05/25/Go_Tcp/","link":"","permalink":"http://www.taroballz.com/2018/05/25/Go_Tcp/","excerpt":"introduction socket編程分為客戶端及服務器 golang中服務端處理流程： 監聽端口 接收客戶端的連接 創建goroutine，處理該連接 golang中客戶端處理流程： 建立與服務端的連接 進行數據受發 關閉連接 一般socket基本的架構如圖所示 golang 將以上的服務皆封裝了，且性能非常高","text":"introduction socket編程分為客戶端及服務器 golang中服務端處理流程： 監聽端口 接收客戶端的連接 創建goroutine，處理該連接 golang中客戶端處理流程： 建立與服務端的連接 進行數據受發 關閉連接 一般socket基本的架構如圖所示 golang 將以上的服務皆封裝了，且性能非常高 服務端(server)123456789101112131415161718192021222324252627282930313233343536373839404142434445package mainimport ( \"fmt\" \"net\")func main()&#123; fmt.Println(\"start server....\") // 1. 監聽端口 listen,err := net.Listen(\"tcp\",\"0.0.0.0:7777\") if err != nil &#123; fmt.Println(\"Build Listen Action Failed with Error:\",err) return &#125; defer listen.Close() for &#123; // 2. 接收客戶端的連接 conn,err := listen.Accept() if err != nil &#123; fmt.Println(\"Accept Connet Failed with Error\",err) continue &#125; // 3. 創建goroutine，處理該連接 go process(conn) &#125;&#125;func process(conn net.Conn)&#123; //退出連接時一定要關閉 defer conn.Close() //建立512bytes的緩衝區 buf := make([]byte,512) for &#123; n,err := conn.Read(buf) if err != nil &#123; fmt.Println(\"read bytes err:\",err) return &#125; fmt.Println(string(buf[:n]),\"from:\",conn.RemoteAddr()) //使用buf[:n]才不會用緩衝區未讀取的情況 if string(buf[:n]) == \"exit\" &#123; return &#125; &#125;&#125; 可使用nc連接測試 客戶端(client)123456789101112131415161718192021222324252627282930313233343536373839404142434445package mainimport ( \"bufio\" \"fmt\" \"net\" \"os\" \"strings\")func send_data(terminal_reader *bufio.Reader,connect net.Conn) &#123; for &#123; str, err := terminal_reader.ReadString('\\n') if err != nil &#123; fmt.Println(\"Read string Error:\", err) &#125; str = strings.Trim(str, \"\\r\\n\") _, err = connect.Write([]byte(str)) if err != nil &#123; fmt.Println(\"Send Data Failed\", err) &#125; else &#123; fmt.Println(\"Send data successs!!\") &#125; if str == \"exit\"&#123; return &#125; &#125;&#125;func main()&#123; var forward_ip string = \"127.0.0.1\" var forward_port string = \"8888\" // 1. 建立與服務端的連接 conn,err := net.Dial(\"tcp\",fmt.Sprintf(\"%s:%s\",forward_ip,forward_port)) if err != nil &#123; fmt.Println(\"Client Dial Error:\",err) &#125; // 3. 退出時務必關閉 defer conn.Close() terminal_reader := bufio.NewReader(os.Stdin) // 2. 進行數據收發 send_data(terminal_reader, conn)&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"網路編程","slug":"網路編程","permalink":"http://www.taroballz.com/tags/網路編程/"},{"name":"socket","slug":"socket","permalink":"http://www.taroballz.com/tags/socket/"}]},{"title":"Python機器學習-numpy","slug":"Python_ML_numpy","date":"2018-05-20T16:00:00.000Z","updated":"2018-05-21T13:23:36.000Z","comments":true,"path":"2018/05/21/Python_ML_numpy/","link":"","permalink":"http://www.taroballz.com/2018/05/21/Python_ML_numpy/","excerpt":"introduction 對一份大型的數據來說，是由多筆樣本所構成的 列(column)通常為樣本的指標或是特徵(feature) 行(row)則代表一筆含有多項特徵的資料集合 綜合以上，以矩陣形式表示資料會更為直觀 計算方便 計算效率高 numpy庫可用於矩陣計算","text":"introduction 對一份大型的數據來說，是由多筆樣本所構成的 列(column)通常為樣本的指標或是特徵(feature) 行(row)則代表一筆含有多項特徵的資料集合 綜合以上，以矩陣形式表示資料會更為直觀 計算方便 計算效率高 numpy庫可用於矩陣計算 導入numpy Library1import numpy as np 產生陣列(array)從列表(list)產生陣列將列表類型轉換為numpy.ndarray以創建陣列123data = [1,2,3,4,5]arr = np.array(data)arr 亦可直接填入list12arr = np.array([1,2,3,4,5])arr result1array([1, 2, 3, 4, 5]) 查看類型1type(arr) result1numpy.ndarray 類型為numpy.ndarray arrange產生陣列產生int陣列1np.arange(10) result1array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 產生float陣列1np.arange(10.0) result1array([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.]) 步進產生陣列example 1:1np.arange(10,30,5) 從10開始，每＋５產生值到３０停止，但不包含３０ result1array([10, 15, 20, 25]) example 2:1np.aarange(0,2,0.3) result1array([0. , 0.3, 0.6, 0.9, 1.2, 1.5, 1.8]) linspace產生1D陣列得到特定範圍內指定個數元素的陣列12from numpy import pinp.linspace(0,2*pi,6) 產生從０開始到2pi(包含2pi)，分成６等份的一維陣列 若未指定分成多少等份，預設為５０等份，即(start,inclusive stop,50) result12array([0. , 1.25663706, 2.51327412, 3.76991118, 5.02654825, 6.28318531]) logspace產生1D陣列得到10的start次方到10的inclusive stop次方的陣列1np.logspace(0, 3, 8) # 10^0 to 10^3 (inclusive) with 8 points result12array([ 1. , 2.6826958 , 7.19685673, 19.30697729, 51.79474679, 138.94954944, 372.75937203, 1000. ]) 創建二維(2D)矩陣搭配range()創建2D array123data2 = [range(1, 5), range(5, 9)] # list of listsarr2 = np.array(data2) # 2d arrayarr2 直接填入嵌套的list創建12arr2 = np.array([[1,2,3,4],[5,6,7,8]])arr2 result12array([[1, 2, 3, 4], [5, 6, 7, 8]]) 將矩陣轉為列表類型 將numpy.ndrray轉為list12a = arr2.tolist() # convert array back to listtype(a) result1list 陣列檢查查看矩陣存放的類型(dtype)在創建矩陣時不像list，各元素之間可為不同類型，矩陣中的元素必須為同一類型 12arr_test = np.array([1,2,3,4,5])arr_test.dtype result1dtype(&apos;int64&apos;) 只要其中一個元素類型不一樣，為了滿足其中一個元素的類型，會將其他元素轉換為更泛用的類型 example 1:12arr_test = np.array([1,2,3,4,5.0])arr_test.dtype result1dtype(&apos;float64&apos;) example 2:12arr_test = np.array([1,2,3,'4',5.0])arr_test.dtype result1dtype(&apos;&lt;\\U21&apos;) 查看矩陣的結構(shape)常用於debug 2D array1arr2.shape shape返回一個tuple，為(row, column)形式 result1(2, 4) 1D array1arr.shape result1(5,) 查看矩陣維度(ndim)12print(arr.ndim)print(arr2.ndim) result1212 查看矩陣的元素總數(size)12print(arr.size)print(arr2.size) result1258 矩陣的選取(切片slicing)透過索引(index)選取特定範圍內的陣列 語法與list切片的方法一樣，只是不同維度需用逗號(,)隔開start (= 0) : stop (= last) :step (= 1) 取特定行example 1:12arr = np.array([range(1,4),range(4,7),range(7,10)])arr[0, :] result1array([1, 2, 3]) example 2:1arr[0:2, :] result12array([[1, 2, 3], [4, 5, 6]]) 取特定列example 1:1arr[:, 0] result1array([1, 4, 7]) 單取一列值時，返回為1d-array example 2:1arr[:, 1:] result123array([[2, 3], [5, 6], [8, 9]]) 取特定範圍1arr[0:2, 0:2] result12array([[1, 2], [4, 5]]) 取特定值12val = arr[2:2]val 其等同於arr[2][2]，先取行在取列result19 修改特定值12arr[1:1] = 100arr 其等同於arr[1][1] = 100，先取行在取列result123array([[ 1, 2, 3], [ 4, 100, 6], [ 7, 8, 9]]) 矩陣的邏輯運算普通邏輯運算進行普通邏輯運算時會對陣列中的每一個元素都進行計算，並返回一個bool類型的陣列(不需使用for循環進行運算)example 1:12matrix = np.array([range(1,4),range(4,7),range(7,10)])matrix &gt; 5 result123array([[False, False, False], [False, False, True], [ True, True, True]]) example 2:1matrix == 9 result123array([[False, False, False], [False, False, False], [False, False, True]]) 返回為True的值example 1:123arr_bool = np.array([False,True,False])arr_int = np.array([1,2,3]) arr_int[arr_bool] # 將arr_bool當作index，傳入arr_int中計算 result1array([2]) example 2:1234matrix = np.array([[5,15,20],[20,25,30],[35,40,45]])second_col_25 = matrix[1, :] == 25print(second_col_25)matrix[second_col_25] # 從matrix中查找符合此bool矩陣的row之值 result123[False True False]array([[20, 25, 30]]) 結果為matrix[1,:] 與或運算example 1:12matrix = np.array([[5,15,20],[20,25,30],[35,40,45]])(matrix &gt; 25) &amp; (matrix &lt; 50) 務必加上括號() result123array([[False, False, False], [False, False, True], [ True, True, True]]) example 2:1(matrix &gt; 25) | (matrix &lt; 10) result123array([[ True, False, False], [False, False, True], [ True, True, True]]) 判斷有無非數字值(isnan)12a = np.array([1,2,3,4,5,np.nan])np.isnan(a) result1array([False, False, False, False, False, True]) 矩陣的運算減法1234a = np.array([10,20,30,40,50])b = np.arange(5)print(a-b)print(b-1) result12[10 19 28 37 46][-1 0 1 2 3] 對應位置相減 求次方12b = np.arrane(5)b**2 result1array([ 0, 1, 4, 9, 16]) 矩陣乘法使用＊則對應位置元素相乘12345A = np.array([[1,1], [0,1]])B = np.array([[2,0], [3,4]])A*B result12array([[2, 0], [0, 4]]) 使用dot求積12print(A.dot(B))print(np.dot(A,B)) 兩個效果是一樣的result12345[[5 4] [3 4]] [[5 4] [3 4]] 變換矩陣存儲的類型(astype)透過astype()將矩陣原類型，轉換為其他類型12345str_matrix = np.array([['1','2','3']]) print(str_matrix.dtype)int_matrix = str_matrix.astype(int)print(int_matrix.dtype)int_matrix result1234&lt;\\U1int64array([[1, 2, 3]]) 矩陣的內置屬性求最小值(min)12IntVector = np.array([1,2,3,4,5,6,7,8,9])IntVector.min() result11 求最大值(max)12IntVector = np.array([1,2,3,4,5,6,7,8,9])IntVector.max() result19 比較同座標值之大小(maximum,minimum)12nums = np.arange(5)np.maximum(nums, np.array([1, -2, 3, -4, 5])) # compare element-wise maximum返回較大的值之矩陣，minimum返回較小值之矩陣 result1array([1, 1, 3, 3, 5]) 求極值(最大值，最小值)的索引(argmax,argmin)123a = np.floor(10*np.random.random((3,4)))print(a)a.argmax(axis = 1) axis=1為求每一行(row)最大值的索引，axis=0為求每一列(column)，不加則是全部運算取一返回值 result12345[[8. 8. 8. 4.] [5. 2. 7. 3.] [8. 9. 5. 6.]]array([0, 2, 1]) 求和(sum)example 1:12IntMatrix = np.array([range(1,4),range(4,7),range(7,10)])IntMatrix.sum(axis = 0) axis = 0 代表 求每一列(column)之總和，不加怎是全部元素求和 result1array([12, 15, 18]) example 2:12IntMatrix = np.array([range(1,4),range(4,7),range(7,10)])IntMatrix.sum(axis = 1) axis = 1 代表 求每一行(row)之總和 result1array([ 6, 15, 24]) 求集合(unique)陣列中不會有重複的元素，相當於set()12Intmatrix = np.array([1,2,1,2,3,3,4,5,6,6,6,7,7,8,8])np.unique(Intmatrix) result1array([1, 2, 3, 4, 5, 6, 7, 8]) 向量(vector)與矩陣(matrix)的轉換使用reshape將向量轉為矩陣123matrix = np.arange(15)matrix.reshape(3,5)matrix 在reshape過程中，元素數量為一固定值，因此確定了３行必定為５列，亦可寫成reshape(3,-1) result123array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14]]) shape賦值將向量轉為矩陣123matrix = np.arange(15)matrix.shape = (3,-1)matrix result123array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14]]) 將矩陣拉成一向量ravel1234matrix =np.array([[5, 7, 1, 3], [7, 8, 9, 4], [8, 8, 7, 0]])matrix.ravel() result1array([5, 7, 1, 3, 7, 8, 9, 4, 8, 8, 7, 0]) ravel產生的陣列仍指向原矩陣，操作其值，原矩陣亦會發生改變 flatten12345matrix =np.array([[5, 7, 1, 3], [7, 8, 9, 4], [8, 8, 7, 0]])a = matrix.flatten() # flatten 回傳一個原始的陣列複本 (a flat copy)a result1array([5, 7, 1, 3, 7, 8, 9, 4, 8, 8, 7, 0]) flatten產生的陣列為一復本，操作其值，原矩陣不會發生改變 使用np.newaxis將平行向量轉換為垂直向量123a = np.array([0, 1, 2, 3]) a_col = a[:, np.newaxis] # same as a_col = a[:, None]a_col result1234array([[0], [1], [2], [3]]) 初始化矩陣zeros初始化一個元素皆為０的矩陣(參數為一tuple)1np.zeros((3, 4),dtype=np.int32) dtype可決定存放的類型(亦可不設置，默認為float64) result123array([[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]], dtype=int32) ones初始化一個元素皆為１的矩陣(參數為一tuple)1np.ones((2,3,4),dtype=np.int8) result1234567array([[[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]], dtype=int8) random初始化一個元素為0至１之間隨機浮點數的矩陣(參數為一tuple)1np.random.random((2,3)) result12array([[0.78248299, 0.52270045, 0.0945345 ], [0.30580916, 0.31472853, 0.34269623]]) numpy開啟格式化文件(genfromtxt) 使用numpy.genfromtxt()讀取格式化的數據 1np.genfromtxt(\"student_score.txt\",delimiter=',',dtype=str) 參數１：指定文件路徑 delimiter : 指定分隔符(文件中元素之間的分隔符) dtype : 以何種類型將文件讀入(大部分用str方式讀入再去轉換成其他類型) 12345array([[&apos;Amy&apos;, &apos;1001&apos;, &apos;18&apos;, &apos;95.0&apos;], [&apos;Tom&apos;, &apos;1002&apos;, &apos;20&apos;, &apos;89.5&apos;], [&apos;John&apos;, &apos;1003&apos;, &apos;21&apos;, &apos;77.8&apos;], [&apos;Tony&apos;, &apos;1004&apos;, &apos;23&apos;, &apos;99.0&apos;], [&apos;Lucy&apos;, &apos;1005&apos;, &apos;19&apos;, &apos;88.6&apos;]], dtype=&apos;&lt;U4&apos;) 讀入為一矩陣 12stu_info = np.genfromtxt(\"student_score.txt\",delimiter=',',dtype=str)type(stu_info) 1numpy.ndarray 為numpy.ndarray類型 其他操作指數函數(exp)12B = np.arange(3)np.exp(B) result1array([1. , 2.71828183, 7.3890561 ]) 開根號(sqrt)1np.sqrt(B) result1array([0. , 1. , 1.41421356]) 無條件捨去取整(floor)將矩陣內元素的小數位皆丟棄，只留下整數位的數123A = np.random.random((3,4))*10print(A)print(np.floor(A)) result1234567[[4.79808472 2.44399243 5.548923 6.92783862] [2.83681077 4.38694273 8.19855738 4.97988545] [1.04608979 1.0399803 2.22577406 7.76268637]] [[4. 2. 5. 6.] [2. 4. 8. 4.] [1. 1. 2. 7.]] 無條件進位取整(ceil)將矩陣內元素的小數位皆進位，只留下整數位的數123A = np.random.random((3,4))*10print(A)print(np.ceil(A)) result1234567[[1.9360702 1.05170707 5.41654963 7.97196499] [8.12826589 7.20266718 8.15762529 5.84988628] [4.32137618 9.08694857 1.05489433 6.37825292]] [[ 2. 2. 6. 8.] [ 9. 8. 9. 6.] [ 5. 10. 2. 7.]] 轉置矩陣(T)123matrix =np.array([[9., 3., 8., 0., 6., 9.], [4., 1., 4., 3., 8., 3.]])matrix.T result123456array([[9., 4.], [3., 1.], [8., 4.], [0., 3.], [6., 8.], [9., 3.]]) 擴展矩陣(tile)定義一個矩陣，以此矩陣為單元擴展成自己需要的維度123a = np.arange(1,3)b = np.tile(a,(2,2))b result12array([[1, 2, 1, 2], [1, 2, 1, 2]]) 矩陣疊加平行疊加(hstack)增加特徵數12345a = np.floor(10*np.random.random((2,2)))b = np.floor(10*np.random.random((2,2)))print(a)print(b)print(np.hstack((a,b))) result12345678[[1. 3.] [8. 6.]] [[1. 4.] [3. 7.]] [[1. 3. 1. 4.] [8. 6. 3. 7.]] 垂直疊加(vstack)增加樣本數12345a = np.floor(10*np.random.random((2,2)))b = np.floor(10*np.random.random((2,2)))print(a)print(b)print(np.vstack((a,b))) result12345678910[[2. 1.] [8. 0.]] [[5. 5.] [3. 7.]] [[2. 1.] [8. 0.] [5. 5.] [3. 7.]] 多維疊加(stack) 兩個一維的矩陣疊加為二維矩陣 兩個二維的矩陣疊加為三維矩陣12345a = np.floor(10*np.random.random((2,2)))b = np.floor(10*np.random.random((2,2)))print(a)print(b)np.stack((a,b)) result1234567891011[[7. 7.] [3. 3.]] [[4. 4.] [4. 9.]] [[[7. 7.] [3. 3.]] [[4. 4.] [4. 9.]]] 矩陣切分(split)平行切分(np.hsplit)第二參數為一整數123a = np.floor(10*np.random.random((2,12)))print(a)print(np.hsplit(a,3)) 將a平行切分成３等份 result123456789[[1. 5. 8. 1. 3. 1. 9. 4. 3. 8. 8. 9.] [2. 8. 9. 7. 1. 9. 6. 6. 9. 1. 1. 7.]] [array([[1., 5., 8., 1.], [2., 8., 9., 7.]]), array([[3., 1., 9., 4.], [1., 9., 6., 6.]]), array([[3., 8., 8., 9.], [9., 1., 1., 7.]])] 指定平行切分第二參數為一tuple123a = np.floor(10*np.random.random((2,12)))print(a)print(np.hsplit(a,(3,4,6))) 將陣列於index第３ ４ ６的位置進行拆分 1234567891011[[3. 4. 8. 7. 1. 7. 3. 8. 5. 7. 1. 3.] [1. 2. 4. 8. 2. 5. 4. 6. 1. 8. 0. 8.]] [array([[3., 4., 8.], [1., 2., 4.]]), array([[7.], [8.]]), array([[1.], [2.]]), array([[7., 3., 8., 5., 7., 1., 3.], [5., 4., 6., 1., 8., 0., 8.]])] 垂直切分(np.vsplit)123b = np.floor(10*np.random.random((2,2)))print(b)print(np.vsplit(b,2)) result12345[[1. 6.] [5. 9.]] [array([[1., 6.]]), array([[5., 9.]])] 指定垂直切分123b = np.floor(10*np.random.random((3,2)))print(b)print(np.vsplit(b,(1,))) result1234567[[5. 8.] [9. 9.] [5. 1.]] [array([[5., 8.]]), array([[9., 9.], [5., 1.]])] 矩陣間的拷貝Situation 1 - 非拷貝Ａ與Ｂ指向同一矩陣(非拷貝)只是變量名不同，但指向的為同一個矩陣12345678910a = np.arange(12)print(a.shape)b = aprint(b is a)b.shape = (3,-1)print(a.shape)print(id(a))print(id(b)) result12345(12,)True(3, 4)43955593924395559392 對Ａ操作等同於對Ｂ操作 Situation 2 - 淺拷貝(view)Ａ與Ｂ指向不同矩陣，但矩陣中存放的值為共用的12345678910111213a =np.arange(12)print(a.shape)b = a.view()print(b is a)b.shape = (3,-1)print(a.shape)print(id(a))print(id(b))a[0] = 10000print(a)print(b) result123456789(12,)False(12,)43953852804395385120[10000 1 2 3 4 5 6 7 8 9 10 11][[10000 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] a.view()創建一個a矩陣的淺拷貝 a 與 b 為不同矩陣 改變b矩陣的shape,a並無變化 a 與 b 指向不同的內存地址 a 與 b 矩陣中的值是共用的 操作 a 矩陣的值 b 矩陣仍會改變 Situation 3 - 深拷貝Ａ與Ｂ指向不同矩陣，矩陣中存放的值也互不相干12345678910111213a =np.arange(12)print(a.shape)b = a.copy()print(b is a)b.shape = (3,-1)print(a.shape)print(id(a))print(id(b))a[0] = 10000print(a)print(b) result123456789(12,)False(12,)43955587524395560832[10000 1 2 3 4 5 6 7 8 9 10 11][[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] a.copy()創建一個a矩陣的深拷貝 a 與 b 矩陣中的值互不相干 矩陣排序np.sort排序返回一個排序好的矩陣1234matrix =np.array([[9., 3., 8., 0., 6., 9.], [4., 1., 4., 3., 8., 3.]])a = np.sort(matrix,axis=1)a axis=1代表按行排序，axis=0則為按列排序result12array([[0., 3., 6., 8., 9., 9.], [1., 3., 3., 4., 4., 8.]]) 矩陣內置.sort()排序對當前調用方法的矩陣排序1234matrix =np.array([[9., 3., 8., 0., 6., 9.], [4., 1., 4., 3., 8., 3.]])matrix.sort(axis =1)matrix result12array([[0., 3., 6., 8., 9., 9.], [1., 3., 3., 4., 4., 8.]]) argsort返回由小到大排序的索引值1234matrix =np.array([[9., 3., 8., 0., 6., 9.], [4., 1., 4., 3., 8., 3.]])SortIndex = matrix.argsort(axis=1)SortIndex result12array([[3, 1, 4, 2, 0, 5], [1, 3, 5, 0, 2, 4]]) 返回原矩陣由小到大原索引值的矩陣","categories":[{"name":"Python機器學習","slug":"Python機器學習","permalink":"http://www.taroballz.com/categories/Python機器學習/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"機器學習(Machine Learning)","slug":"機器學習-Machine-Learning","permalink":"http://www.taroballz.com/tags/機器學習-Machine-Learning/"},{"name":"numpy","slug":"numpy","permalink":"http://www.taroballz.com/tags/numpy/"}]},{"title":"Golang多線程初識-day28-線程異常(panic)","slug":"Go_ThreadPanic","date":"2018-05-18T16:00:00.000Z","updated":"2018-05-19T14:40:40.000Z","comments":true,"path":"2018/05/19/Go_ThreadPanic/","link":"","permalink":"http://www.taroballz.com/2018/05/19/Go_ThreadPanic/","excerpt":"introduction在實際業務開發中，我們可能會創建上萬個goroutine，當其中某個goroutine panic了，且沒有捕獲(recover)錯誤，那麼整個程序將會崩潰。所以，養成好習慣，每當創建一個goroutine，請記得於函數內寫下recover","text":"introduction在實際業務開發中，我們可能會創建上萬個goroutine，當其中某個goroutine panic了，且沒有捕獲(recover)錯誤，那麼整個程序將會崩潰。所以，養成好習慣，每當創建一個goroutine，請記得於函數內寫下recover 未捕獲錯誤即使創建上萬個goroutine，只要其中一個panic，程序亦無法正常執行 12345678910111213141516171819202122232425package mainimport ( \"fmt\" \"time\")func map_operation()&#123; var a map[string]string //map未初始化而panic a[\"123\"] = \"456\"&#125;func RunInNoError()&#123; fmt.Println(\"I'm no Error\")&#125;func main()&#123; for i:=0;i&lt;10000;i++&#123; go RunInNoError() &#125; go map_operation() time.Sleep(time.Second*10)&#125; result12345678910111213......I&apos;m no ErrorI&apos;m no ErrorI&apos;m no ErrorI&apos;m no Errorpanic: assignment to entry in nil maporoutine 10005 [running]:main.magp_operation() /.../main.go:12 +0x4bcreated by main.main /.../main.go:22 +0x66 其中一個goroutine發生panic導致主程序全數崩潰無法正常運行 捕獲(recover)錯誤養成好習慣，不管是在匿名函數或是函數中使用goroutine，請務必記得，於函數開始使用defer搭配recover捕獲錯誤 1234567891011121314151617181920212223242526272829303132package mainimport ( \"fmt\" \"time\")func map_operation()&#123; //於函數開始使用defer搭配recover捕獲錯誤 defer func()&#123; if err := recover(); err != nil &#123; fmt.Println(\"Error:\",err) &#125; &#125;() var a map[string]string //map未初始化而panic a[\"123\"] = \"456\"&#125;func RunInNoError()&#123; fmt.Println(\"I'm no Error\")&#125;func main()&#123; for i:=0;i&lt;10000;i++&#123; go RunInNoError() &#125; go map_operation() time.Sleep(time.Second*10)&#125; result123456789101112131415......I&apos;m no ErrorI&apos;m no ErrorI&apos;m no ErrorI&apos;m no ErrorI&apos;m no ErrorError: assignment to entry in nil mapI&apos;m no ErrorI&apos;m no ErrorI&apos;m no ErrorI&apos;m no ErrorI&apos;m no Error...... 即使其中有個goroutine發生panic仍不影響，其他業務及主程序的運行","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"錯誤處理","slug":"錯誤處理","permalink":"http://www.taroballz.com/tags/錯誤處理/"},{"name":"多線程","slug":"多線程","permalink":"http://www.taroballz.com/tags/多線程/"},{"name":"goroutine","slug":"goroutine","permalink":"http://www.taroballz.com/tags/goroutine/"}]},{"title":"Golang多線程初識-day28-定時器(超時處理)","slug":"Go_Timer","date":"2018-05-18T16:00:00.000Z","updated":"2020-01-12T15:43:20.000Z","comments":true,"path":"2018/05/19/Go_Timer/","link":"","permalink":"http://www.taroballz.com/2018/05/19/Go_Timer/","excerpt":"introduction Timer可以讓用戶自定義超時的邏輯 尤其是在應對select處理多個channel的超時、單channel讀寫的超時等情形， 為一次性的時間觸發事件，其與Ticker不同 Ticker是按一定時間間隔持續觸發時間事件 設置超時時間(timeout)，避免阻塞時間過長 定時器(Ticker)位於time包中，使用NewTicker()方法生成定時器","text":"introduction Timer可以讓用戶自定義超時的邏輯 尤其是在應對select處理多個channel的超時、單channel讀寫的超時等情形， 為一次性的時間觸發事件，其與Ticker不同 Ticker是按一定時間間隔持續觸發時間事件 設置超時時間(timeout)，避免阻塞時間過長 定時器(Ticker)位於time包中，使用NewTicker()方法生成定時器 生成定時器(Ticker)1234567891011121314151617package mainimport ( \"time\" \"fmt\")func main()&#123; //使用NewTicker設置定時器,參數為時間的間隔 //以下為設置一個一秒執行一次的定時器 timer := time.NewTicker(time.Second) //使用range()方法從timer.C管道中取出數據 for v:= range(timer.C) &#123; fmt.Println(\"hello\",v) &#125;&#125; timer.C 本身為一個channel，其後端有一個goroutine，每隔一段NewTicker()方法設置的時間參數，會往裡面寫入時間 上述利用range()方法將數據取出 result12345hello 2018-05-19 18:18:47.193000586 +0800 CST m=+1.004599317hello 2018-05-19 18:18:48.190658733 +0800 CST m=+2.002270359hello 2018-05-19 18:18:49.189746058 +0800 CST m=+3.001370599...... 因為每隔一秒goroutine才會往timer.C管道扔數據，因此主線程也是每一秒才能從管道中取出數據 一次性定時器 搭配select一起使用，仍是用作設置timeout time.After(Time)的參數為一時間 相當於time.NewTimer(d).C 為一 只讀channel 類型 其它創建方式 12t := time.NewTimer(d)t := time.AfterFunc(d,f) 定時時間：d 觸發後執行的動作：f 時間channel:t example 112345678910111213141516171819202122232425262728package mainimport ( \"time\" \"fmt\")func main()&#123; IntChan1 := make(chan int,1) IntChan2 := make(chan int,2) i := 0 for &#123; //time.After開始計時 select &#123; case IntChan1 &lt;- i: fmt.Printf(\"i value %d in Chan 1\\n\",i) case IntChan2 &lt;- i: fmt.Printf(\"i value %d in Chan 2\\n\",i) //滿足time.After()參數設置的時間， //表示無法滿足上面任一case操作(兩管道皆已滿)，操作已超時 //將time.After()管道中的時間丟棄，並完成select操作 case &lt;- time.After(time.Second): fmt.Println(\"cross 1 second: timeout\") &#125; i++ &#125;&#125; result12345678i value 0 in Chan 1i value 1 in Chan 2i value 2 in Chan 2cross 1 second: timeoutcross 1 second: timeoutcross 1 second: timeout...... tips 較不推薦使用此方法作為超時控制，因為time.After()並未關閉， 在for無限循環中可以看到，會創建越來越多的管道造成內存overflow example 2 使用time.NewTimer()作為一次性計時器 123456789101112131415161718192021222324package mainimport ( \"fmt\" \"time\")func main()&#123; timer := time.NewTimer(5*time.Second) go func()&#123; &lt;- timer.C fmt.Println(\"開始執行函數\") &#125;() time.Sleep(3 * time.Second) succ := timer.Stop() //未到timer的timeout時可停止timer的運作 if succ &#123; fmt.Println(\"timer stop succ\") return &#125; fmt.Println(\"timer stop failed\")&#125; example 3 使用time.NewTicker()作為一次性的計時器 123456789101112131415161718192021222324252627282930313233package mainimport ( \"time\" \"fmt\")func main()&#123; IntChan1 := make(chan int,1) IntChan2 := make(chan int,2) timer := time.NewTicker(time.Second) i := 0 for &#123; select &#123; case IntChan1 &lt;- i: fmt.Printf(\"i value %d in Chan 1\\n\",i) time.Sleep(time.Millisecond*800) case IntChan2 &lt;- i: fmt.Printf(\"i value %d in Chan 2\\n\",i) time.Sleep(time.Millisecond*800) //與上個例子一樣從管道中取出時間丟棄 case &lt;- timer.C: fmt.Println(\"cross 1 second: timeout\") &#125; i++ //使用完一次性的計時器隨即關閉，關閉後對象就消失，在使用此對象會panic timer.Stop() &#125;&#125; result1234i value 0 in Chan 1i value 1 in Chan 2i value 2 in Chan 2fatal error: all goroutines are asleep - deadlock! 第一次select已經關閉timer，但管道未滿， 第四次select後，timer已關閉，再次使用發生panic tips推薦使用第二種方式當作一次性的定時器","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"時間和日期(time)","slug":"時間和日期-time","permalink":"http://www.taroballz.com/tags/時間和日期-time/"},{"name":"多線程","slug":"多線程","permalink":"http://www.taroballz.com/tags/多線程/"},{"name":"管道(channel)","slug":"管道-channel","permalink":"http://www.taroballz.com/tags/管道-channel/"}]},{"title":"Golang多線程初識-day27-goroutine通信-管道(channel)","slug":"Go_channel","date":"2018-05-16T16:00:00.000Z","updated":"2020-01-12T14:11:27.000Z","comments":true,"path":"2018/05/17/Go_channel/","link":"","permalink":"http://www.taroballz.com/2018/05/17/Go_channel/","excerpt":"introduction 類似unix中的管道(pipe)，或是隊列(queue) channel為引用類型的數據結構 先進先出 線程安全，多個goroutine同時訪問，不需要加鎖 channel是有類型的，整數的channel只能存放整數，依此類推 使用make()初始化管道","text":"introduction 類似unix中的管道(pipe)，或是隊列(queue) channel為引用類型的數據結構 先進先出 線程安全，多個goroutine同時訪問，不需要加鎖 channel是有類型的，整數的channel只能存放整數，依此類推 使用make()初始化管道 聲明123456var 變量名 chan 類型var test chan intvar test1 chan stringvar test2 chan map[string]stringvar test3 chan stu //自定義結構體類型var test4 chan *stu //亦可傳入指針 通常變量名會希望知道其為管道，因此會將chan結合其他關鍵字作為變量名12var IntChan chan intvar StrChan chan string 操作管道example 1123456789101112131415161718192021222324252627282930313233343536package mainimport \"fmt\"func main()&#123; //聲明管道 var intChan chan int //初始化管道 intChan = make(chan int,10) mapChan := make(chan map[string]string,10) //往管道內寫入數據 //int intChan &lt;- 10 //map a := make(map[string]string,0) a[\"Name\"] = \"Curtis\" mapChan &lt;- a //關閉管道 close(intChan) close(mapChan) //遍歷管道 //int for i := range intChan &#123; fmt.Println(i) &#125; //map for i := range mapChan &#123; fmt.Println(i) &#125;&#125; result1210map[Name:Curtis] example 212345678910111213141516171819202122232425262728293031package mainimport \"fmt\"func main()&#123; //聲明並初始化管道 UserChan := make(chan user,10) UserPtrChan := make(chan *user,10) var User1 user = user&#123; UserName:\"Tom\", UserAge:18, &#125; //往管道內寫入數據 UserChan &lt;- User1 UserPtrChan &lt;- &amp;User1 //關閉管道 close(UserChan) close(UserPtrChan) //遍歷管道 for i := range(UserChan) &#123; fmt.Println(i) &#125; for i := range(UserPtrChan)&#123; fmt.Println(*i) &#125;&#125; 若管道類型為interface{}則可以接受任何類型數據的寫入 result12&#123;Tom 18&#125;&#123;Tom 18&#125; tips從channel讀取數據12a = &lt;- testChanb := &lt;- testChan 賦值記得加上= 聲明並賦值加上:= 從channel寫入數據1testChan &lt;- a channel和goroutine相結合使用goroutine搭配channel實現讀寫 example123456789101112131415161718192021222324252627package mainimport ( \"time\" \"fmt\")var dataChan chan int = make(chan int,1)func WriteData (i int) &#123; dataChan &lt;- i&#125;func ReadData()&#123; data := &lt;- dataChan fmt.Println(data)&#125;func main()&#123; for i:=0;i&lt;10;i++&#123; go WriteData(i) &#125; for i:=0;i&lt;10;i++&#123; go ReadData() &#125; time.Sleep(time.Second*5)&#125; result123456789105312678409 阻塞 若是存放進去管道的數據數量超過管道的容量又沒有其他協程取出數據，管道會一直阻塞等待數據被取出 1234567891011121314151617181920212223242526272829package mainimport ( \"time\" \"fmt\")var dataChan chan int = make(chan int,5)func WriteData (i int) &#123; dataChan &lt;- i fmt.Println(\"input the data\",i)&#125;func ReadData()&#123; data := &lt;- dataChan fmt.Println(\"get the data:\",data)&#125;func main()&#123; for i:=0;i&lt;10;i++&#123; go WriteData(i) &#125; for i:=0;i&lt;10;i++&#123; time.Sleep(time.Second) go ReadData() &#125; time.Sleep(time.Second*5)&#125; result1234567891011121314151617181920input the data 5input the data 8input the data 0input the data 1input the data 7get the data: 1input the data 9get the data: 0input the data 6get the data: 5input the data 3get the data: 8input the data 2get the data: 7input the data 4get the data: 9get the data: 6get the data: 3get the data: 2get the data: 4 從上述可看到寫入的協程馬上寫入了５組數據，但要再寫入時因為管道已經滿了，必須等待讀的協程取出數據，才能在寫入數據到管道中 檢測channel是否被關閉 使用close()函數關閉channel 在關閉channel後，管道只可讀(取出)不可再寫入 在取數據時可判斷管道是否已關閉，將最後一個數據取出時便會停止再取出數據 安全的取出數據，才不會造成死循環 val,ok := &lt;- channel 當ok的值返回false時代表已從關閉的管道中取出最後一條數據 example12345678910111213141516171819202122package mainimport \"fmt\"func main()&#123; var intChan chan int intChan = make(chan int, 10) for i:=0;i&lt;10;i++&#123; intChan &lt;- i &#125; close(intChan) for &#123; var b int //ok返回管道中是否還有下一條數據 b,ok := &lt;- intChan if !ok &#123; break &#125; fmt.Println(b) &#125;&#125; 要是沒有使用ok判斷已關閉的管道是否還有下一條數據時，for循環會不斷的訪問管道造成死循環 result123456789100123456789 channel之間的同步 不再使用time.Sleep()等待線程完成任務 example 1 查找1-100的所有質數 12345678910111213141516171819202122232425262728293031323334353637383940package mainimport \"fmt\"func calc(i int,ResultNum chan int,Sync_signal chan bool)&#123; //退出時傳一個訊號到同步的channel中表示此任務已完成 defer func()&#123; Sync_signal &lt;- true &#125;() //判斷質數 for j:=2;j&lt;i;j++&#123; if i%j == 0 &#123; return &#125; &#125; ResultNum &lt;- i return&#125;func main()&#123; //建立接收同步訊號的channel(可以為任何類型的管道) //只要最後傳入訊號即可 Sync := make(chan bool,100) ResultNum := make(chan int,100) for i:=1;i&lt;=100;i++&#123; go calc(i,ResultNum,Sync) &#125; //上面共開啟100個線程，因此只要能取出100個訊號則代表子線程皆完成任務 for i:=1;i&lt;=100;i++&#123; //沒有變量接收訊號，代表將訊號取出後就直接丟棄 &lt;- Sync &#125; //主線程關閉管道 close(ResultNum) //遍歷管道計算的結果 for v := range(ResultNum)&#123; fmt.Println(v) &#125;&#125; 使用range()遍歷管道時，請注意管道必須先關閉(close())否則panic(Dead Lock) result123456789101112131415161718192021222324252621735111317192329313741434753596167717379838997 example 21234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport \"fmt\"func sendData(country string, DataChan chan string, Signal chan struct&#123;&#125;)&#123; DataChan &lt;- country //完成上述的任務後傳入信號 Signal &lt;- struct&#123;&#125;&#123;&#125;&#125;func getData(result chan string)&#123; for &#123; country,ok := &lt;-result if !ok &#123; break &#125; fmt.Println(country) &#125;&#125;func main()&#123; country := []string&#123;\"Washington\",\"Tripoli\",\"London\",\"Beijing\",\"Tokyo\"&#125; //創建一個存放data的管道 DataChan := make(chan string,len(country)) //創建一個存放線程結束信號的管道,信號型態為空結構體(可自定義為任何形式) SyncChan := make(chan struct&#123;&#125;,len(country)) for _,v := range country &#123; go sendData(v,DataChan,SyncChan) &#125; //取到全部子線程結束的信號，關閉data管道 go func()&#123; for i:=0;i&lt;len(country);i++ &#123; &lt;- SyncChan &#125; close(DataChan) &#125;() //取data getData(DataChan)&#125; result12345TripoliWashingtonBeijingLondonTokyo (補充)管道的只讀與只寫通常不會用以下的方法直接創建，會直接拿來當參數的類型使用居多 於函數中接受的形式參數類型為 只讀(只寫) 的通道時，可傳入可讀寫的雙向通道作為實體參數 (推薦) 創建可讀可寫管道(一般)123var 變量名 = make(chan int,1)變量名 := make(chan int,1) 創建只讀的管道123var 變量名 &lt;- chan int變量名 := make(&lt;-chan int,10) 創建只寫的管道123var 變量名 chan &lt;- int變量名 := make(chan &lt;- int ,10) 對channel進行select操作應用１管道都有固定大小，實際業務開發中，有可能會有管道空間不夠使用的情況，此時會一直阻塞，並等待數據被取出，才能再次寫入數據，若是一直無法將數據取出，會造成之後要寫入的數據無法進入管道，而使得業務停擺 解決方式：1234567891011121314151617181920package mainimport \"fmt\"func main()&#123; var testChan = make(chan int,10) test2Chan := make(chan int,10) for i:=1;i&lt;25;i++&#123; select &#123; case testChan &lt;- i: //1.創建多個管道，當第一個管道滿時，存入第二個管道 case test2Chan &lt;- i: //2.當連多個管道都不夠用時,採用default方法，防止堵塞情況 default : fmt.Println(i,\"can't send to Channel\") &#125; &#125;&#125; result123421 can&apos;t send to Channel22 can&apos;t send to Channel23 can&apos;t send to Channel24 can&apos;t send to Channel 應用２管道可能為空的情況下，有可能仍要持續的取出存放在管道內的數據，否則會一直阻塞，等待管道中有數據被寫入，才能再次取出數據，若是一直無數據被寫入，會造成業務停擺 解決方式：12345678910111213141516171819202122package mainimport \"fmt\"func main()&#123; testChan := make(chan int, 10) for i:=1;i&lt;10;i++&#123; testChan &lt;- i &#125; for i:=1;i&lt;15;i++&#123; select &#123; //盡可能的取出數據 case v := &lt;-testChan: fmt.Println(\"data\",v ,\"is got\") //無數據時，執行default方法，防止堵塞情況發生 default : fmt.Println(\"Channel have no item to get\") &#125; &#125;&#125; result1234567891011121314data 1 is gotdata 2 is gotdata 3 is gotdata 4 is gotdata 5 is gotdata 6 is gotdata 7 is gotdata 8 is gotdata 9 is gotChannel have no item to getChannel have no item to getChannel have no item to getChannel have no item to getChannel have no item to get","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"多線程","slug":"多線程","permalink":"http://www.taroballz.com/tags/多線程/"},{"name":"goroutine","slug":"goroutine","permalink":"http://www.taroballz.com/tags/goroutine/"},{"name":"管道(channel)","slug":"管道-channel","permalink":"http://www.taroballz.com/tags/管道-channel/"}]},{"title":"Golang多線程初識-day26-goroutine通信-線程同步(sync)","slug":"Go_sync","date":"2018-05-14T16:00:00.000Z","updated":"2018-05-17T14:56:36.000Z","comments":true,"path":"2018/05/15/Go_sync/","link":"","permalink":"http://www.taroballz.com/2018/05/15/Go_sync/","excerpt":"全局變量和鎖(sync) 透過全局的數據結構達到線程之間的通信 建立互斥鎖(sync.Mutex) -&gt; 只會有一個線程進到程序中進行讀寫 透過go build -race 檔名查看是否存在資源的競爭","text":"全局變量和鎖(sync) 透過全局的數據結構達到線程之間的通信 建立互斥鎖(sync.Mutex) -&gt; 只會有一個線程進到程序中進行讀寫 透過go build -race 檔名查看是否存在資源的競爭 example 創建goroutine完成不同數階乘的計算12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport ( \"fmt\" \"time\" \"sync\")type task struct &#123; num int&#125;//創建一個為map[string]int類型的切片var ShareSlice []map[string]int = make([]map[string]int,0)var lock sync.Mutexfunc calc(t *task)&#123; result := 1 //進行階乘運算 for i:=1; i&lt;=t.num; i++&#123; result *= i &#125; var ans map[string]int = map[string]int&#123;fmt.Sprintf(\"%d!\",t.num):result&#125; //涉及多個goroutine對同一個slice進行寫操作，因此加鎖 lock.Lock() ShareSlice = append(ShareSlice,ans) lock.Unlock()&#125;func main()&#123; //創建多個goroutine for i:=1;i&lt;11;i++&#123; t := &amp;task&#123;num:i&#125; go calc(t) &#125; //讓主線程等待所有線程完成執行計算任務 time.Sleep(time.Second*5) //對同一數據進行讀操作因此需加鎖 lock.Lock() for _,v := range(ShareSlice)&#123; fmt.Println(v) &#125; lock.Unlock()&#125; result12345678910map[9!:362880]map[2!:2]map[10!:3628800]map[1!:1]map[4!:24]map[3!:6]map[5!:120]map[7!:5040]map[6!:720]map[8!:40320] tips 可搭配 Go初識-day13-包(package)、線程同步(sync)與atomic操作 一起服用","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"多線程","slug":"多線程","permalink":"http://www.taroballz.com/tags/多線程/"},{"name":"goroutine","slug":"goroutine","permalink":"http://www.taroballz.com/tags/goroutine/"},{"name":"線程同步(sync)","slug":"線程同步-sync","permalink":"http://www.taroballz.com/tags/線程同步-sync/"}]},{"title":"Golang多線程初識-day25-goroutine","slug":"Go_goroutine","date":"2018-05-13T16:00:00.000Z","updated":"2018-05-17T14:54:56.000Z","comments":true,"path":"2018/05/14/Go_goroutine/","link":"","permalink":"http://www.taroballz.com/2018/05/14/Go_goroutine/","excerpt":"多線程編程(併發) 在C++, Java中創建線程，亦必須實現線程池管理線程;亦須解決線程之間數據共享的問題 goroutine 用於golang中的併發，屬於輕量級的線程 不需考慮線程池如何實現(由golang中的runtime管理) 創建goroutine非常方便(go)","text":"多線程編程(併發) 在C++, Java中創建線程，亦必須實現線程池管理線程;亦須解決線程之間數據共享的問題 goroutine 用於golang中的併發，屬於輕量級的線程 不需考慮線程池如何實現(由golang中的runtime管理) 創建goroutine非常方便(go) 進程與線程進程 進程是程序在操作系統中的一次執行過程，系統進行資源分配和調度的一個獨立單位 進程是程序運行的一個實例 線程 線程是進程的一個執行實體，是ＣＰＵ調度和分派的基本單位，他是比進程更小的能獨立運行的基本單位 一個程序中即使沒有創建任何線程，也有一個主線程在運行(一個進程之中至少有一個線程) 一個進程之中可創建大於一個的線程 tips 一個進程可以創建銷毀多個線程;同一個進程中的多個線程之間可併發執行 兩個線程執行是互不相影響的 一個進程中只有一個線程在執行：單線程程序 一個進程中有多個線程在執行：多線程程序 一個進程中創建多個子進程執行程序：多進程程序(nginx) 併發與併行 併發多線程程序在一個核的ＣＰＵ上運行 同一時刻只有一個線程在跑，只是間隔的時間很短 當創建了子線程時，主線程要是執行結束便直接退出，不會管子線程結束了沒 example123456789101112131415package mainimport ( \"fmt\")func test()&#123; for i:=0;i&lt;100;i++&#123; fmt.Println(i) &#125;&#125;func main()&#123; go test()&#125; result12 因主線程創建好子線程時就繼續往下執行 因此不管子線程是否有將程序執行完畢，當主線程執行結束時程序就結束了 要避免此情況，最簡單方法可在主線程使用time.Sleep()等待子線程執行完畢再退出 example 212345678910111213141516171819package mainimport ( \"fmt\" \"time\")func test()&#123; for i:=0;i&lt;100;i++&#123; fmt.Println(i) &#125;&#125;func main()&#123; go test() //加入等待時間等待子線程結束任務 time.Sleep(time.Second)&#125; result1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991000123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899 並行多線程程序在多個核的ＣＰＵ上運行 任一時刻有一個以上的線程在執行程序 只在多核的ＣＰＵ上才得以實現 協程與線程協程 擁有獨立的棧空間，且共享堆空間，調度由用戶自己控制 本質上類似於用戶級線程，這些用戶級線程也是自己實現的 線程 一個線程上可以跑多個協程，協程是輕量級的線程 一個物理線程可以執行多個goroutine協程 設置golang運行的cpu核數 golang v1.8版本之前需設定運行golang時所需要的CPU核心數(未設置則跑在單核心上) 12345678910package mainimport ( \"runtime\")func main()&#123; CpuNum := runtime.NumCPU() runtime.GOMAXPROCS(CpuNum)&#125; 1.8以上的版本默認將程序跑在所有的核上","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"多線程","slug":"多線程","permalink":"http://www.taroballz.com/tags/多線程/"},{"name":"goroutine","slug":"goroutine","permalink":"http://www.taroballz.com/tags/goroutine/"}]},{"title":"Go初識-day24-錯誤處理","slug":"Go_Error","date":"2018-05-07T16:00:00.000Z","updated":"2018-05-07T19:04:26.000Z","comments":true,"path":"2018/05/08/Go_Error/","link":"","permalink":"http://www.taroballz.com/2018/05/08/Go_Error/","excerpt":"定義錯誤 errors.New(&quot;錯誤碼&quot;) : 生成一個錯誤類型的實例 12345678910111213package mainimport ( \"errors\" \"fmt\")//定義一個errNotFound的變量為error類型，並用errors.New產生實例var errNotFound error = errors.New(\"NotFoundError\")func main()&#123; fmt.Printf(\"error : %v\",errNotFound)&#125; 在函數外定義錯誤，在函數內引用","text":"定義錯誤 errors.New(&quot;錯誤碼&quot;) : 生成一個錯誤類型的實例 12345678910111213package mainimport ( \"errors\" \"fmt\")//定義一個errNotFound的變量為error類型，並用errors.New產生實例var errNotFound error = errors.New(\"NotFoundError\")func main()&#123; fmt.Printf(\"error : %v\",errNotFound)&#125; 在函數外定義錯誤，在函數內引用 tips error類型並不是結構體(struct)類別，而是interfacehttps://golang.org/pkg/builtin/#error 只要實現error接口，我們也可自定義錯誤類型 123type error interface&#123; Error() string&#125; 絕大多數情況下使用 errors.New() 就能滿足自定義錯的需求 自定義錯誤類型(struct) 欲自定義錯誤類型並返回更多細節，可自定義錯誤類型的struct 只要結構體實現了Error()這個方法就能實現error這個接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( \"fmt\" \"os\" \"time\")//定義一個結構體紀錄錯誤細節的信息type FileNotFoundError struct &#123; FileName string Path string Time string operation string message string&#125;//FileNotFoundError這個結構體實現了Error()方法並返回string類型func (self *FileNotFoundError)Error()string&#123; return fmt.Sprintf(\"FileNotFound:\\n %s/%s\\n Time:%s\\n operation:%s\\n Message:%s\\n\", self.Path, self.FileName, self.Time, self.operation, self.message)&#125;//請注意期返回值error為接口 而不是結構體func ReadDoc (filename string) error &#123; File,err := os.Open(filename) if err != nil &#123; return &amp;FileNotFoundError&#123; FileName : filename, Path : \"somewhere\", Time : fmt.Sprintf(\"%v\",time.Now()), operation : \"Read\", message : err.Error(), &#125; &#125; defer File.Close() return nil&#125;func main()&#123; fmt.Println(ReadDoc(\"fasdfsdf.txt\"))&#125; result12345FileNotFound: somewhere/fasdfsdf.txt Time:2018-05-08 01:51:52.93837283 +0800 CST m=+0.000345825 operation:Read Message:open fasdfsdf.txt: no such file or directory 判斷錯誤屬於何種類型 判斷錯誤是否為自定義的錯誤類型 可使用類型斷言來判斷，因為error類型為interface example 11234567func main()&#123; err := ReadDoc(\"adfsdfsfd.txt\") _, ok := err.(*FileNotFoundError) if ok &#123; fmt.Println(\"It's FileNotFoundError Type\") &#125;&#125; result1It&apos;s FileNotFoundError Type example 212345678910func main()&#123; // 使用switch搭配.type使用類型斷言判斷 switch ReadDoc(\"fasdfsdf.txt\").(type) &#123; case *FileNotFoundError: fmt.Println(v, \"is type FileNotFoundError type\") default: fmt.Println(\"Default\") &#125;&#125; result1is type FileNotFoundError type tips 實際業務開發中使用errors.New()方法還是比較多 panic &amp; recover 請參考內置函數章節有詳盡的panic與recover的介紹","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"錯誤處理","slug":"錯誤處理","permalink":"http://www.taroballz.com/tags/錯誤處理/"}]},{"title":"Go初識-day23-json數據協議","slug":"Go_json","date":"2018-05-05T16:00:00.000Z","updated":"2019-03-30T08:48:28.000Z","comments":true,"path":"2018/05/06/Go_json/","link":"","permalink":"http://www.taroballz.com/2018/05/06/Go_json/","excerpt":"Introduction 目前有８０％的ＡＰＩ支持json數據協議 json協議為一種資料傳輸的標準，不同語言之間溝通的橋樑 將golang中數據類型，如struct,map等，使用json序列化，與其他語言進行交互","text":"Introduction 目前有８０％的ＡＰＩ支持json數據協議 json協議為一種資料傳輸的標準，不同語言之間溝通的橋樑 將golang中數據類型，如struct,map等，使用json序列化，與其他語言進行交互 json數據協議 導入包：import &quot;encoding/json&quot; json序列化 序列化：json.Marshal(data interface{}) 打包成json字符串，參數可傳入各種不同的數據結構 json序列化結構體 因為json為外部的package，因此欲被外部包訪問的情況下，在定義結構體時需注意字段名(屬性)須為大寫 123456789101112131415161718192021222324252627282930313233343536package mainimport ( \"encoding/json\" \"fmt\" \"os\")type User struct&#123; UserName string NickName string Age int Birth string Gender string Email string Phone string&#125;func main() &#123; Taroballz := &amp;User&#123; UserName:\"Curtis\", NickName:\"Taroballz\", Age:18, Birth:\"2000/12/12\", Gender:\"Male\", Email:\"study@golang.com\", Phone:\"1001234567\", &#125; result, err := json.Marshal(Taroballz) if err != nil &#123; fmt.Fprintf(os.Stderr,\"json encoding Failed:%s\",err) return &#125; fmt.Println(\"json encoding result:\",result) fmt.Println(\"json string is \", string(result))&#125; json打包的結果為[]byte類型，透過string()方法轉換為字符串 result12json encoding result: [123 34 85 115 101 114 78 97 109 101 34 58 34 67 117 114 116 105 115 34 44 34 78 105 99 107 78 97 109 101 34 58 34 84 97 114 111 98 97 108 108 122 34 44 34 65 103 101 34 58 49 56 44 34 66 105 114 116 104 34 58 34 50 48 48 48 47 49 50 47 49 50 34 44 34 71 101 110 100 101 114 34 58 34 77 97 108 101 34 44 34 69 109 97 105 108 34 58 34 115 116 117 100 121 64 103 111 108 97 110 103 46 99 111 109 34 44 34 80 104 111 110 101 34 58 34 49 48 48 49 50 51 52 53 54 55 34 125]json string is &#123;&quot;UserName&quot;:&quot;Curtis&quot;,&quot;NickName&quot;:&quot;Taroballz&quot;,&quot;Age&quot;:18,&quot;Birth&quot;:&quot;2000/12/12&quot;,&quot;Gender&quot;:&quot;Male&quot;,&quot;Email&quot;:&quot;study@golang.com&quot;,&quot;Phone&quot;:&quot;1001234567&quot;&#125; tips可使用json.MarshalIndent(欲格式化數據,空值替換,縮進替換)進行格式化輸出顯示結果會較清晰，但與Marshal方法無異1result, err := json.MarshalIndent(Taroballz,\"\",\" \") result123456789json string is &#123; &quot;username&quot;: &quot;Curtis&quot;, &quot;nickname&quot;: &quot;Taroballz&quot;, &quot;Age&quot;: 18, &quot;Birth&quot;: &quot;2000/12/12&quot;, &quot;Gender&quot;: &quot;Male&quot;, &quot;Email&quot;: &quot;study@golang.com&quot;, &quot;Phone&quot;: &quot;1001234567&quot;&#125; tag 透過反射(reflect)的tag將字段從大寫轉為小寫 格式為json:&quot;value&quot; 1234567891011121314151617181920212223242526272829303132333435package mainimport ( \"encoding/json\" \"fmt\" \"os\")type User struct&#123; UserName string `json:\"username\"` NickName string `json:\"nickname\"` Age int Birth string Gender string Email string Phone string&#125;func main() &#123; Taroballz := &amp;User&#123; UserName:\"Curtis\", NickName:\"Taroballz\", Age:18, Birth:\"2000/12/12\", Gender:\"Male\", Email:\"study@golang.com\", Phone:\"1001234567\", &#125; result, err := json.Marshal(Taroballz) if err != nil &#123; fmt.Fprintf(os.Stderr,\"json encoding Failed:%s\",err) return &#125; fmt.Println(\"json string is \", string(result))&#125; result1json string is &#123;&quot;username&quot;:&quot;Curtis&quot;,&quot;nickname&quot;:&quot;Taroballz&quot;,&quot;Age&quot;:18,&quot;Birth&quot;:&quot;2000/12/12&quot;,&quot;Gender&quot;:&quot;Male&quot;,&quot;Email&quot;:&quot;study@golang.com&quot;,&quot;Phone&quot;:&quot;1001234567&quot;&#125; 透過tag可將原本需大寫的字段名在json的格式中轉為小寫 tips 若是編碼後的json不想輸出至終端可使用json:&quot;-&quot;作為tag 若是bool類型的true,false;float及int類型的數字要使用字符串作為json輸出可使用json:&quot;,string&quot;作為tag json序列化map1234567891011121314151617181920212223package mainimport ( \"encoding/json\" \"fmt\" \"os\")func testJsonMap()&#123; var Tom map[string]interface&#123;&#125; = map[string]interface&#123;&#125;&#123;\"Age\":18&#125; Tom[\"Name\"] = \"Tom\" Tom[\"gender\"] = \"Male\" data,err := json.Marshal(Tom) if err != nil &#123; fmt.Fprintln(os.Stderr,\"json encoding failed:\",err) return &#125; fmt.Println(\"json encoding result:\",string(data))&#125;func main() &#123; testJsonMap()&#125; result1json encoding result: &#123;&quot;Age&quot;:18,&quot;Name&quot;:&quot;Tom&quot;,&quot;gender&quot;:&quot;Male&quot;&#125; json序列化切片(slice) 使用json序列化一個map類型的切片 123456789101112131415161718192021222324252627package mainimport ( \"encoding/json\" \"fmt\" \"os\")func testJsonSlice()&#123; var userinfo []map[string]interface&#123;&#125; userinfo = make([]map[string]interface&#123;&#125;,0) userinfo = append(userinfo,map[string]interface&#123;&#125;&#123;\"Name\":\"Amy\"&#125;) userinfo[0][\"Age\"] = 18 fmt.Println(cap(userinfo)) userinfo = append(userinfo,map[string]interface&#123;&#125;&#123;\"Name\":\"Tom\"&#125;) data, err := json.Marshal(userinfo) if err != nil &#123; fmt.Fprintln(os.Stderr,\"json encoding failed:\",err) return &#125; fmt.Println(\"json encoding result:\",string(data))&#125;func main() &#123; testJsonSlice()&#125; result121json encoding result: [&#123;&quot;Age&quot;:18,&quot;Name&quot;:&quot;Amy&quot;&#125;,&#123;&quot;Name&quot;:&quot;Tom&quot;&#125;] 可以看到slice的數據化類型為[ ]陣列形式 json反序列化在別人系統或是不同語言中拿到json的數據類型並反序列化成golang中的數據類型，並進行其他操作 反序列化：json.UnMarshal(data []byte, v interface{}) 將json字符串反序列化成golang的數據類型 data為要反序列化的json字符串 v為不同數據類型的實例 反序列化結構體 在反序列化之前要保證反序列化的類型及字段跟欲接收的容器是一樣的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package mainimport ( \"encoding/json\" \"fmt\")type User struct&#123; UserName string `json:\"username\"` NickName string `json:\"nickname\"` Age int Birth string Gender string Email string Phone string&#125;func testStruct()(Error error, user string)&#123; Taroballz := &amp;User&#123; UserName:\"Curtis\", NickName:\"Taroballz\", Age:18, Birth:\"2000/12/12\", Gender:\"Male\", Email:\"study@golang.com\", Phone:\"1001234567\", &#125; result, err := json.Marshal(Taroballz) if err != nil &#123; Error = fmt.Errorf(\"json encoding Failed:%s\",err) return &#125; user = string(result) return&#125;func testUnMarshallStruct(data string)(ret User, err error)&#123; var container User err = json.Unmarshal([]byte(data),&amp;container) if err != nil &#123; err = fmt.Errorf(\"UnMarshal Failed\") return &#125; ret = container return&#125;func main() &#123; err,data := testStruct() if err != nil &#123; fmt.Println(err) return &#125; result ,err := testUnMarshallStruct(data) if err != nil &#123; fmt.Println(err) return &#125; fmt.Println(\"result is\",result)&#125; result1Result is : &#123;Curtis Taroballz 18 2000/12/12 Male study@golang.com 1001234567&#125; tips UnMarshall只會解析所需要的字段置入結構體中 反序列化map1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport ( \"encoding/json\" \"fmt\")func testJsonMap()(ret string, error error)&#123; var Tom map[string]interface&#123;&#125; = map[string]interface&#123;&#125;&#123;\"Age\":18&#125; Tom[\"Name\"] = \"Tom\" Tom[\"gender\"] = \"Male\" data,err := json.Marshal(Tom) if err != nil &#123; error = fmt.Errorf(\"json encoding failed\") return &#125; ret = string(data) return&#125;func testUnMarshalMap(data string)(ret map[string]interface&#123;&#125;,error error)&#123; var container map[string]interface&#123;&#125; err := json.Unmarshal([]byte(data),&amp;container) //即使map為引用類型 仍需對map取址 if err != nil&#123; error = fmt.Errorf(\"Unmarshal failed:\",err) return &#125; ret = container return&#125;func main() &#123; data,err := testJsonMap() if err != nil &#123; fmt.Println(err) return &#125; result ,err := testUnMarshalMap(data) if err != nil &#123; fmt.Println(err) return &#125; fmt.Println(\"result is\",result)&#125; 可以看到在創建接收map類型的變量時，並沒有使用make()初始化map，亦就是說map在json.unmarshal()函數中才分配，只需將對應類型的變量傳入就好 往map中插入數據時，才會因為map是引用類型無須取址，但是改變map本身所儲存的資料則需取址 result1result is map[Name:Tom gender:Male Age:18] tips 在json數據的量比較大的情況下，標準庫encoding/json會不敷使用 這時可以使用ffjson進行序列化及反序列化 go get github.com/pquerna/ffjson/ffjson 其使用方法與encoding/json使用方法差不多 其速度為encoding/json的3到4倍","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"json","slug":"json","permalink":"http://www.taroballz.com/tags/json/"}]},{"title":"Golang物件導向初識-day22-命令行參數","slug":"Go_Args","date":"2018-05-01T16:00:00.000Z","updated":"2018-05-03T18:01:57.000Z","comments":true,"path":"2018/05/02/Go_Args/","link":"","permalink":"http://www.taroballz.com/2018/05/02/Go_Args/","excerpt":"Introduction 之前執行程序都是go build命令編譯成exe格式，不帶參數直接執行 但在線上開發業務時必須帶參數(指定配置文件等操作)","text":"Introduction 之前執行程序都是go build命令編譯成exe格式，不帶參數直接執行 但在線上開發業務時必須帶參數(指定配置文件等操作) os.Args 其為string類型的切片 若是在執行程序時，命令行沒有傳入參數，os.Args切片中只有一個元素，也就是程序自身 example123456789101112131415161718package mainimport ( \"fmt\" \"os\")func testArgs()&#123; fmt.Println(\"The Args length is: \",len(os.Args)) for i,v := range(os.Args)&#123; fmt.Printf(\"index %d is %s\\n\",i,v) &#125; return&#125;func main()&#123; testArgs()&#125; result123456789&gt; main.exe&gt; The Args length is: 1index 0 is main.exe&gt; main.exe -c D:/go_dev&gt; The Args length is: 3index 0 is main.exeindex 1 is -cindex 2 is D:/go_dev 可以發現自定義傳入的參數，其index皆由１開始 且傳入的每一個參數皆由空格(space)分割 tips 使用以上的方法去設置參數非常的不友好 且會限制使用者對於參數的使用法 通常使用以上的方法是為了單純獲取使用者傳入的所有參數 package flag透過flag包可以用來解析(讀取)命令行的參數，其接受的類型皆為指針 flag.BoolVar(&amp;test, &quot;b&quot;, false, &quot;input bool&quot;) 其接收的為boolean值 flag.StringVar(&amp;str, &quot;s&quot;, &quot;&quot;, &quot;input string&quot;) 其接收的為string值 flag.IntVar(&amp;count, &quot;c&quot;, 1001, &quot;input int&quot;) 其接收為int值 第一個參數為接收值的變量之地址(類似scanf) 第二個參數為key的名字 第三個參數為默認值(default value)，如果未指定key指向的值，便傳入默認值 第四個參數為說明 example1234567891011121314151617package mainimport( \"fmt\" \"flag\")func main()&#123; var configpath string var port int flag.StringVar(&amp;configpath,\"c\",\"\",\"input config path\") flag.IntVar(&amp;port,\"p\",3389,\"input port \") //上面寫完(預處理)仍不生效，需調用Parse()方法才會生效 flag.Parse() fmt.Println(\"configpath:\",configpath,\"port:\",port, \"start\")&#125; result12&gt; main.exe -c /var/mysql/config.conf -p 3306configpath: /var/mysql/config.conf port: 3306 start","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"接口(interface)","slug":"接口-interface","permalink":"http://www.taroballz.com/tags/接口-interface/"},{"name":"os","slug":"os","permalink":"http://www.taroballz.com/tags/os/"},{"name":"flag","slug":"flag","permalink":"http://www.taroballz.com/tags/flag/"},{"name":"命令行參數(Args)","slug":"命令行參數-Args","permalink":"http://www.taroballz.com/tags/命令行參數-Args/"}]},{"title":"Golang物件導向初識-day21-讀寫文件","slug":"Go_ReadWrite","date":"2018-04-30T16:00:00.000Z","updated":"2018-04-30T16:16:09.000Z","comments":true,"path":"2018/05/01/Go_ReadWrite/","link":"","permalink":"http://www.taroballz.com/2018/05/01/Go_ReadWrite/","excerpt":"終端讀寫 之前常使用的fmt包，就是操作終端的代表 操作終端相關文件句柄常量 os.Stdin:標準輸入 os.Stdout:標準輸出 os.Stderr:標準錯誤輸出","text":"終端讀寫 之前常使用的fmt包，就是操作終端的代表 操作終端相關文件句柄常量 os.Stdin:標準輸入 os.Stdout:標準輸出 os.Stderr:標準錯誤輸出 Fprintln(Fprintf)搭配os實現終端寫入fmt.Println(io.Writer, a ...interface{}) 第一個參數為一個實現io.Writer接口的實例 第二個參數為內容 12345678910package mainimport ( \"fmt\" \"os\")func main()&#123; fmt.Fprintln(os.Stdout,\"Hello World\")&#125; 其中的os.Stdout實現了io.Writer這個接口，因此可作為參數被傳入 result1Hello World 可以發現其功能與fmt.Println()直接輸出的功能是一樣的 Scanln(Scanf)實現終端讀入可使用Scanln()實現單行從終端讀入，其等價於Scanf()123456789101112func testScanln()&#123; var a int var b string fmt.Printf(\"input int &amp; string:\") fmt.Scanln(&amp;a,&amp;b) fmt.Fprintf(os.Stdout,\"int:%d, string:%s\",a,b)&#125;func main()&#123; testScanln()&#125;` 其fmt.Scanln(&amp;a,&amp;b)等同於fmt.Scanf(%d %s,a,b) result12&gt; input int &amp; string:1234 Hello!!&gt; int:1234, string:Hello!! Sscanf實現字符串格式化讀入將特定的字符串格式化讀入，並賦值給不同的變量 123456789101112func testSscanf()&#123; var a int var b string var c float64 str := \"18 Hello 12.3\" fmt.Sscanf(str,\"%d %s %f\", &amp;a, &amp;b, &amp;c) //注意給變量賦值要加上＆ fmt.Fprintf(os.Stdout,\"int:%d, string:%s, float:%.2f\", a, b, c)&#125;func main()&#123; testSscanf()&#125; fmt.Sscanf(string, format, ...variables): 第一個參數為要讀入的字符串(string) 第二個參數為要讀入的格式(format) 第三個參數為可變參數，將讀入的值賦給各個變量(…variables) result1int:18, string:Hello, float:12.30 文件讀寫套用終端讀寫使用的Fprintln()方法，只要將實現io.Writer接口的文件句柄傳參亦能實現讀寫文件的功能 建立(Write)文件句柄使用os.OpenFile()方法來開啟文件，且其賦值的變量就為文件句柄os.OpenFile()方法通常用作寫文件 1file,err := os.OpenFile(\"test.log\", os.O_CREATE|os.O_WRONLY, 0664) 第一個參數要是沒有填寫路徑則會打開(創建)在GoPATH下的文件 第二個參數為文件開啟的模式 (為一常量)，標記之間可使用|(或操作)加成 os.O_WRONLY: 只寫 os.O_CREATE: 創建文件(如果文件不存在) os.O_RDONLY: 只讀 os.O_RDWR: 讀寫皆可 os.O_TRUNC: 清空(文件存在情況下) 第三個參數設置權限控制 r —&gt; 004 w —&gt; 002 x —&gt; 001 example12345678910111213141516package mainimport ( \"os\" \"fmt\")func main()&#123; file,err := os.OpenFile(\"/tmp/test.log\",os.O_CREATE|os.O_WRONLY,0664) if err != nil &#123; fmt.Println(\"OpenFile Failed !, Error:\",err) return &#125; defer file.Close() fmt.Fprintln(file,\"Test WritingFile!!\")&#125; result12&gt; cat /tmp/test.log test.log&gt; Test WritingFile!! 從上述結果可以知道File這個變量亦實現了io.Writer接口，才能作為參數被傳入到Fprintln()函數中 建立(Read)文件句柄使用os.Open()方法來開啟文件os.Open()方法通常用作讀文件 1file,err := os.Open(\"test.log\") 只有一個參數，要是沒有填寫路徑預設會打開在GoPATH底下的同名文件 ioutil文件讀寫位於io/ioutil包中，可將整個文件直接讀取或是直接寫入 應用於讀取或是寫入的文件大小不是很大的時候 讀操作123456789101112131415161718func testIoutilRead(FileName string)&#123; //ioutil.Readfile可直接讀取整份文件的內容至緩衝區 file,err := ioutil.ReadFile(FileName) if err != nil &#123; //os.Stderr亦實現了io.writer的操作，可返回錯誤至終端 fmt.Fprintf(os.Stderr,\"File Error: %s\",err) return &#125; //讀出來的data為[]byte類型，需轉為string型 fmt.Println(string(file))&#125;func main()&#123; testIoutilRead(\"Testlog.log\")&#125; result1Test Hello World 寫操作12345678910111213func testIoutilWrite(FileName string)&#123; //將data直接寫入至文件中 err := ioutil.WriteFile(FileName,[]byte(\"Writing...\"),0664) if err != nil &#123; fmt.Fprintf(os.Stderr,\"File Write Error:\",err) return &#125;&#125;func main()&#123; testIoutilWrite(\"/tmp/test.log\")&#125; ioutil.WriteFile只有一個錯誤的返回值 請注意寫入多data為[]byte類型 第三個參數為權限設置 result12&gt; cat /tmp/test.log&gt; Writing... 帶緩衝區(bufio)的讀寫不直接操作底層的io(包括文件或是終端)，而是將數據先寫入緩衝區，再由Golang或是操作系統將緩衝區的數據寫入文件中 一般會先寫入到緩衝區中主要是為了性能，因為直接操作存放在硬碟的文件比記憶體的效率差很多 從終端讀入1234567891011121314151617181920func testbufio_terminalRead()&#123; //NewReader的參數為一個實現io.Reader接口的實例 bufioRead := bufio.NewReader(os.Stdin) fmt.Printf(\"input something I can read:\") //ReadBytes方法的參數填入分隔符 讀到何種字元為止（注意填入代表byte的單引號） str,err := bufioRead.ReadBytes('\\n') if err != nil&#123; fmt.Println(\"Terminal Read FAILED!!:\",err) return &#125; //讀到的bytes要將其轉為string fmt.Println(string(str)) &#125;func main()&#123; testbufio_terminalRead()&#125; 請注意bufio.NewReader()創造的實例有很多方法可以自己嘗試 亦可將os.Stdin替換成其他實現io.Reader接口的實例，實現不同的讀操作(文件，網路等) result12&gt; input something I can read:You have to read this sentence&gt; You have to read this sentence 從文件讀入1234567891011121314151617181920212223242526272829303132333435func testbufio_FileRead(FileName string) &#123; //前面有介紹讀文件通常使用os.Open() file, err := os.Open(FileName) if err != nil &#123; fmt.Println(\"file open failed with Error:\", err) return &#125; //記得關閉文件 defer file.Close() //新建一個緩衝區讀取的實例，file文件句柄實現了io.Reader接口 bufioRead := bufio.NewReader(file) for &#123; //一次讀入一行 line,err := bufioRead.ReadString('\\n') // io.EOF為讀到文件最後一行時會返回的錯誤，捕捉錯誤以 確定讀到最後一行 if err == io.EOF &#123; fmt.Println(\"The End\") return &#125; if err != nil &amp;&amp; err != io.EOF &#123; fmt.Println(\"ReadLine Error:\",err) return &#125; fmt.Printf(line) &#125;&#125;func main()&#123; testbufio_FileRead(\"Testlog.log\")&#125; result12Test Hello WorldThe End os.Fileos.File是一個結構體(struct)之前提到的os.Stdin,os.Stdout,os.Stderr,file文件句柄都屬於os.File的指針類型 寫入文件123456789101112131415161718192021func testbufioWrite(FileName string) &#123; file,err := os.OpenFile(FileName,os.O_WRONLY|os.O_CREATE,0664) if err != nil &#123; fmt.Fprintf(os.Stderr,\"File Open Error:%s\",err) return &#125; defer file.Close() //創建一個bufio.NewWriter對象 writer := bufio.NewWriter(file) //將要寫的內容先存入緩衝區 writer.WriteString(\"test bufio writing...\") //將寫入緩衝區(內存)的數據全部刷入文件(硬碟) writer.Flush()&#125;func main()&#123; testbufioWrite(\"bufioWritingTest.log\")&#125; 讀取壓縮文件1234567891011121314151617181920212223242526272829303132func testReadgzip(FileName string)&#123; fi, err := os.Open(FileName) if err != nil&#123; fmt.Fprintf(os.Stderr,\"Open file err : %s\",err) os.Exit(1) return &#125; defer fi.Close() //記得最後須關閉文件 //gzip.NewReader方法具解壓縮的功能 //gz變量接收解壓所過後所得到的文字訊息 gz,err := gzip.NewReader(fi) if err != nil &#123; fmt.Fprintf(os.Stderr,\"ungzip Failed: %s\",err) return &#125; //將gz變量讀取到的文字讀入緩存區中,並打印出來 r := bufio.NewReader(gz) for &#123; line,err := r.ReadString('\\n') if err != nil &amp;&amp; err == io.EOF &#123; fmt.Fprintf(os.Stdout,\"File Read Finish\") return &#125; fmt.Print(line) &#125;&#125;func main()&#123; testReadgzip(\"Testlog.log.gz\")&#125; result12Test Hello WorldFile Read Finish 拷貝文件拷貝文件使用io.Copy(dst Writer, src Reader)(written int64, err error)方法 dst為原文件，實現了Writer接口 src為拷貝文件位置，實現了Reader接口 翻閱Go文件源碼便可以知道，其實他是不斷的循環讀取src文件，並寫入到dst文件中https://golang.org/src/io/io.go line:359 12345678910111213141516171819202122232425func TestCopy(dst_file,src_file string)(written int64,err error)&#123; src,err := os.Open(src_file) if err != nil &#123; fmt.Fprintf(os.Stderr,\"dst File open Failed:\",err) return &#125; defer src.Close() dst,err := os.OpenFile(dst_file,os.O_CREATE|os.O_WRONLY,0666) if err != nil&#123; fmt.Fprintf(os.Stderr,\"src File open Failed:\",err) return &#125; defer dst.Close() return io.Copy(dst,src)&#125;func main()&#123; _ ,err := TestCopy(\"new_dst_file.go\",\"test2.go\") if err != nil &#123; fmt.Fprintf(os.Stderr,\"Copy Failed:%s\",err) return &#125; fmt.Println(\"Copy sucess\")&#125; result1Copy sucess","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"接口(interface)","slug":"接口-interface","permalink":"http://www.taroballz.com/tags/接口-interface/"},{"name":"os","slug":"os","permalink":"http://www.taroballz.com/tags/os/"},{"name":"bufio","slug":"bufio","permalink":"http://www.taroballz.com/tags/bufio/"},{"name":"ioutil","slug":"ioutil","permalink":"http://www.taroballz.com/tags/ioutil/"},{"name":"文件讀寫","slug":"文件讀寫","permalink":"http://www.taroballz.com/tags/文件讀寫/"},{"name":"多態","slug":"多態","permalink":"http://www.taroballz.com/tags/多態/"}]},{"title":"Golang物件導向初識-day20-反射(reflect)","slug":"Go_reflect","date":"2018-04-14T16:00:00.000Z","updated":"2020-01-18T18:53:44.000Z","comments":true,"path":"2018/04/15/Go_reflect/","link":"","permalink":"http://www.taroballz.com/2018/04/15/Go_reflect/","excerpt":"Introduction 反射，是指電腦程序在運行時(Run Time)可以訪問、檢測和修改它本身狀態或行為的一種能力。 程序在運行時能夠觀察並修改自己的行為 可以在運行時動態的獲取變量的相關信息，包括類型與值 在Golang中有提供官方的package可實現反射 主要有兩個函數 reflect.TypeOf:獲取變量的類型，返回reflect.Type類型 reflect.ValueOf:獲取變量的值，返回reflect.Value類型 reflect.Value.Kind:可以獲取變量的類別，返回一個常量 reflect.Value.Interface{}:轉換成interface{}(空接口)類型","text":"Introduction 反射，是指電腦程序在運行時(Run Time)可以訪問、檢測和修改它本身狀態或行為的一種能力。 程序在運行時能夠觀察並修改自己的行為 可以在運行時動態的獲取變量的相關信息，包括類型與值 在Golang中有提供官方的package可實現反射 主要有兩個函數 reflect.TypeOf:獲取變量的類型，返回reflect.Type類型 reflect.ValueOf:獲取變量的值，返回reflect.Value類型 reflect.Value.Kind:可以獲取變量的類別，返回一個常量 reflect.Value.Interface{}:轉換成interface{}(空接口)類型 TypeOf動態的獲取變量的類型1func TypeOf (i interface&#123;&#125;) Type 可看到reflect.TypeOf接受空接口類型的參數，並返回reflect.Type類型 123456789101112131415161718192021package mainimport ( \"fmt\" \"reflect\")//空接口接受任何類型func test(b interface&#123;&#125;)&#123; //獲取傳參的類型 tp := reflect.TypeOf(b) fmt.Println(\"b type:\",tp) fmt.Printf(\"tp type: %T\",tp)&#125;func main()&#123; a := 100 test(a)&#125; result12b type: inttp type: *reflect.rtype 透過reflect.TypeOf可直接獲取傳參進來的空接口為何種類型，但儲存類型的變量是reflect.Type類型 ValueOf 透過reflect.ValueOf函數可將空接口變量轉換成reflect.Value類型 reflect.Value類型擁有很多方法，可獲取變量的相關信息(分析變量) 1func ValueOf (i interface&#123;&#125;) Value 可看到reflect.ValueOf接受空接口類型的參數，並返回reflect.Value類型 1234567891011121314151617package mainimport ( \"fmt\" \"reflect\")func test(b interface&#123;&#125;)&#123; vl := reflect.ValueOf(b) fmt.Println(\"b value:\",vl) fmt.Printf(\"vl type: %T\",vl)&#125;func main()&#123; a := 100 test(a)&#125; result 12b value: 100vl type: reflect.Value 可看到其返回的類型為reflect.Value類型 .Kind() 查看變量類別 reflect.Value類型的變量可調用.Kind()方法查看變量的類別 返回的是變量的類別，返回一個常量(reflect.類別) 請注意類別與類型不一樣 123456type Student struct&#123; Name string Age int&#125;a := Student&#123;&#125; a變量為自訂義的Student類型 a變量的類別為結構體(struct) example12345678910111213141516171819202122232425262728293031package mainimport ( \"fmt\" \"reflect\")type Student struct &#123; Name string Age int&#125;func test(b interface&#123;&#125;)&#123; tp := reflect.TypeOf(b) fmt.Println(\"b type:\",tp) vl := reflect.ValueOf(b) fmt.Println(\"b value:\",vl) l := vl.Kind() fmt.Printf(\"b kind: %v\\n\",l)&#125;func main()&#123; a := Student&#123; Name : \"Curtis\", Age : 18, &#125; test(a)&#125; result123b type: main.Studentb value: &#123;Curtis 18&#125;b kind: struct .interface() 轉換成空接口類型 reflect.Value類型的變量可調用.interface()方法將類型轉換成interface{}類型 interface{}空接口類型又可透過類型斷言，將變量從空接口轉成具體類型 example12345678910111213141516171819202122232425262728293031323334353637package mainimport ( \"fmt\" \"reflect\")type Student struct &#123; Name string Age int&#125;func test(b interface&#123;&#125;)&#123; vl := reflect.ValueOf(b) fmt.Println(\"b value:\",vl) //使用ValueOf獲取值時,類型為reflect.Value類型 fmt.Printf(\"vl type: %T\\n\",vl) //reflect.Value類型的變量可調用interface()方法，將變量轉成interface&#123;&#125;類型 interfacE := vl.Interface() //透過安全的類型斷言，將interface&#123;&#125;類型轉成變量的具體類型 stu,ok := interfacE.(Student) if ok &#123; fmt.Printf(\"vl.interface().type:%T\\n\",stu) &#125;&#125;func main()&#123; a := Student&#123; Name : \"Curtis\", Age : 18, &#125; test(a)&#125; result123b value: &#123;Curtis 18&#125;vl type: reflect.Valuevl.interface().type:main.Student 獲取變量的值reflect.Value類型可使用內置的方法，獲取變量的值 1234reflect.ValueOf(x).Float()reflect.ValueOf(x).Int()reflect.ValueOf(x).String()reflect.ValueOf(x).Bool() 根據值不同的類型，獲取其值 要是空接口傳進來的值為int類型，透過reflect.ValueOf()函數轉成reflect.Value類型若使用reflect.Value類型可調用的String()方法獲取一開始具體類型為int的值則會獲取不到相對應的值 example123456789101112131415161718package mainimport ( \"fmt\" \"reflect\")func test(b interface&#123;&#125;)&#123; vl := reflect.ValueOf(b) fmt.Printf(\"vl.Int(): %d\\n\",vl.Int()) fmt.Printf(\"vl.String(): %s\\n\",vl.String())&#125;func main()&#123; a := 100 test(a)&#125; result12vl.Int(): 100vl.String(): &lt;int Value&gt; 因從b參數傳進來的類型為int類型，將其轉成string類型時獲取不到值 設置變量的值reflect.Value類型可使用內置的方法，設置變量的值 其方法通常為Set類型作為方法名 只有reflect.Value的類型可以調用 注意!!!欲設置的值應為外部變量，因此傳參需傳入指針類型，否則panic 需搭配Elem()方法設置指針變量內部之值，相當於具體類型的* 1234reflect.ValueOf(x).Elem().SetFloat() reflect.ValueOf(x).Elem().SetInt()reflect.ValueOf(x).Elem().SetString()reflect.ValueOf(x).Elem().SetBool() example123456789101112131415161718192021package mainimport ( \"fmt\" \"reflect\")func test(b interface&#123;&#125;)&#123; val := reflect.ValueOf(b) val.Elem().SetInt(10000) //[1] //指針在取值時須加上*，這邊仍適用Elem()代替* c := val.Elem().Int() fmt.Println(\"c =\",c)&#125;func main()&#123; a := 100 test(&amp;a) fmt.Println(\"a =\",a)&#125; [1] Elem()函數為reflect.Value類型可調用的方法是向傳進來具體類型的指針指向的地址取值，相當於* 12var x *int = new(int)*x = 100 Elem()就類似於變量前面加上* result12c = 10000a = 10000 操作結構體 reflect.Value類型可使用內置的方法，操作結構體 其傳進來的空接口必須指向的是結構體類別，才能操作 .NumField() 查看結構體的字段數1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( \"fmt\" \"reflect\")type Student struct &#123; Name string Age int score float64&#125;func StructOP(b interface&#123;&#125;)&#123; val := reflect.ValueOf(b) c := val.Kind() //查看參數的類別為何 // 判斷是否為struct 不是struct類別則退出 // reflect.Struct 為一常量 if c != reflect.Struct&#123; fmt.Println(\"parameter isn't belong with a struct\") return &#125; num_property := val.NumField() fmt.Println(num_property) return&#125;func main()&#123; Tom := Student&#123; Name : \"Tom\", Age : 100, score: 60.0, &#125; StructOP(Tom)&#125; result13 tips reflect.Value類型亦能調用.Field(n) 方法顯示字段信息， n為第n個字段 若傳入為struct的指針類型，記得使用Elem().Field(n)方法顯示字段信息 字段的信息仍為reflect.Value類型，仍可對字段進行動態分析，或對字段進行操作 透過Elem().Field(n).Set類型(值)便可以對外部struct中的字段修改值 .NumMethod() 查看結構體的方法數123456789101112131415161718192021222324252627282930313233343536373839404142434445package mainimport ( \"fmt\" \"reflect\")type Student struct &#123; Name string Age int score float64&#125;//方法1func (self *Student)Reading()&#123; fmt.Println(\"Reading Books\")&#125;//方法2func (self *Student)Write()&#123; fmt.Println(\"Writing\")&#125;func StructOP(b interface&#123;&#125;)&#123; val := reflect.ValueOf(b) c := val.Elem().Kind() //注意指針類型取值使用Elem() if c != reflect.Struct&#123; fmt.Println(\"parameter isn't belong with a struct\") return &#125; num_Method := val.NumMethod() //* fmt.Println(num_Method)&#125;func main()&#123; Tom := Student&#123; Name : \"Tom\", Age : 100, score: 60.0, &#125; StructOP(&amp;Tom)&#125; result12 .Method(n).Call 調用結構體中的方法 n代表的是調用第n個方法 使用Call方法時須先初始化一個reflect.Value類型的切片，或直接傳入nil 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mainimport ( \"fmt\" \"reflect\")type Student struct &#123; Name string Age int score float64&#125;func (self *Student)Reading()&#123; fmt.Println(\"Reading Books\")&#125;func (self *Student)Write()&#123; fmt.Println(\"Writing\")&#125;func StructOP(b interface&#123;&#125;)&#123; val := reflect.ValueOf(b) c := val.Elem().Kind() if c != reflect.Struct&#123; fmt.Println(\"parameter isn't belong with a struct\") return &#125; //使用Call方法時必須先初始化一個reflect.Value類型的切片 var method_slice = make([]reflect.Value,0) //調用結構體的第一個方法 val.Method(0).Call(method_slice) //調用結構體的第二個方法,Call函數的參數可傳入nil val.Method(1).Call(nil)&#125;func main()&#123; Tom := Student&#123; Name : \"Tom\", Age : 100, score: 60.0, &#125; StructOP(&amp;Tom)&#125; result12Reading BooksWriting Tag在之前json的打包中，我們遍歷結構體時，透過json作為key找到其value作為結構體的字段名其具體也是透過反射做到的 調用Tag方法必須為reflect.Type類型 且Tag的類型為reflect.StructTag類型，可調用Get()方法尋找key對應的value為何 12345678910111213141516171819202122232425262728293031package mainimport ( \"reflect\" \"fmt\")type Car struct&#123; Name string `json:\"car_name\"` Age int Price float64&#125;func main()&#123; Benz := &amp;Car&#123; Name : \"Benz\", Age : 20, Price : 10000.00, &#125; typ := reflect.TypeOf(Benz) //獲取第0個字段的Tag tag := typ.Elem().Field(0).Tag //其類型為reflect.StructTag類型 fmt.Printf(\"tag type = %T\\n\",tag) //使用Get()函數中的參數為key值，返回對應的value fmt.Println(\"tag =\",tag.Get(\"json\"))&#125; result12tag type = reflect.StructTagtag = car_name json就是利用反射，得到tag的key為”json”，其對應的value 優先進行打包","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"json","slug":"json","permalink":"http://www.taroballz.com/tags/json/"},{"name":"反射(reflect)","slug":"反射-reflect","permalink":"http://www.taroballz.com/tags/反射-reflect/"}]},{"title":"Golang物件導向初識-day19-接口嵌套、類型斷言","slug":"Go_interface_2","date":"2018-04-11T16:00:00.000Z","updated":"2018-04-11T17:20:46.000Z","comments":true,"path":"2018/04/12/Go_interface_2/","link":"","permalink":"http://www.taroballz.com/2018/04/12/Go_interface_2/","excerpt":"接口嵌套 (接口繼承)一個接口可以嵌套在另外的接口，如下所示","text":"接口嵌套 (接口繼承)一個接口可以嵌套在另外的接口，如下所示 範例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package mainimport \"fmt\"type ReadWrite interface &#123; Read() Write()&#125;type Lock interface &#123; Lock() Unlock()&#125;//File接口 包含ReadWrite及Lock兩接口type File interface &#123; ReadWrite Lock close()&#125;//函數傳參的接收類型為 File接口類型，只要自訂義的類型實現File接口的所有方法//其自定義類型實例化的變量 就能作為參數傳進此函數並調用此函數func File_operate(f File)&#123; f.Write() f.Read() f.Lock() f.Unlock() f.close()&#125;type Test struct &#123; Name string&#125;//以下 Test類型 實現了File接口的所有方法func (self Test) Read()&#123; fmt.Println(\"Read....\")&#125;func (self Test) Write()&#123; fmt.Println(\"Write....\")&#125;func (self Test) Lock()&#123; fmt.Println(\"File Lock !!\")&#125;func (self Test) Unlock()&#123; fmt.Println(\"File Unlock !!\")&#125;func (self Test) close()&#123; fmt.Println(\"File close...\")&#125;func main()&#123; //因 Test類型實現了File接口的所有方法 //所以Test類型實例化的變量test亦為File接口類型 //所以test變量可作為參數傳入File_operate函數，並調用適用此接口類型的方法或函數 var test Test File_operate(test)&#125; 一種接口類型可放到其他接口類型中 若要實現File接口，則ReadWrite及Lock接口的所有方法及close()方法都必須實現 類似結構體嵌套匿名結構體 result12345Write....Read....File Lock !!File Unlock !!File close... 類型斷言 (類型轉換) 由於接口是一般類型，並不知道具體類型 任何類型只要滿足a接口內所有的方法，該類型亦為a接口類型 再調用函數時，參數接受a接口類型時，並不知道傳參進來的a接口指向的是何種類型的實例(如上範例) 要是接口指向的是非期望的類型需進行類型轉換再操作 此時便需做類型斷言 如要轉成具體類型可採用以下方式進行轉換 不安全的類型斷言1234var t intvar x interface&#123;&#125;x = ty = x.(int) //將x空接口強轉成int類型 範例123456789101112131415161718package mainimport \"fmt\"//a形參接受任何類型的參數(空接口可接受任何類型)func add (a interface&#123;&#125;)&#123; //將a斷言為int類型，並賦值給b //將接口類型轉為int類型，傳進來的參數也必須為int類型才能轉換，否則panic b := a.(int) //[1] b += 3 fmt.Println(b)&#125;func main()&#123; a := 100 add(a)&#125; [1] 要是傳進來的參數不為int類型時，斷言為int將會panic，因此需要安全的類型斷言 安全的類型斷言在進行斷言之前會先檢查是否能轉換1234var t intvar x interface&#123;&#125;x = ty,ok =x.(int) //將x轉成int，並帶檢查 範例123456789101112131415161718package mainimport \"fmt\"func add (a interface&#123;&#125;)&#123; b , ok := a.(int) //如果ok返回是true則可成功類型轉換 if ok == false &#123; fmt.Println(\"assertion Error\") return &#125; b += 3 fmt.Println(b)&#125;func main()&#123; a := 1000 add(a)&#125; 判斷傳參的類型(利用switch斷言)使用switch判斷傳入參數的類型123456789101112131415161718192021222324package mainimport ( \"fmt\")func determine_type (a ...interface&#123;&#125;)&#123; for i,x := range a&#123; switch x.(type)&#123; case bool: fmt.Println(\"number\",i,\"type is bool\") case int: fmt.Println(\"number\",i,\"type is integer\") case string: fmt.Println(\"number\",i,\"type is string\") case nil: fmt.Println(\"number\",i,\"type is nil\") case int64: fmt.Println(\"number\",i,\"type is int64\") case float64,float32: fmt.Println(\"number\",i,\"type is float\") default: fmt.Println(\"I don't know what's the type of\",i) &#125; &#125;&#125;func main()&#123; determine_type(\"a\",int64(133),true,false,\"abcd\",'c',123456,333.3333)&#125; 須注意x.(type)這樣的用法，用來作類型斷言的判斷非常好用 也可用來判斷自定義的類型，如struct、指針類型等 result12345678number 0 type is stringnumber 1 type is int64number 2 type is boolnumber 3 type is boolnumber 4 type is stringI don&apos;t know what&apos;s the type of 5number 6 type is integernumber 7 type is float tips 類型斷言不一定是只拿某個接口類型的變量判斷是否能轉成其他類型 其他類型的變量也能拿來判斷是否實現了接口 (比較少用) practice 實現一個可存放任何類型data的鏈表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package mainimport \"fmt\"type data_save struct &#123; data interface&#123;&#125; next *data_save&#125;type record_pointer struct &#123; Head *data_save Tail *data_save&#125;func (self *record_pointer)InsertHead_CreateNode(data interface&#123;&#125;)&#123; Node := &amp;data_save&#123;&#125; Node.data = data if self.Head == nil &amp;&amp; self.Tail ==nil &#123; self.Head = Node self.Tail = Node return &#125; Node.next = self.Head self.Head = Node&#125;func (self *record_pointer)InsertTail_CreateNode(data interface&#123;&#125;)&#123; Node := &amp;data_save&#123;&#125; Node.data = data if self.Head == nil &amp;&amp; self.Tail ==nil &#123; self.Head = Node self.Tail = Node return &#125; self.Tail.next = Node self.Tail = Node&#125;func (self *record_pointer)view()&#123; var p *data_save = self.Head for p != nil &#123; fmt.Println(*p) p = p.next &#125;&#125;func main()&#123; var a record_pointer for i:=0;i&lt;10;i++&#123; a.InsertTail_CreateNode(i) &#125; a.view()&#125; 只要存放的data接受空接口類型(interface{})，就能存放任何類型的變量 result12345678910&#123;0 0xc04205a400&#125;&#123;1 0xc04205a420&#125;&#123;2 0xc04205a440&#125;&#123;3 0xc04205a460&#125;&#123;4 0xc04205a480&#125;&#123;5 0xc04205a4a0&#125;&#123;6 0xc04205a4c0&#125;&#123;7 0xc04205a4e0&#125;&#123;8 0xc04205a500&#125;&#123;9 &lt;nil&gt;&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"接口(interface)","slug":"接口-interface","permalink":"http://www.taroballz.com/tags/接口-interface/"},{"name":"多態","slug":"多態","permalink":"http://www.taroballz.com/tags/多態/"},{"name":"結構體(struct)","slug":"結構體-struct","permalink":"http://www.taroballz.com/tags/結構體-struct/"},{"name":"類型斷言","slug":"類型斷言","permalink":"http://www.taroballz.com/tags/類型斷言/"},{"name":"鏈表(Linked list)","slug":"鏈表-Linked-list","permalink":"http://www.taroballz.com/tags/鏈表-Linked-list/"}]},{"title":"Golang物件導向初識-day18-接口(interface)","slug":"Go_interface_1","date":"2018-04-10T16:00:00.000Z","updated":"2018-04-10T16:41:28.000Z","comments":true,"path":"2018/04/11/Go_interface_1/","link":"","permalink":"http://www.taroballz.com/2018/04/11/Go_interface_1/","excerpt":"實現 String()方法如果一個變量實現了String()這個方法，那麼fmt.Printf默認會調用這個變量的String()進行輸出","text":"實現 String()方法如果一個變量實現了String()這個方法，那麼fmt.Printf默認會調用這個變量的String()進行輸出 123456789101112131415161718192021222324package mainimport \"fmt\"type ClassRoom struct &#123; Name string Teacher string RoomNum int&#125;func (self *ClassRoom)String()string&#123; result := fmt.Sprintf(\"%s Class %d - %s\",self.Name,self.RoomNum,self.Teacher) return result&#125;func main()&#123; var chem *ClassRoom = &amp;ClassRoom&#123;&#125; chem.Name = \"Chemistry\" chem.Teacher = \"Dr.Chang\" chem.RoomNum = 101 //調用fmt.Printf方法，格式化輸出會調用String方法 fmt.Printf(\"%s\",chem)&#125; result1Chemistry Class 101 - Dr.Chang 以上為一接口的實現 定義 Interface為一種類型可以定義多個方法，但是本身不需要實現，由調用接口者實現 Interface不能包含任何字段、變量 Interface類型默認就是一個指針 12345678910type 接口名 interface&#123; 方法1(參數列表) 返回值列表 方法2(參數列表) 返回值列表 ...&#125;type Test interface&#123; Print() Sleep()&#125; 只要某個類型實現了Print()及Sleep()這兩個方法，這個類型也同時實現了Test這個接口 要是接口裡定義多個方法，某個類型也要同時實現這些多個方法，才算是實現接口 不能部份實現方法(只實現一種方法)，必須全部實現 空接口 要是接口裡沒有任任何方法，我們稱為空接口 任何類型皆實現空接口 (空接口能指向任何類型) 123456789101112package mainimport \"fmt\"func main()&#123; var a interface&#123;&#125; //聲明一個空接口 var b int //空接口指向int類型的實例化變量b a = b fmt.Printf(\"%T\",a)&#125; result1int 接口調用 Goalng中的接口，不需要顯式的實現(只要自定義的類型裡，方法名、參數、返回類型有對上即可) 只要某種類型實現接口裡的所有方法，就可以將實例化的接口變量指向某種類型，並使用實例化的接口調用方法 example123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package mainimport( \"fmt\")//定義car接口，裡面只有一個方法run()type car interface &#123; run()&#125;type Bike struct&#123; Name string Speed int&#125;//Bike實現了car接口裡的所有方法，因此亦實現了car接口func (self *Bike) run() &#123; fmt.Println(\"Bike running\")&#125;type Train struct &#123; Name string Speed int&#125;//Train實現了car接口裡的所有方法，因此亦實現了car接口func (self *Train)run()&#123; fmt.Println(\"Train running\")&#125;func main()&#123; //實例化一個Bike類型 var Giant Bike Giant.Name = \"Giant\" Giant.Speed = 20 //實例化一個Train類型 var Tze_Chiang Train Tze_Chiang.Name = \"Tze_Chiang\" Tze_Chiang.Speed = 2000 //實例化一個car類型的接口(car_interface為接口類型的變量) var car_interface car //將實例化的接口(就是一個指針)指向實例化的Bike類型 car_interface = &amp;Giant //調用方法 car_interface.run() car_interface = &amp;Tze_Chiang car_interface.run()&#125; result12Bike runningTrain running 實現多接口 如果一個變量含有了多個interface類型的方法，那麼這個變量就實現了多個接口 example12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport \"fmt\"type Message interface&#123; Send() Receive()&#125;type call interface&#123; Call()&#125;type cellphone struct &#123; Name string price int&#125;func (self *cellphone)Send()&#123; fmt.Println(\"SendMessage\")&#125;func (self *cellphone)Receive()&#123; fmt.Println(\"ReceiveMessage...\")&#125;func (self *cellphone)Call()&#123; fmt.Println(\"Calling....\")&#125;func main()&#123; var Nokia *cellphone = &amp;cellphone&#123; Name:\"Nokia\", price : 100, &#125; var message Message //Nokia實現了message的接口 message = Nokia message.Send() message.Receive() var c call //Nokia亦實現了call的接口 c = Nokia c.Call()&#125; Nokia變量實現了多個接口 result123SendMessageReceiveMessage...Calling.... tips struct中必須全部實踐interface的所有方法 才算是成功調用接口 (不能部分實踐) 實例化的接口 可以指向多種不同的實例化類型 (多態) 排序每種不同的類型，皆有排序的需求，因此將排序的功能做成一個接口只要實現排序接口的各個方法就能實現排序的功能Golang中的sort package也有這樣的接口https://golang.org/pkg/sort/ 123456789type Interface interface &#123; // Len is the number of elements in the collection. Len() int // Less reports whether the element with // index i should sort before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int)&#125; example12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package mainimport ( \"fmt\" \"math/rand\" \"sort\")type Interface interface&#123; Len() int Less(i,j int)bool Swap(i,j int)&#125;type Student struct&#123; Name string ID int Age int score float64&#125;//接口是針對特定類型的 因此需定義一個Student切片的別名type StudentArray []Student//以下為實現Sort包中Interface的三個方法func (self StudentArray)Len()int&#123; return len(self)&#125;//按照ID由小到大排序func (self StudentArray)Less(i,j int)bool&#123; return self[i].ID &lt; self[j].ID&#125;func (self StudentArray)Swap(i,j int)&#123; self[i],self[j] = self[j],self[i]&#125;func main()&#123; Tom := Student&#123; Name : \"Tom\", ID : rand.Intn(10000), Age : 18, score : 60.0, &#125; Amy := Student&#123; Name : \"Amy\", ID : rand.Intn(10000), Age : 17, score : 70.0, &#125; Tony := Student&#123; Name : \"Tony\", ID : rand.Intn(10000), Age : 16, score : 80.0, &#125; Student_list := make(StudentArray,3) Student_list[0] = Tom Student_list[1] = Amy Student_list[2] = Tony fmt.Println(\"Before Sort:\",Student_list) //因為StudentArray類型實現了Interface這個接口 //因此可直接傳入StudentArray類型的變量 sort.Sort(Student_list) fmt.Println(\"After Sort:\",Student_list)&#125; 可依照自己的需求 調整自訂義類型的排序方法 result12Before Sort: [&#123;Tom 8081 18 60&#125; &#123;Amy 7887 17 70&#125; &#123;Tony 1847 16 80&#125;]After Sort: [&#123;Tony 1847 16 80&#125; &#123;Amy 7887 17 70&#125; &#123;Tom 8081 18 60&#125;] tips 只要實現sort包中Interface這個接口的規範，任何自訂義類型接能調用此接口使用sort.Sort()方法排序","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"接口(interface)","slug":"接口-interface","permalink":"http://www.taroballz.com/tags/接口-interface/"},{"name":"多態","slug":"多態","permalink":"http://www.taroballz.com/tags/多態/"},{"name":"結構體(struct)","slug":"結構體-struct","permalink":"http://www.taroballz.com/tags/結構體-struct/"},{"name":"排序(sort)","slug":"排序-sort","permalink":"http://www.taroballz.com/tags/排序-sort/"}]},{"title":"Golang物件導向初識-day17-結構體方法2","slug":"Go_struct_method_","date":"2018-04-09T16:00:00.000Z","updated":"2018-04-10T16:05:38.000Z","comments":true,"path":"2018/04/10/Go_struct_method_/","link":"","permalink":"http://www.taroballz.com/2018/04/10/Go_struct_method_/","excerpt":"方法 結構體(struct)可認為是其他語言的類(class)，亦可定義適用於此結構體的方法 Golang中的方法是作用在特定類型的變量上 方法仍是透過方法名的大小寫來決定外部是否能調用，小寫的方法名為私有方法","text":"方法 結構體(struct)可認為是其他語言的類(class)，亦可定義適用於此結構體的方法 Golang中的方法是作用在特定類型的變量上 方法仍是透過方法名的大小寫來決定外部是否能調用，小寫的方法名為私有方法 定義12345678func (適用類型) 方法名 (參數列表) (返回值)&#123; 方法內容&#125;//例子:func (self *Student) print_info (Name string, Age int, Score float64)int&#123; &#125; 適用類型決定此方法適用於何種結構體類型 self為適用類型的實例，可自訂義為其他名字，方法會作用於 結構體或是類型本身 與定義函數沒有區別，最大的差異為適用此函數的類型需正確 example1234567891011121314151617181920212223242526272829303132package mainimport( \"math/rand\" \"fmt\")type Student struct&#123; Name string Age int score float64 ID int&#125;//接收指針類型的實例化對象func (self *Student)Stu_init(name string, age int, input_score float64,)int&#123; self.Name = name self.Age = age self.score = input_score self.ID = rand.Intn(1000) fmt.Println(*self) return self.ID&#125;func main()&#123; var Tom Student = Student&#123;&#125; //調用方法 實例化物件.方法即可調用 Tom_ID := Tom.Stu_init(\"Tom\",20,80) fmt.Println(Tom_ID)&#125; result12&#123;Tom 20 80 81&#125;81 tips 實例化對象最好在定義方法時傳入指針類型，否則再調用函數的時候，實例化的對象會因為是值類型，而無法連續操作 使用值類型傳參123456789101112131415161718192021222324252627282930313233package mainimport( \"math/rand\" \"fmt\")type Student struct&#123; Name string Age int score float64 ID int&#125;func (self Student)Stu_init(name string, age int, input_score float64,)int&#123; self.Name = name self.Age = age self.score = input_score self.ID = rand.Intn(1000) fmt.Println(self) return self.ID&#125;func (self Student)get()Student&#123; return self&#125;func main()&#123; var Tom Student = Student&#123;&#125; Tom_ID := Tom.Stu_init(\"Tom\",20,80) fmt.Println(Tom_ID) fmt.Println(Tom.get())&#125; result123&#123;Tom 20 80 81&#125;81&#123; 0 0 0&#125; 使用指針傳參123456789101112131415161718192021222324252627282930313233package mainimport( \"math/rand\" \"fmt\")type Student struct&#123; Name string Age int score float64 ID int&#125;func (self *Student)Stu_init(name string, age int, input_score float64,)int&#123; self.Name = name self.Age = age self.score = input_score self.ID = rand.Intn(1000) fmt.Println(*self) return self.ID&#125;func (self *Student)get()*Student&#123; return self&#125;func main()&#123; var Tom Student = Student&#123;&#125; Tom_ID := Tom.Stu_init(\"Tom\",20,80) fmt.Println(Tom_ID) fmt.Println(*Tom.get())&#125; 因方法的適用類型為指針類型，所以在調用函數時應(&amp;Tom).Stu_init()或是(&amp;Tom).get())調用 但是golang內部做了簡化，會自動判斷 前面的對象為何種類型傳入值類型或是指針類型 若適用方法為self Student則Tom.get()傳入為值類型 若適用方法為self *Student則Tom.get()默認就是(&amp;Tom).get()傳入指針類型 result123&#123;Tom 20 80 81&#125;81&#123;Tom 20 80 81&#125; 繼承與組合 (結構體之間的嵌套) 如果一個struct嵌套了另一個匿名結構體，那麼這個結構體可以直接訪問匿名結構體的方法，從而實現了繼承(可參考Golang物件導向初識-day16-結構體方法1 章節) 如果有一個struct嵌套了另一個有名結構體，那麼這個模式就叫做組合 example1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package mainimport( \"math/rand\" \"fmt\")// Classroom結構體 繼承了Student匿名結構體 及 組合了Tch結構體(Teacher類型)type Classroom struct&#123; Student Tch Teacher RoomNumber int&#125;type Teacher struct &#123; Name string Age int Major string&#125;func (self *Teacher) GetInfo()&#123; fmt.Println(\"Teacher Name:\",self.Name,\" age:\",self.Age,\" Major\",self.Major)&#125;type Student struct&#123; Name string Age int score float64 ID int&#125;func (self *Student)Stu_init(name string, age int, input_score float64,)int&#123; self.Name = name self.Age = age self.score = input_score self.ID = rand.Intn(1000) fmt.Println(*self) return self.ID&#125;func (self *Student)get()*Student&#123; return self&#125;func main()&#123; var One Classroom // Classroom 結構體調用了Student匿名字段中的方法 fmt.Println(\"John's ID=\",One.Stu_init(\"John\",18,60)) // Classroom 子類調用了父類Teacher組合的字段 One.Tch.Name = \"Teacher Chang\" One.Tch.Major = \"Chemistry\" One.Tch.Age = 40 // Classroom 子類調用了父類Teacher組合的方法 One.Tch.GetInfo()&#125; 一個子結構體嵌套了一個父匿名結構體，則子結構體實現了父結構體中所有的屬性及方法 亦可稱匿名字段是一種特殊的組合 一個子結構體嵌套了一個父有名結構體組合，則子結構體實現了父結構體中所有的屬性及方法 組合調用方法都必須加字段名 result123&#123;John 18 60 81&#125;John&apos;s ID= 81Teacher Name: Teacher Chang age: 40 Major Chemistry 多重繼承 一個struct嵌套了多個匿名結構體，此結構體可直接訪問多個匿名結構體的方法，就實現了多重繼承 要是兩個匿名結構體中有相同字段，且要訪問此字段時必須透過 實例化變量.匿名結構體類型.字段訪問 要是兩個匿名結構體之間皆為不同字段，要訪問字段時直接透過 實例化變量.字段訪問即可","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"結構體(struct)","slug":"結構體-struct","permalink":"http://www.taroballz.com/tags/結構體-struct/"}]},{"title":"Golang物件導向初識-day16-結構體方法1","slug":"Go_struct_METHOD","date":"2018-04-08T16:00:00.000Z","updated":"2018-04-10T10:28:58.000Z","comments":true,"path":"2018/04/09/Go_struct_METHOD/","link":"","permalink":"http://www.taroballz.com/2018/04/09/Go_struct_METHOD/","excerpt":"定義類型的別名 結構體是用戶單獨定義的類型，不能和其他Go內置類型進行強制轉換(如int,string等) 類型仍可透過type重新命名（別名），但是與原類型為不同類型1234type 原類型 類型別名type integer inttype stu Student 在定義struct的別名時，即使內部的字段（屬性）都相同，別名類型與原類型仍為不同類型 因此不同類型之間不能賦值也不能運算 若要是進行賦值及運算則必須強制轉換","text":"定義類型的別名 結構體是用戶單獨定義的類型，不能和其他Go內置類型進行強制轉換(如int,string等) 類型仍可透過type重新命名（別名），但是與原類型為不同類型1234type 原類型 類型別名type integer inttype stu Student 在定義struct的別名時，即使內部的字段（屬性）都相同，別名類型與原類型仍為不同類型 因此不同類型之間不能賦值也不能運算 若要是進行賦值及運算則必須強制轉換 工廠模式（構造函數）構造函數：對象不需要參數即可調用的構造函數。對象生成時如果沒有顯式地調用構造函數，則預設構造函數會被自動調用。可是在Golang中，並無構造函數存在因此需顯式的使用工廠模式調用自定義的構造函數 1234567891011121314151617181920212223package modeltype student struct &#123; Name string Age int Score float32&#125;func NewStudent(Name string, Age int, Score float32)*student&#123; var New *student = &amp;student&#123; Name : Name, Age : Age, Score : Score, &#125; return New&#125;//於main包調用model包中的自定義構造函數package mainfunc main()&#123; Tom := model.NewStudent(\"Tom\",18,90)&#125; struct中的tag tag 相當於struct中字段的原信息 我們可以為struct中的每個字段，在字段的類型後面寫上一個tag tag相當於這個字段的說明，編譯器會將tag儲存，並作為此字段的描述 這個tag可通過反射的機制獲取到 最常用的場景就是json的序列化與反序列化 通常json打包所使用的大部分都是小寫字母，但Go語言在包外要引用結構體內的字段需要首字大寫才能訪問,使用tag指定字段來調用struct 聲明tag1234type Student struct &#123; name string `NameFieldTag` age int `AgeFieldTag`&#125; json序列化與反序列化123456789101112131415161718192021222324252627282930package mainimport ( \"encoding/json\" \"fmt\")//透過tag反射找到字段type Student struct&#123; Name string `json:\"name\"` Age int `json:\"age\"`&#125;func main()&#123; var stu = Student&#123; Name : \"Tom\", Age : 18, &#125; //使用json package序列化 其返回的是字符數組( []bytes ) data ,err := json.Marshal(stu) if err != nil &#123; fmt.Println(\"json encoding failed:\",err) return &#125; //將打包完的訊息從[]bytes轉成string fmt.Println(string(data))&#125; result1&#123;&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:18&#125; 從結果可得知，我們所使用的json tag為小寫，透過外部的json package訪問到被打包的字段便是小寫的 亦剛好符合json大部分皆為小寫的需求 透過json key取得其對應的value 匿名字段結構體中的可以包含字段是只有類型，沒有名字，即匿名字段 example123456789101112//定義結構體type Car struct&#123; Name string Age int&#125;//於另一個結構體中包含Car結構體類型的數據，但不聲明字段type Train struct&#123; Car //匿名字段 Start time.Time int //匿名字段&#125; 訪問12345678910111213141516171819202122232425262728293031323334package mainimport ( \"fmt\" \"time\")type car struct &#123; Name string Age int&#125;type Train struct &#123; car start time.Time int Age int&#125;func main()&#123; //定義TzeChiang變量為Train類型 var TzeChiang Train //如匿名字段為結構體類型，且結構體中的字段唯一，可直接使用 實例化對象.字段訪問 TzeChiang.Name = \"TzeChiang\" //若不唯一，或是優先級次於原類型其他字段，可使用實例化對象.結構體類型.字段訪問 TzeChiang.car.Age = 30 //其他匿名字段亦可實例化對象.字段訪問 TzeChiang.int = 8757 fmt.Println(TzeChiang)&#125; result1&#123;&#123;TzeChiang 30&#125; &#123;0 0 &lt;nil&gt;&#125; 8757&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"結構體(struct)","slug":"結構體-struct","permalink":"http://www.taroballz.com/tags/結構體-struct/"},{"name":"json","slug":"json","permalink":"http://www.taroballz.com/tags/json/"}]},{"title":"Golang資料結構-day15-二元樹(binary tree)","slug":"Go_binarytree","date":"2018-04-05T16:00:00.000Z","updated":"2018-04-05T19:48:02.000Z","comments":true,"path":"2018/04/06/Go_binarytree/","link":"","permalink":"http://www.taroballz.com/2018/04/06/Go_binarytree/","excerpt":"introduction結構體會有一些自己的字段(屬性)但單一節點中定有兩個為自身指針類型的字段，分別指向左子樹及右子樹 最上方的節點稱為根節點 最下方未在指向任何節點的節點，稱為葉節點","text":"introduction結構體會有一些自己的字段(屬性)但單一節點中定有兩個為自身指針類型的字段，分別指向左子樹及右子樹 最上方的節點稱為根節點 最下方未在指向任何節點的節點，稱為葉節點 定義12345678910type Student struct &#123; //資訊域 Name string Age int Score float64 //指標域 Left *Student Right *Student&#125; 指標域的指針可為nil，不一定要指向其他節點 創建節點並插入子樹1234567891011121314151617181920212223242526272829303132333435363738394041424344package maintype Student struct &#123; Name string Age int score float64 Left *Student Right *Student&#125;func main()&#123; //創建節點 var Root *Student = &amp;Student&#123; Name : \"Tom\", Age : 20, score : 70.0, &#125; var Left Student = Student&#123; Name : \"Amy\", Age : 18, score : 60.0, &#125; //於根節點插入左子樹 Root.Left = &amp;Left var Right *Student = new(Student) Right.Name = \"Tommy\" Right.Age = 19 Right.score = 50 //於根節點插入右子樹 Root.Right = Right left_2 := Student&#123; Name : \"Tony\", Age : 50, score : 87.5, &#125; //於左子樹節點再插入左子樹 Left.Left = &amp;left_2&#125; 遍歷二元樹 二元樹可以拆分成無數個小二元樹，使用遞歸解決遍歷問題 深度優先遍歷 : 逐條分支遍歷 [V] 廣度優先遍歷 : 層層向外遍歷 前序遍歷先遍歷根節點資訊-前序遍歷123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package mainimport \"fmt\"type Student struct &#123; Name string Age int score float64 Left *Student Right *Student&#125;func traversal(Node *Student)&#123; //設定出口條件：當前節點為空則return if Node == nil &#123; return &#125; //1.遍歷根節點 fmt.Println(*Node) //2.遍歷左子樹 traversal(Node.Left) //3.遍歷右子樹 traversal(Node.Right)&#125;func main()&#123; var Root *Student = &amp;Student&#123; Name : \"Tom\", Age : 20, score : 70.0, &#125; var Left Student = Student&#123; Name : \"Amy\", Age : 18, score : 60.0, &#125; Root.Left = &amp;Left var Right *Student = new(Student) Right.Name = \"Tommy\" Right.Age = 19 Right.score = 50 Root.Right = Right left_2 := Student&#123; Name : \"Tony\", Age : 50, score : 87.5, &#125; Left.Left = &amp;left_2 //遍歷二元樹 traversal(Root)&#125; 中序遍歷先遍歷左(右)子樹節點的資訊，再遍歷根節點-中序遍歷12345678910111213141516func traversal(Node *Student)&#123; //設定出口條件：當前節點為空則return if Node == nil &#123; return &#125; //1.遍歷左子樹 traversal(Node.Left) //2.遍歷根節點 fmt.Println(*Node) //3.遍歷右子樹 traversal(Node.Right)&#125; 後序遍歷先遍歷左(右)子樹，再遍歷右(左)子樹，最後為根節點資訊-後序遍歷12345678910111213141516func traversal(Node *Student)&#123; //設定出口條件：當前節點為空則return if Node == nil &#123; return &#125; //1.遍歷左子樹 traversal(Node.Left) //2.遍歷右子樹 traversal(Node.Right) //3.遍歷根節點 fmt.Println(*Node)&#125; tips 根節點再不同時候遍歷，決定了為前序，中序、還是後序遍歷","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"結構體(struct)","slug":"結構體-struct","permalink":"http://www.taroballz.com/tags/結構體-struct/"},{"name":"二元樹(binary tree)","slug":"二元樹-binary-tree","permalink":"http://www.taroballz.com/tags/二元樹-binary-tree/"}]},{"title":"Golang資料結構-day14-鏈表(Linked list)","slug":"Go_linklist","date":"2018-04-04T16:00:00.000Z","updated":"2018-04-05T16:52:07.000Z","comments":true,"path":"2018/04/05/Go_linklist/","link":"","permalink":"http://www.taroballz.com/2018/04/05/Go_linklist/","excerpt":"introduction 結構體會有一些自己的字段，但其中有一個字段，是指向自己結構體類型的指針類型 使用此結構體做為類型的變量，被稱為節點 每個節點包含下一個節點的地址，這樣可把所有的節點都串起來 通常鏈表中的第一個節點被叫做鏈表頭https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8","text":"introduction 結構體會有一些自己的字段，但其中有一個字段，是指向自己結構體類型的指針類型 使用此結構體做為類型的變量，被稱為節點 每個節點包含下一個節點的地址，這樣可把所有的節點都串起來 通常鏈表中的第一個節點被叫做鏈表頭https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8 範例123456type Student struct&#123; Name string Age int Score float64 Next *Student //[1]&#125; [1] 結構體的前半部為結構體的一般字段(屬性)，Next字段的類型為自身結構體的指針 單向鏈表又稱單向連結串列，它包含兩個域一個資訊域(一般屬性)和一個指標域(Next字段)。指標域連結指向鏈表中的下一個節點，而最後一個節點則指向一個空值(nil)。透過Next字段可將使用同種結構體類型的變量全部遍歷 相當於使用一條繩子將所有結構體串起來 缺點：要遍歷整張鏈表，需記住鏈表頭的地址；從其他任一節點開始遍歷都無法完整查看整張鏈表 若將最後一個節點的next字段指向鏈表頭地址，則為循環單鏈表 鏈表與陣列陣列：在固定長度且連續內存空間中，通過index訪問各陣列內的元素鏈表：鏈表的內存空間分配不是連續的，元素之間串聯需通過指針，(Next字段)且鏈表的長度不固定，可隨時增加或減少 新增與插入節點-尾部插入法123456789101112131415161718192021222324252627282930313233package mainimport ( \"fmt\")type Student struct &#123; Name string Age int Score float64 Next *Student&#125;func main()&#123; //創建頭節點 var HeadNode *Student = &amp;Student&#123; Name : \"Curtis\", Age : 18, Score : 90.0, &#125; //創建第二節點 var SecondNode *Student = &amp;Student&#123; Name : \"Tom\", Age : 27, Score :60, //[1] &#125; //插入 第二節點地址 到 頭節點的Next字段中 HeadNode.Next = SecondNode&#125; [1] Next字段不寫的情況下默認為空 tips 請注意!!，此方法新增的節點都只能在末尾插入 讓末尾節點的Next字段，從原本指向空(nil)改成指向一個新的節點地址 遍歷鏈表的節點12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport ( \"fmt\")type Student struct &#123; Name string Age int Score float64 Next *Student&#125;func main()&#123; var HeadNode *Student = &amp;Student&#123; Name : \"Curtis\", Age : 18, Score : 90.0, &#125; var SecondNode *Student = &amp;Student&#123; Name : \"Tom\", Age : 27, Score :60, &#125; HeadNode.Next = SecondNode //創建第三個節點 var ThirdNode Student ThirdNode.Name = \"Amy\" ThirdNode.Age = 20 ThirdNode.Score = 70 //插入第三個節點的地址 到第二個節點的Next字段 SecondNode.Next = &amp;ThirdNode //創建一個變量，接收節點資訊，並指向頭節點 view := HeadNode //只要節點中的資訊不為空，就會打印節點資訊 for view != nil&#123; fmt.Println(*view) //將欲查看的下個節點 指向 已查看完節點的Next字段 view = view.Next &#125;&#125; result123&#123;Curtis 18 90 0xc04206a1e0&#125;&#123;Tom 27 60 0xc04206a210&#125;&#123;Amy 20 70 &lt;nil&gt;&#125; 批量創建節點-尾部插入於main函數中實現1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mainimport ( \"fmt\" \"math/rand\")type Student struct &#123; Name string Age int Score float64 Next *Student&#125;func view(head *Student)&#123; for head != nil&#123; fmt.Println(*head) head = head.Next &#125;&#125;func main()&#123; var HeadNode *Student = &amp;Student&#123; Name : \"Curtis\", Age : 18, Score : 90.0, &#125; //定義一個變量記錄尾部節點的指針 tail := HeadNode for i:=0;i&lt;10;i++&#123; //創建新節點 Node := Student&#123; Name : fmt.Sprintf(\"Student%d\",i), Age : rand.Intn(100), Score : rand.Float64() * 100, &#125; //尾部節點的Next字段指向新節點的地址 tail.Next = &amp;Node //將尾部節點替換為新節點的地址，以獲取新節點的指針 tail = &amp;Node &#125; //遍歷鏈表節點 view(HeadNode)&#125; 函數化實現123456789101112131415161718192021222324252627282930313233343536373839404142434445package mainimport ( \"fmt\" \"math/rand\")type Student struct &#123; Name string Age int Score float64 Next *Student&#125;func view(head *Student)&#123; for head != nil&#123; fmt.Println(*head) head = head.Next &#125;&#125;//尾部插入法函數func loop_tail_insert(Node *Student)&#123; tail := Node for i:=0;i&lt;10;i++&#123; Node := Student&#123; Name : fmt.Sprintf(\"Student%d\",i), Age : rand.Intn(100), Score : rand.Float64() * 100, &#125; tail.Next = &amp;Node tail = &amp;Node &#125;&#125;func main() &#123; var HeadNode *Student = &amp;Student&#123; Name: \"Curtis\", Age: 18, Score: 90.0, &#125; loop_tail_insert(HeadNode) view(HeadNode)&#125; result1234567891011&#123;Curtis 18 90 0xc04206a210&#125;&#123;Student0 81 94.05090880450125 0xc04206a240&#125;&#123;Student1 47 43.771418718698015 0xc04206a270&#125;&#123;Student2 81 68.68230728671094 0xc04206a2a0&#125;&#123;Student3 25 15.651925473279125 0xc04206a2d0&#125;&#123;Student4 56 30.091186058528706 0xc04206a300&#125;&#123;Student5 94 81.36399609900968 0xc04206a330&#125;&#123;Student6 62 38.065718929968604 0xc04206a360&#125;&#123;Student7 28 46.88898449024232 0xc04206a390&#125;&#123;Student8 11 29.310185733681575 0xc04206a3c0&#125;&#123;Student9 37 21.855305259276427 &lt;nil&gt;&#125; 頭部插入法於main函數中實現123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package mainimport ( \"fmt\" \"math/rand\")type Student struct &#123; Name string Age int Score float64 Next *Student&#125;func view(head *Student)&#123; for head != nil&#123; fmt.Println(*head) head = head.Next &#125;&#125;func main()&#123; var HeadNode *Student = &amp;Student&#123; Name : \"Curtis\", Age : 18, Score : 90.0, &#125; //新建一個變量來記錄 原舊頭節點的指針 Head := HeadNode for i:=0;i&lt;10;i++&#123; //創建節點 NewNode := Student&#123; Name : fmt.Sprintf(\"stu%d\",i), Age : rand.Intn(100), Score : rand.Float64() * 100, //新的節點指向舊的頭節點 Next : Head, &#125; //將 舊的頭節點 替換成 新的頭節點 的指針 Head = &amp;NewNode &#125; //遍歷鏈表節點 view(Head)&#125; 函數化實現12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport ( \"fmt\" \"math/rand\")type Student struct &#123; Name string Age int Score float64 Next *Student&#125;func view(head *Student)&#123; for head != nil&#123; fmt.Println(*head) head = head.Next &#125;&#125;//頭部插入法函數func loop_head_insert(Node *Student)(*Student)&#123; Head := Node for i:=0;i&lt;10;i++&#123; NewNode := Student&#123; Name : fmt.Sprintf(\"stu%d\",i), Age : rand.Intn(100), Score : rand.Float64() * 100, Next : Head, &#125; Head = &amp;NewNode &#125; return Head&#125;func main()&#123; var HeadNode *Student = &amp;Student&#123; Name : \"Curtis\", Age : 18, Score : 90.0, &#125; NewHead := loop_head_insert(HeadNode) //遍歷鏈表節點 view(NewHead)&#125; result1234567891011&#123;stu9 37 21.855305259276427 0xc04206a3c0&#125;&#123;stu8 11 29.310185733681575 0xc04206a390&#125;&#123;stu7 28 46.88898449024232 0xc04206a360&#125;&#123;stu6 62 38.065718929968604 0xc04206a330&#125;&#123;stu5 94 81.36399609900968 0xc04206a300&#125;&#123;stu4 56 30.091186058528706 0xc04206a2d0&#125;&#123;stu3 25 15.651925473279125 0xc04206a2a0&#125;&#123;stu2 81 68.68230728671094 0xc04206a270&#125;&#123;stu1 47 43.771418718698015 0xc04206a240&#125;&#123;stu0 81 94.05090880450125 0xc04206a210&#125;&#123;Curtis 18 90 &lt;nil&gt;&#125; 刪除節點紀錄要被刪除節點的上一節點地址，並將上一節點的next字段替換為要刪除節點的next字段(亦就是下一節點的地址) 於main函數中實現1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package mainimport ( \"fmt\" \"math/rand\")type Student struct &#123; Name string Age int Score float64 Next *Student&#125;func view(head *Student)&#123; for head != nil&#123; fmt.Println(*head) head = head.Next &#125;&#125;func loop_tail_insert(Node *Student)&#123; tail := Node for i:=0;i&lt;10;i++&#123; Node := Student&#123; Name : fmt.Sprintf(\"Student%d\",i), Age : rand.Intn(100), Score : rand.Float64() * 100, &#125; tail.Next = &amp;Node tail = &amp;Node &#125;&#125;func main() &#123; var HeadNode *Student = &amp;Student&#123; Name: \"Curtis\", Age: 18, Score: 90.0, &#125; loop_tail_insert(HeadNode) //紀錄頭節點位置 Head := HeadNode //要刪除的節點特徵 choice := \"Curtis\" //遍歷節點找到要刪除的節點 for Head != nil&#123; //確定第一個節點是否為刪除的節點 if Head.Name == choice &#123; Head = Head.Next HeadNode = Head break //當前節點 的 下一節點的字段符合特徵 &#125; else if Head.Next.Name == choice&#123; //將當前節點的Next字段指向要被刪除節點的Next字段 Head.Next =Head.Next.Next break &#125; //否則當前節點 更新為 當前節點的Next字段指向的內存地址 Head = Head.Next &#125; //重新遍歷鏈表 view(HeadNode)&#125; 函數化實現1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package mainimport ( \"fmt\" \"math/rand\")type Student struct &#123; Name string Age int Score float64 Next *Student&#125;func view(head *Student)&#123; for head != nil&#123; fmt.Println(*head) head = head.Next &#125;&#125;func loop_tail_insert(Node *Student)&#123; tail := Node for i:=0;i&lt;10;i++&#123; Node := Student&#123; Name : fmt.Sprintf(\"Student%d\",i), Age : rand.Intn(100), Score : rand.Float64() * 100, &#125; tail.Next = &amp;Node tail = &amp;Node &#125;&#125;func del (Node *Student,choice string)*Student&#123; Head := Node for Head != nil&#123; if Head.Name == choice&#123; Head = Head.Next Node.Next = nil return Head &#125;else if Head.Next.Name == choice&#123; Head.Next =Head.Next.Next break &#125; Head = Head.Next &#125; return Node&#125;func main() &#123; var HeadNode *Student = &amp;Student&#123; Name: \"Curtis\", Age: 18, Score: 90.0, &#125; loop_tail_insert(HeadNode) //返回新節點 New_Node := del(HeadNode,\"Curtis\") view(New_Node)&#125; result12345678910&#123;Student0 81 94.05090880450125 0xc042074240&#125;&#123;Student1 47 43.771418718698015 0xc042074270&#125;&#123;Student2 81 68.68230728671094 0xc0420742a0&#125;&#123;Student3 25 15.651925473279125 0xc0420742d0&#125;&#123;Student4 56 30.091186058528706 0xc042074300&#125;&#123;Student5 94 81.36399609900968 0xc042074330&#125;&#123;Student6 62 38.065718929968604 0xc042074360&#125;&#123;Student7 28 46.88898449024232 0xc042074390&#125;&#123;Student8 11 29.310185733681575 0xc0420743c0&#125;&#123;Student9 37 21.855305259276427 &lt;nil&gt;&#125; 節點插入找到要被插入的節點，讓新節點指向原本的Next字段，在讓當前節點指向新節點 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package mainimport ( \"fmt\" \"math/rand\")type Student struct &#123; Name string Age int Score float64 Next *Student&#125;func view(head *Student)&#123; for head != nil&#123; fmt.Println(*head) head = head.Next &#125;&#125;func loop_tail_insert(Node *Student)&#123; tail := Node for i:=0;i&lt;10;i++&#123; Node := Student&#123; Name : fmt.Sprintf(\"Student%d\",i), Age : rand.Intn(100), Score : rand.Float64() * 100, &#125; tail.Next = &amp;Node tail = &amp;Node &#125;&#125;func insert (HeadNode *Student,InsertNode *Student,choice string)&#123; for HeadNode != nil &#123; if HeadNode.Name == choice &#123; InsertNode.Next = HeadNode.Next HeadNode.Next = InsertNode break &#125; HeadNode = HeadNode.Next &#125;&#125;func main() &#123; var HeadNode *Student = &amp;Student&#123; Name: \"Curtis\", Age: 18, Score: 90.0, &#125; loop_tail_insert(HeadNode) var InseretNode *Student = &amp;Student&#123; Name: \"Insert\", Age: 9, Score: 0.0, &#125; insert(HeadNode,InseretNode,\"Student5\") //重新遍歷鏈表 view(HeadNode)&#125; result123456789101112&#123;Curtis 18 90 0xc042074210&#125;&#123;Student0 81 94.05090880450125 0xc042074240&#125;&#123;Student1 47 43.771418718698015 0xc042074270&#125;&#123;Student2 81 68.68230728671094 0xc0420742a0&#125;&#123;Student3 25 15.651925473279125 0xc0420742d0&#125;&#123;Student4 56 30.091186058528706 0xc042074300&#125;&#123;Student5 94 81.36399609900968 0xc0420743f0&#125;&#123;Insert 9 0 0xc042074330&#125;&#123;Student6 62 38.065718929968604 0xc042074360&#125;&#123;Student7 28 46.88898449024232 0xc042074390&#125;&#123;Student8 11 29.310185733681575 0xc0420743c0&#125;&#123;Student9 37 21.855305259276427 &lt;nil&gt;&#125; 雙向鏈表每個節點有兩個連線：一個指向前一個節點(prev字段)，（當此「連線」為第一個「連線」時，指向空值(nil)或者空列表）而另一個指向下一個節點(next字段)，（當此「連線」為最後一個「連線」時，指向空值(nil)或者空列表） 在任何節點皆能遍歷整張列表","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"結構體(struct)","slug":"結構體-struct","permalink":"http://www.taroballz.com/tags/結構體-struct/"},{"name":"鏈表(Linked list)","slug":"鏈表-Linked-list","permalink":"http://www.taroballz.com/tags/鏈表-Linked-list/"}]},{"title":"Go初識-day13-包(package)、線程同步(sync)與atomic操作","slug":"Go_package_","date":"2018-04-03T16:00:00.000Z","updated":"2018-04-03T18:30:20.000Z","comments":true,"path":"2018/04/04/Go_package_/","link":"","permalink":"http://www.taroballz.com/2018/04/04/Go_package_/","excerpt":"包 (package) Golang目前約有150個標準包 官網有所有package的文檔 https://golang.org/pkg/ 第三方package的資源多位於github","text":"包 (package) Golang目前約有150個標準包 官網有所有package的文檔 https://golang.org/pkg/ 第三方package的資源多位於github 安裝第三方包再命令行輸入1go get github網址 會安裝第三方包，默認會安裝到%GOPATH%/src/ 中 線程同步 (sync) 與鎖 (lock) 多個線程之間可能同時使用同一個資源 資源在線程之間共享，加鎖可以使資源更安全的被取用或是寫入 但在進行只有讀取操作時，不加鎖可讓執行效率更高 情況一: 資源共享讀取寫入 — 不加鎖在不加鎖的情況下，開啟多個線程同時去對map操作 example123456789101112131415161718192021package mainimport ( \"fmt\")func goroutine_write(dic map[int]string)&#123; for i:=0;i&lt;5;i++&#123; go func(source map[int]string)&#123; source[1] = fmt.Sprintf(\"%d%d%d\",i,i,i) &#125;(dic) &#125; fmt.Println(dic)&#125;func main()&#123; a := make(map[int]string) a[1] = \"value1\" goroutine_write(a)&#125; result 11map[1:444] result 21map[1:555] result 31map[1:222] conclusion我們可以看到每次的結果都不一樣，證明了線程之間存在競爭關係 哪個線程得到最後修改的權限，值就會是該線程修改的結果 這不是理想執行的情況，會造成資源取用不安全在編譯時可透過-race參數來檢查是否存在線程競爭，如果存在，編譯完成後，執行時會發出警告1go build -race go_dev/day12/example/example_sync 情況二: 資源共享讀取寫入 — 互斥鎖 互斥鎖：不管讀的線程 或是 寫的線程 每次都只能有一個線程進入到加鎖的代碼中去執行代碼 線程鎖相關的package於”sync”包中 var 變量 sync.Mutex: 定義一個”互斥鎖”類型 變量.Lock()：加鎖 變量.Unlock() :釋放鎖 123456789101112131415161718192021222324252627282930313233package mainimport ( \"fmt\" \"sync\" \"math/rand\" \"time\")var lock sync.Mutex //[1]func goroutine_write(dic map[int]int)&#123; for i:=0;i&lt;5;i++&#123; go func(source map[int]int)&#123; // 賦值寫入線程需加鎖 lock.Lock() source[1] = rand.Intn(100) lock.Unlock() //釋放鎖 &#125;(dic) &#125; //讀取線程也須加鎖 lock.Lock() fmt.Println(dic) lock.Unlock() time.Sleep(time.Second) //[2]&#125;func main()&#123; a := make(map[int]int) a[1] = 1 goroutine_write(a)&#125; [1] 定義一個變量lock為互斥鎖類型(sync.Mutex)[2] 不要讓主線程直接結束，故sleep一段時間之後等待子線程都執行完畢再結束 result1map[1:59] 情況三: 資源共享讀取寫入 — 讀寫鎖 讀寫鎖：一種特殊鎖，對共享資源訪問者劃分讀者和寫者，讀操作可並發重入，寫操作是互斥的。讀線程進到讀寫鎖中，其他 讀線程 仍能進入，但 寫線程 不能進入寫線程進到讀寫鎖中，其他 讀線程 不能進入，且 寫線程 亦不能進入 讀多寫少的情況下，讀寫鎖性能最高 var 變量 sync.RWMutex: 定義一個”讀寫鎖”類型 讀者鎖： 變量.RLock()：只有讀線程可以進入RLock鎖，且讀線程在執行時其他讀線程仍能進入鎖中，與RUnlock之間通常為讀取相關的操作 變量.RUnlock(): 釋放鎖 互斥鎖： 變量.Lock()：只有寫線程可以進入Lock鎖，且寫線程在執行時其他不管是讀或是寫線程皆無法進入鎖中，與Unlock之間通常為寫入相關的操作 變量.Unlock(): 釋放鎖 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( \"fmt\" \"sync\" \"math/rand\" \"time\")var RWlock sync.RWMutexfunc RWLock_test(dic map[int]int)&#123; //寫操作 for i:=0;i&lt;5;i++&#123; go func(source map[int]int)&#123; RWlock.Lock() //只有寫線程可以進入.Lock()鎖，其他讀寫線程皆無法進入 source[1] = rand.Intn(100) RWlock.Unlock() &#125;(dic) &#125; //讀操作 for i:=0;i&lt;100;i++&#123; go func (read map[int]int)&#123; RWlock.RLock() //只有讀線程可以進入.RLock()鎖，且讀線程在執行時其他讀線程仍能繼續執行 fmt.Println(read) RWlock.RUnlock() &#125;(dic) &#125; time.Sleep(time.Second*10)&#125;func main()&#123; a := make(map[int]int) a[1] = 1 a[2] = 2 a[3] = 3 a[4] = 4 RWLock_test(a)&#125; result123456789map[1:81 2:2 3:3 4:4]map[4:4 1:81 2:2 3:3]map[1:81 2:2 3:3 4:4]map[1:81 2:2 3:3 4:4]map[1:81 2:2 3:3 4:4]...map[3:3 4:4 1:81 2:2] atomic package位於sync/atomic包中*atomic.AddInt相關函數，可讓整數同一時間只會有一個線程能修改此數，絕對不存在兩個或多個線程同時操作atomic.AddInt中的整數 使用atomic.AddInt可對同一時間併發多少線程記數 但是記數完時需要打印該值，仍會牽扯到線程互相競爭打印該值的問題 透過atomic.LoadInt相關函數，可直接讀取該值 用法拿int32類型作為示範123atomic.Addint32(int32類型整數的指針,每次增加的差值)atomic.LoadInt32(int32類型整數的指針) 其他方法可參考官方文檔 範例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport ( \"fmt\" \"sync\" \"math/rand\" \"time\" \"sync/atomic\")var RWlock sync.RWMutexfunc RWLock_test(dic map[int]int)&#123; var count int32 //聲明int32類型的count變量 //寫操作 for i:=0;i&lt;5;i++&#123; go func(source map[int]int)&#123; RWlock.Lock() source[1] = rand.Intn(100) RWlock.Unlock() &#125;(dic) &#125; //讀操作 for i:=0;i&lt;1000;i++&#123; go func (read map[int]int)&#123; RWlock.RLock() fmt.Println(read) RWlock.RUnlock() atomic.AddInt32(&amp;count,1) //於線程通過鎖時記數 &#125;(dic) &#125; time.Sleep(time.Second*5) fmt.Println(atomic.LoadInt32(&amp;count)) //讀取最新的記數值&#125;func main()&#123; a := make(map[int]int) a[1] = 1 a[2] = 2 a[3] = 3 a[4] = 4 RWLock_test(a)&#125; result12345678910map[1:81 2:2 3:3 4:4]map[2:2 3:3 4:4 1:81]map[1:81 2:2 3:3 4:4]map[1:81 2:2 3:3 4:4]map[1:81 2:2 3:3 4:4]...map[2:2 3:3 4:4 1:81]1000","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"多線程","slug":"多線程","permalink":"http://www.taroballz.com/tags/多線程/"},{"name":"包(package)","slug":"包-package","permalink":"http://www.taroballz.com/tags/包-package/"},{"name":"線程同步(sync)","slug":"線程同步-sync","permalink":"http://www.taroballz.com/tags/線程同步-sync/"},{"name":"atomic","slug":"atomic","permalink":"http://www.taroballz.com/tags/atomic/"}]},{"title":"Golang物件導向初識-day13-結構體(struct)","slug":"Go_struct","date":"2018-04-03T16:00:00.000Z","updated":"2018-04-05T06:18:36.000Z","comments":true,"path":"2018/04/04/Go_struct/","link":"","permalink":"http://www.taroballz.com/2018/04/04/Go_struct/","excerpt":"introduction 用來自定義複雜的數據結構，亦為一種自定義的類型(與golang自帶的int,string,map類型等價) struct可以包含多個字段，或稱屬性 struct類型可以定義方法，須注意和函數的區分 struct類型屬於值類型，因此要修改struct中的值，必須傳入指針 struct之間可以嵌套，自定義的struct中可再包含其他struct類型 Golang中沒有class類型，只有struct類型 可將struct類型當作class類型使用","text":"introduction 用來自定義複雜的數據結構，亦為一種自定義的類型(與golang自帶的int,string,map類型等價) struct可以包含多個字段，或稱屬性 struct類型可以定義方法，須注意和函數的區分 struct類型屬於值類型，因此要修改struct中的值，必須傳入指針 struct之間可以嵌套，自定義的struct中可再包含其他struct類型 Golang中沒有class類型，只有struct類型 可將struct類型當作class類型使用 定義struct用type定義一個自定義的類型，也包括自定義struct12345type struct名 struct &#123; 字段1 類型 字段2 類型 字段3 類型&#125; 結構體中可包含多個字段 example12345type Student struct &#123; Name string Age int Score float64&#125; 初始化初始化為空12345678910111213type Student struct &#123; Name string Age int Score float64&#125;func main()&#123; //聲明一個Student類型(struct)的變量 var A Student var AA Student = Student&#123;&#125;&#125; 當其初始化時字段皆為空 初始化時賦值1234567891011121314type Student struct &#123; Name string Age int Score float64&#125;func main()&#123; var B Student = Student&#123; Name : \"Jack\", //[1] Age : 20, Score: 89.5, //[1] &#125;&#125; [1] 字段之間賦值需用,隔開，最後字段也需以,結尾 tips 亦可初始化部分字段，未初始化的字段會為空 使用new初始化(返回指針)struct為值類型，也可使用new函數初始化 注意！返回的為指針類型 1234567891011type Student struct &#123; Name string Age int Score float64&#125;func main()&#123; var C *Student = new(Student) //[1] D := new(Student) &#125; [1] *Student為Student類型的指針 取址符&amp; 初始化(返回指針)123456789type Student struct &#123; Name string Age int Score float64&#125;func main()&#123; var E *Student = &amp;Student&#123;&#125; //[1]&#125; [1] E變量的值是使用&amp;取址；所以類型應為*Student，接收Student類型的指針 字段訪問上數有提到struct類型可當作class類型來使用所以要訪問struct中的字段(屬性)，與其他語言一樣，使用struct名.字段訪問及賦值 字段名為大寫是外部包可訪問的 字段名小寫表示為私有字段，外部不可訪問 12345678910111213141516171819202122232425262728293031323334package mainimport ( \"fmt\")type Student struct &#123; Name string Age int Score float64&#125;func print_info(name string,age int,score float64)&#123; fmt.Printf(\"%s's age is %d, he got %.1f point\\n\",name,age,score)&#125;func main()&#123; var A Student //使用 struct名.字段 賦值 A.Name = \"Tom\" A.Age = 18 A.Score = 90.0 var B Student = Student&#123; Name : \"Jack\", Age : 20, Score: 89.5, &#125; //使用 struct名.字段 訪問 print_info(A.Name,A.Age,A.Score) print_info(B.Name,B.Age,B.Score)&#125; result12Tom&apos;s age is 18, he got 90.0 pointJack&apos;s age is 20, he got 89.5 point 訪問指針類型的struct 字段照理來說訪問指針類型的struct 字段應為1(*變量).字段 但Golang做了簡化，會自動判斷是否為指針類型自動轉換所以即使使用 1變量.字段 仍能訪問 example123456789101112131415161718192021package mainimport ( \"fmt\")type Student struct &#123; Name string Age int Score float64&#125;func main()&#123; var E *Student = &amp;Student&#123;&#125; (*E).Name = \"Curtis\" E.Age = 18 E.Score = 100.0 fmt.Println(*E)&#125; result1&#123;Curtis 18 100&#125; struct的內存布局struct中所有的字段在內存都是連續的(與陣列相同)，布局如下 從圖中可以看到，即使結構體接收的為指針類型兩指針的存放的地址是連續的只是兩指針是指向不同的內存地址，指向的內存地址不連續而已 example1234567891011121314151617181920212223package mainimport ( \"fmt\")type Student struct &#123; Name string Age int Score float64&#125;func main()&#123; var E *Student = &amp;Student&#123; Name : \"Curtis\", Age : 20, Score : 80.0, &#125; fmt.Printf(\"Name:%p\\n\",&amp;E.Name) fmt.Printf(\"Age: %p\\n\",&amp;E.Age) fmt.Printf(\"Score:%p\\n\",&amp;E.Score)&#125; result123Name:0xc04205a3e0Age: 0xc04205a3f0Score:0xc04205a3f8","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"結構體(struct)","slug":"結構體-struct","permalink":"http://www.taroballz.com/tags/結構體-struct/"}]},{"title":"Go初識-day12-map類型(key-value pair)","slug":"Go_map","date":"2018-04-02T16:00:00.000Z","updated":"2018-04-02T19:33:10.000Z","comments":true,"path":"2018/04/03/Go_map/","link":"","permalink":"http://www.taroballz.com/2018/04/03/Go_map/","excerpt":"introductionkey-value的數據結構，又名關聯數組或是hash table在python中被稱為字典(dictionary) map本身是無序的 map的key是唯一的 map為引用類型","text":"introductionkey-value的數據結構，又名關聯數組或是hash table在python中被稱為字典(dictionary) map本身是無序的 map的key是唯一的 map為引用類型 聲明1var 變量名 map[key的類型]value的類型 聲明是不會分配內存的，只是聲明變量為map類型而已 必須初始化(make)才能使用 若無初始化，表示此變量並無內存空間存放，操作會發生panic example 112345var a map[string]stringvar a map[string]intvar a map[int]string example 21var map[string]map[string]string key為string類型 value為map類型 初始化make語法1變量 := make(map[key的類型]值的類型,容量) 容量可以不填寫，會有一個默認map所儲存的容量值，如超過容量值，會觸發內存重新分配 (效能降低) 容量值有填寫的情況下，會提前分配一個相對應容量值的內存空間 (效能較高) 可根據自己的需求定義容量會獲得比較好的效能 如果儲存的值一直沒有超過初始化的容量，就不會觸發內存重新分配，性能最高 12var a map[string]stringa = make(map[string]string) 可簡寫成1a := make(map[string]string) {}初始化12var a map[string]stringa = map[string]string&#123;&#125; 可簡寫成1a := map[string]string&#123;&#125; 聲明時並初始化1var a map[string]string = map[string]string&#123;\"1\":\"apple\",\"2\":\"banana\"&#125; 添加鍵值對、更新鍵值語法1變量[key] = value example1234567891011package mainimport \"fmt\"func main()&#123; var a map[string]string = map[string]string&#123;\"1\":\"apple\",\"2\":\"banana\"&#125; fmt.Println(\"initialize\",a) a[\"3\"] = \"cake\" a[\"1\"] = \"APPLE\" fmt.Println(\"modify\",a)&#125; result12initialize map[1:apple 2:banana]modify map[3:cake 1:APPLE 2:banana] 操作嵌套的map 在對第一層key1賦值時，其value也為map類型，不要忘記將value的map類型初始化 對第一層的其他key賦值時，value需再重新初始化12345678910111213141516171819202122232425package mainimport \"fmt\"func main()&#123; a := make(map[string]map[string]string) a[\"key1\"]= make(map[string]string) //賦值 a[\"key1\"][\"key1_1\"] = \"value1\" a[\"key1\"][\"key1_2\"] = \"value2\" //對第一層其他key賦值,需再重新初始化 a[\"key2\"] = make(map[string]string) //才能賦值 a[\"key2\"][\"key2_1\"] = \"value3\" //覺得以上稍嫌麻煩 //你可以直接使用&#123;&#125;方法直接多個賦值 a[\"key3\"] = map[string]string&#123;\"key3_1\":\"value4\",\"key3_2\":\"value5\"&#125; fmt.Println(a)&#125; result1map[key1:map[key1_1:value1 key1_2:value2] key2:map[key2_1:value3] key3:map[key3_1:value4 key3_2:value5]] 查找操作查找對應的key是不是在map中 語法1value,ok := name[key] example1234567891011121314151617package mainimport \"fmt\"func main()&#123; a := make(map[string]string) a[\"key1\"] = \"value1\" a[\"key2\"] = \"value2\" a[\"key3\"] = \"value3\" value,ok := a[\"key4\"] fmt.Println(\"key4_status:\",ok,\"key4_value:\",value) value2,ok2 := a[\"key3\"] fmt.Println(\"key3_status:\",ok2,\"key3_value:\",value2)&#125; result12key4_status: false key4_value: key3_status: true key3_value: value3 要是key存在於map類型的name中ok會返回true 且 value會返回key對應的值 要是key不存在於name中ok會返回false 且 value為空 遍歷使用for range遍歷 example123456789101112131415package mainimport \"fmt\"func main()&#123; a := make(map[string]string) a[\"key1\"] = \"value1\" a[\"key2\"] = \"value2\" a[\"key3\"] = \"value3\" for k,v := range a &#123; fmt.Println(k,\":\",v) &#125;&#125; result123key1 : value1key2 : value2key3 : value3 刪除 (delete)刪除map中的鍵使用delete內置函數刪除語法: delete(map,key) example123456789101112131415package mainimport \"fmt\"func main()&#123; a := make(map[string]string) a[\"key1\"] = \"value1\" a[\"key2\"] = \"value2\" a[\"key3\"] = \"value3\" delete(a,\"key1\") //* fmt.Println(a)&#125; result1map[key2:value2 key3:value3] 求長度求map的長度使用len(map) example12345678910111213package mainimport \"fmt\"func main()&#123; a := make(map[string]string) a[\"key1\"] = \"value1\" a[\"key2\"] = \"value2\" a[\"key3\"] = \"value3\" fmt.Println(\"length of map:\",len(a))&#125; result1length of map: 3 map為引用類型1234567891011121314151617181920212223package mainimport \"fmt\"func modify_map(aa map[string]string)&#123; aa[\"key1\"] = \"VALUE_ONE\" //*&#125;func main()&#123; a := make(map[string]string) a[\"key1\"] = \"value1\" a[\"key2\"] = \"value2\" a[\"key3\"] = \"value3\" fmt.Println(\"Before Modify:\") fmt.Println(a) modify_map(a) //* fmt.Println(\"Afer Modify:\") fmt.Println(a)&#125; result1234Before Modify:map[key3:value3 key1:value1 key2:value2]Afer Modify:map[key1:VALUE_ONE key2:value2 key3:value3] map類型的切片是允許的比較少人使用 example 112345678910package mainimport \"fmt\"type m map[int]string //[1]func main()&#123; a := []map[int]string&#123;m&#123;1:\"A\"&#125;,m&#123;2:\"B\"&#125;,m&#123;3:\"C\"&#125;&#125; fmt.Println(a)&#125; [1] 使用type將map[int]string類型取一個為m的別名 result1[map[1:A] map[2:B] map[3:C]] example 2123456789101112package mainimport \"fmt\"func main()&#123; a := make([]map[int]string,3) //[1] for i:=1;i&lt;=3;i++ &#123; a[i-1] = make(map[int]string) //[2] a[i-1][i] = string('A'+i-1) &#125; fmt.Println(a)&#125; [1] 用make初始化一切片[2] 搭配for循環將切片裡map類型的元素 逐一使用make初始化 result1[map[1:A] map[2:B] map[3:C]] map中的排序 map中的key是無序的 並沒有函數可以直接傳入map類型進行排序 先獲取map所有key，把key進行排序 按照排序好的key對map進行遍歷 1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( \"fmt\" \"sort\")func traversal(key_list []string,m map[string]string)&#123; for _,v := range key_list&#123; fmt.Println(v,\"-\",m[v]) &#125;&#125;func map_key_sort(aa map[string]string)[]string&#123; slice := make([]string,0) for k,_ := range aa &#123; slice = append(slice,k) &#125; sort.Strings(slice) return slice&#125;func main()&#123; a := make(map[string]string) a[\"key1\"] = \"value9\" a[\"key2\"] = \"value8\" a[\"key3\"] = \"value7\" a[\"key7\"] = \"value6\" a[\"key9\"] = \"value5\" a[\"key8\"] = \"value4\" a[\"key6\"] = \"value3\" a[\"key4\"] = \"value2\" a[\"key5\"] = \"value1\" key_list := map_key_sort(a) traversal(key_list,a)&#125; result123456789key1 - value9key2 - value8key3 - value7key4 - value2key5 - value1key6 - value3key7 - value6key8 - value4key9 - value5 map反轉 (鍵值互換)初始化另一個map將key及value互換即可 新初始化的map其key與value的類型也必須相反 1234567891011121314151617181920212223package mainimport ( \"fmt\")func key_value_change(source map[int]string)map[string]int&#123; target := make(map[string]int) for k,v := range source &#123; target[v] = k &#125; return target&#125;func main()&#123; a := make(map[int]string) a[1] = \"value1\" a[2] = \"value2\" a[3] = \"value3\" trans := key_value_change(a) fmt.Println(trans)&#125; result1map[value3:3 value1:1 value2:2]","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"map","slug":"map","permalink":"http://www.taroballz.com/tags/map/"}]},{"title":"Go初識-day11-切片","slug":"Go_slice","date":"2018-04-01T16:00:00.000Z","updated":"2018-04-02T06:45:55.000Z","comments":true,"path":"2018/04/02/Go_slice/","link":"","permalink":"http://www.taroballz.com/2018/04/02/Go_slice/","excerpt":"introduction定義：切片為陣列的引用，因此切片為引用類型 切片本身並不會單獨存在，切片的底層就是陣列 切片的長度可以改變，可將切片視為可變陣列 切片的遍歷方式與陣列一樣 切片長度與陣列一樣可用len函數取得 cap函數可以求出切片的容量，0 ≦ len(array) ≦ cap(slice) array是指被引用的陣列","text":"introduction定義：切片為陣列的引用，因此切片為引用類型 切片本身並不會單獨存在，切片的底層就是陣列 切片的長度可以改變，可將切片視為可變陣列 切片的遍歷方式與陣列一樣 切片長度與陣列一樣可用len函數取得 cap函數可以求出切片的容量，0 ≦ len(array) ≦ cap(slice) array是指被引用的陣列 聲明1var 變量名 []類型 與陣列不一樣的地方是[]中並無數字來表示長度，切片本身長度可以改變 123var slice_int []intvar slice_string []string 初始化聲明切片變量後，請注意要初始化，否則操作時會造成越界，而拋出panic make創建空切片語法121. var 變量 []類型 = make([]類型,長度,容量)2. 變量 := make([]類型,長度,容量) 容量值可以省略不寫 example 11var slice_int []int = make([]int,10,20) example 212var slice_int []intslice_int = make([]int,10) 可簡寫成1slice_int := make([]int,10) 聲明並初始化1var slice_int []int = []int&#123;1,2,3,4,5,6,7,8&#125; 可讓Go自動做類型推導1var slice_int = []int&#123;1,2,3,4,5,6,7,8&#125; 或是1slice_int := []int&#123;1,2,3,4,5,6,7,8&#125; 實際上其為兩條語句的縮寫,因此應為聲明後才初始化12var slice_int []intslice_int =[]int&#123;1,2,3,4,5,6,7,8&#125; 已知陣列切片後初始化 切片的語法為[start:end]，從start開始到end結束，但不包含end 如start為0開始，可省略不寫 如end為len(array)，可省略不寫 如要包含整個陣列，兩個皆可省略不寫 12345var array_int = [8]int&#123;1,2,3,4,5,6,7,8,&#125;var slice_int = array_int[:]var array_int = [...]int&#123;1,2,3,4,5,6,7,8,9,10&#125;var slice_int = array_int[:9] 切片去掉最後一個元素切片的end值為陣列的長度減1 12var array_int = [8]int&#123;1,2,3,4,5,6,7,8,&#125;var slice_int = array_int[:len(array_int)-1] 切片去掉第一個元素切片的end值為1 12var array_int = [8]int&#123;1,2,3,4,5,6,7,8,&#125;var slice_int = array_int[1:] 容量(cap)與長度(len)切片的容量與指向的數組的長度有關係且0≦len(array)≦cap(slice) example 112var array_int = [8]int&#123;1,2,3,4,5,6,7,8,&#125;var slice_int = array_int[:3] result12len(slice) = 3cap(slice) = 8 因切片只取了陣列前面三位元素，後面還有五位元素未拿取，所以實際上切片的容量為8 只要切片的start值為0，容量(cap)一定是被指向的陣列之長度 example 212var array_int = [8]int&#123;1,2,3,4,5,6,7,8,&#125;var slice_int = array_int[3:7] result12len(slice) = 4cap(slice) = 5 因切片start從3開始，前面被切斷了，後面都是切片本身可以拿取的元素，所以容量為5 切片start數不為0的情況，容量為陣列的長度減掉start值 example 3123var array_int = [8]int&#123;1,2,3,4,5,6,7,8,&#125;var slice_int = array_int[3:5]var slice_twice_int = slice_int[2:] result12len(slice_twice) = 0cap(slice_twice) = 3 對陣列的切片再進行切片，其容量仍與陣列相關仍取決於指向的陣列後面有多少元素可以拿取 切片的內存佈局 切片的指針是指向陣列的(只是外部看不到，底層還是操作陣列)因此將切片傳參進函數，在函數內操作切片中的元素(賦值、改值等)，被指向陣列中的元素也會改變更證明了切片本身為引用類型 example123456789101112131415161718package mainimport \"fmt\"func modify_slice(s []int)&#123; s[0] = 1000 s[1] = 2000&#125;func main()&#123; var array_int = [8]int&#123;1,2,3,4,5,6,7,8,&#125; var slice_int = array_int[:] modify_slice(slice_int) fmt.Println(\"slice_int =\",slice_int) fmt.Println(\"array_int =\",array_int)&#125; result12slice_int = [1000 2000 3 4 5 6 7 8]array_int = [1000 2000 3 4 5 6 7 8] 切片內存地址指向第一個元素1234567891011121314package mainimport \"fmt\"func main()&#123; var slice1 = []int&#123;2,4,6,8,10&#125; var slice2 = slice1[1:3] fmt.Printf(\"slice1_address =%p\\n\",slice1) //[1] fmt.Println(\"slice1[0] address =\",&amp;slice1[0]) fmt.Printf(\"slice1[1] address = %p\\n\",&amp;slice1[1]) fmt.Printf(\"slice2 address = %p\\n\",slice2)&#125; [1] 切片本身已經為引用類型，不須再使用&amp;得到內存地址，因為它本身就是指針 若是使用&amp;則會得到指向指針的指針類型，也就是存放這個指針類型(0xc04207e030)的地址 (重要) result1234slice1_address =0xc04207e030slice1[0] address = 0xc04207e030slice1[1] address = 0xc04207e038slice2 address = 0xc04207e038 細談 append append使用方法可參考day9-內置函數 使用append函數，將數個元素追加到一切片中，當超出切片初始化的容量(cap)時原切片會自動擴容，幅度為原容量的一倍 (5 —&gt; 10)123456789101112package mainimport \"fmt\"func main()&#123; var array = [5]int&#123;2,4,6,8,10&#125; var slice = array[1:3] fmt.Println(\"before append cap(slice) =\",cap(slice)) slice = append(slice,1,3,5) fmt.Println(\"after append cap(slice) =\",cap(slice))&#125; result12before append cap(slice) = 4after append cap(slice) = 8 但是切片內部的指針便不是在指向原本的陣列，而是新的陣列 開闢新的內存空間創建新陣列，將原切片內的元素及拷貝到新陣列中，在追加新元素 這時再修改切片中的元素，跟原陣列無關123456789101112131415161718package mainimport \"fmt\"func main()&#123; var array = [5]int&#123;2,4,6,8,10&#125; var slice = array[1:3] fmt.Println(\"Before append:\") fmt.Println(\"array[1] address =\",&amp;array[1]) fmt.Printf(\"slice address =%p\\n\",slice) slice = append(slice,1,3,5) fmt.Println(\"After append:\") fmt.Println(\"array[1] address =\",&amp;array[1]) fmt.Printf(\"slice address =%p\\n\",slice)&#125; result123456Before append:array[1] address = 0xc04207e038slice address =0xc04207e038After append:array[1] address = 0xc04207e038slice address =0xc042086080 如又使用append方法，再次追加元素超出擴容後的切片時，會再擴容(10 —&gt; 20)，且會再次指向新陣列 切片拷貝 (copy)可將切片拷貝至其他切片中 語法1copy(slice_target,slice_source) 將slice_source拷貝至slice_target中 拷貝的長度取決於slice_target容量的大小 即使slice_source的長度大於slice_target的容量，拷貝過程不會擴容 target容量小於source1234567var array = [5]int&#123;2,4,6,8,10&#125;var slice = array[1:3]slice2 := make([]int,1) //*copy(slice2,slice)fmt.Println(slice2) result1[4] target容量大於source1234567var array = [5]int&#123;2,4,6,8,10&#125;var slice = array[1:3]slice2 := make([]int,3) //*copy(slice2,slice)fmt.Println(slice2) result1[4 6 0] 字符串 (string)string的底層就是一個byte類型的陣列([n]byte)，因此也可進行切片操作 string為不可變類型，不能透過元素操作修改已定義的string 因此也沒有容量(cap)的概念 example12345678910package mainimport \"fmt\"func main()&#123; var str string = \"Hello My World\" fmt.Println(str[:5]) fmt.Println(str[6:8]) fmt.Println(str[9:])&#125; result123HelloMyWorld string底層的內存布局 改變string中的字符 如真的欲改變字符串之值，可將不可變的string轉換為可變的[]byte切片，再進行元素操作 再將操作完的[]byte切片轉換為string 123456789101112131415package mainimport \"fmt\"func main()&#123; var str string = \"Hello My World\" str_conv := []byte(str) //[1] str_conv[0] = 'h' //[2] str_conv[6] = 'm' str_conv[9] = 'w' str = string(str_conv) //[3] fmt.Println(str)&#125; [1] 利用強制轉換[]byte()將string轉為[]byte[2] 改變單個字符記得用單引號&#39;&#39;[3] 修改完成後強轉為string類型 result1hello my world 改變string中非ASCII字符如果轉換非ASCII的字符，如中文字(三個byte)等，不能強轉為[]byte操作元素需轉換成[]rune類型，在進行元素操作 1234567891011121314package mainimport \"fmt\"func main()&#123; var str string = \"哈囉 世界\" str_conv := []rune(str) //[1] str_conv[0] = '你' //[2] str_conv[1] = '好' str = string(str_conv) //[3] fmt.Println(str)&#125; [1] 利用強制轉換[]rune()將string轉為[]rune[2] 改變單個字符記得用單引號&#39;&#39;[3] 修改完成後強轉為string類型 result1你好 世界","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"切片","slug":"切片","permalink":"http://www.taroballz.com/tags/切片/"}]},{"title":"Go初識-day11-排序與查找","slug":"Go_sort","date":"2018-04-01T16:00:00.000Z","updated":"2018-04-02T10:15:04.000Z","comments":true,"path":"2018/04/02/Go_sort/","link":"","permalink":"http://www.taroballz.com/2018/04/02/Go_sort/","excerpt":"introductionGo語言本身已有內置的官方package可無痛實現排序功能 位於sort包，導入即可使用 網址：https://golang.org/pkg/sort/","text":"introductionGo語言本身已有內置的官方package可無痛實現排序功能 位於sort包，導入即可使用 網址：https://golang.org/pkg/sort/ Notice 使用排序(sort)函數時，不能使用陣列作為排序的對象 因陣列本身為值類型，傳參時為陣列的副本傳參，是對副本進行排序，不會對外部陣列排序 必須為切片類型才能進行排序 排序整數使用sort.Ints([]int)排序整數類型的切片1234567891011121314151617package mainimport ( \"fmt\" \"sort\")func IntSort(slice []int)&#123; sort.Ints(slice) //* return&#125;func main()&#123; var list = [...]int&#123;1,468,48,456,465,465,48,4,46,54,54,8,43,2,41,98,1,6,16,489,4689,788948,4689,489,4,&#125; IntSort(list[:]) //[1] fmt.Println(list)&#125; [1] 傳入list陣列的全切片 result1[1 1 2 4 4 6 8 16 41 43 46 48 48 54 54 98 456 465 465 468 489 489 4689 4689 788948] 切片是指向陣列的，可以發現陣列也發生了排序 排序字符串使用sort.Strings([]string)排序字符串類型的切片 默認是從ASCII碼由小到大排列 ASCII1234567891011121314151617package mainimport ( \"fmt\" \"sort\")func StringSort(slice []string)&#123; sort.Strings(slice) //* return&#125;func main()&#123; var list = [...]string&#123;\"Apple\",\"banana\",\"Cake\",\"dog\",\"EGG\",\"elephant\",\"Fox\",\"@\",\"*\",\"&amp;\",\" \"&#125; StringSort(list[:]) fmt.Println(list)&#125; result1[ &amp; * @ Apple Cake EGG Fox banana dog elephant] 排序浮點數使用sort.Float64s([]float64)排序浮點數類型的切片1234567891011121314151617package mainimport ( \"fmt\" \"sort\")func FloatSort(slice []float64)&#123; sort.Float64s(slice) //* return&#125;func main()&#123; var list = [...]float64&#123;1531.6181,843.4848,0.484,6198.54984,0.000584894,0.00541818184&#125; FloatSort(list[:]) fmt.Println(list)&#125; result1[0.000584894 0.00541818184 0.484 843.4848 1531.6181 6198.54984] 查找元素於切片的位置sort包中有相關的search函數可以查找已排序的切片中特定元素位於切片中的index值 要是傳入的切片未排序，會返回錯誤的index 查找string型，使用sort.SearchStrings 查找Int型，使用sort.SearchInts 查找float64型，使用sort.SearchFloat64s 以查找float64為範例1234567891011121314151617181920212223package mainimport ( \"fmt\" \"sort\")func FloatSort(slice []float64)&#123; sort.Float64s(slice) //* return&#125;func search(target float64,slice []float64)int&#123; return sort.SearchFloat64s(slice,target) //*&#125;func main()&#123; var list = [...]float64&#123;1531.6181,843.4848,0.484,6198.54984,0.000584894,0.00541818184&#125; FloatSort(list[:]) fmt.Println(list) result := search(1531.6181,list[:]) fmt.Println(\"result =\",result)&#125; result12[0.000584894 0.00541818184 0.484 843.4848 1531.6181 6198.54984]result = 4","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"排序(sort)","slug":"排序-sort","permalink":"http://www.taroballz.com/tags/排序-sort/"}]},{"title":"Go初識-day10-陣列(Array)","slug":"Go_Array","date":"2018-03-31T16:00:00.000Z","updated":"2018-04-01T09:32:24.000Z","comments":true,"path":"2018/04/01/Go_Array/","link":"","permalink":"http://www.taroballz.com/2018/04/01/Go_Array/","excerpt":"introduction定義：有固定長度且裏頭的每個元素都為同一種數據類型之序列 陣列屬於值類型 長度是陣列類型的一部分，不同長度的陣列即使內部元素類型相同，仍為不同類型例如：12var a [5]intvar b [10]int a,b兩變量為不同類型，因此也不能比較 陣列的index皆為0開始，最後一個元素的index為len-1 如果訪問的index在陣列合法範圍之外，會觸發訪問越界，丟出panic","text":"introduction定義：有固定長度且裏頭的每個元素都為同一種數據類型之序列 陣列屬於值類型 長度是陣列類型的一部分，不同長度的陣列即使內部元素類型相同，仍為不同類型例如：12var a [5]intvar b [10]int a,b兩變量為不同類型，因此也不能比較 陣列的index皆為0開始，最後一個元素的index為len-1 如果訪問的index在陣列合法範圍之外，會觸發訪問越界，丟出panic 聲明1var variable_name [len]type []中的數字為陣列的長度，確定後就無法修改 []後指定陣列中儲存哪種數據類型(type) 聲明時默認每個元素都會初始化成0、空字符串、false 比如12var a [5]intvar b [10]string 初始化1var 變量名 [長度]類型 = [長度]類型&#123;元素...&#125; 123456789var array [10]int = [10]int&#123;1,2,3,4,5,6,7,8,9,10&#125;var array [5]int = [5]int&#123;1,2,3&#125; //[1]var array = [4]int&#123;1,2,3&#125; //[2] var array = [...]int&#123;1,2,3,4,&#125; //[3]var array = [5]string&#123;3:\"Hello\",2:\"100\"&#125; //[4] [1] 如果未填滿陣列長度對應的值，會自動將未填入位置填入0[2] 聲明的部分可不寫類型，Go會自動做類型推導[3] 如果陣列太長不得而知長度又懶得數，可用...代替長度，編譯器會自動數 但是初始化時後面跟了多少元素，便為其長度，不得修改 [4] 可直接指定下標初始化，元素欄裡的格式為{index:值} (重要) 其他未初始化的值會初始化為0,空字符串,或是false…等 元素賦值訪問index賦值1變量名[index] = 值 1234var array [10]intarray[0] = 1array[1] = 2array[9] = 9 須注意index必須小於陣列的長度 遍歷陣列使用for循環遍歷陣列 訪問index遍歷1234var array [3]int = [3]int&#123;1,2,3&#125;for i:=0;i&lt;len(array);i++ &#123; fmt.Printf(\"array[%d]=%d\\n\",i,array[i])&#125; result123array[0]=1array[1]=2array[2]=3 使用range遍歷1234var array [3]int = [3]int&#123;1,2,3&#125;for i,v := range array &#123; fmt.Printf(\"array[%d]=%d\\n\",i,v)&#125; result123array[0]=1array[1]=2array[2]=3 Notice陣列屬值類型陣列屬於值類型，因此改變副本的值，並不會改變本身 example 1123456789101112package mainimport \"fmt\"func main()&#123; var array_1 [3]int = [3]int&#123;1,2,3&#125; array_2 := array_1 fmt.Println(\"before array_1:\",array_1) array_2[2] = 100 fmt.Println(\"after array_1:\",array_1)&#125; result12before array_1: [1 2 3]after array_1: [1 2 3] example 21234567891011121314151617package mainimport \"fmt\"func modify_array(array [3]int)&#123; array[0] = 3 array[1] = 2 array[2] = 1 return&#125;func main()&#123; var array_1 [3]int = [3]int&#123;1,2,3&#125; fmt.Println(\"before array_1:\",array_1) modify_array(array_1) fmt.Println(\"after array_1:\",array_1)&#125; result12before array_1: [1 2 3]after array_1: [1 2 3] 函數傳參指針類型的陣列1234567891011121314151617package mainimport \"fmt\"func modify_array(array *[3]int)&#123; //[1] array[0] = 3 array[1] = 2 //[2] (*array)[2] = 1 //[2] return&#125;func main()&#123; var array_1 [3]int = [3]int&#123;1,2,3&#125; fmt.Println(\"before array_1:\",array_1) modify_array(&amp;array_1) //[1] fmt.Println(\"after array_1:\",array_1)&#125; [1] 函數接收陣列指針類型的參數，調用函數時搭配取址符&amp;獲得內存地址[2] 於函數內部修改陣列中的值時，(*array)[index] 可簡寫成 array[index]即可 result12before array_1: [1 2 3]after array_1: [3 2 1] practice使用非遞歸的方式實現費波那契數列，打印前20個數123456789101112131415package mainimport \"fmt\"func main()&#123; var fib_array [20]uint64 = [20]uint64&#123;1,1&#125; for i:=2;i&lt;len(fib_array);i++ &#123; fib_array[i] = fib_array[i-1]+fib_array[i-2] &#125; for _,v := range fib_array &#123; fmt.Printf(\"%d \",v) &#125;&#125; result11 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 多維陣列聲明及初始化123var TwoDimensional [5][3]intvar TwoDimensional = [...][3]int&#123;&#123;1,2,3&#125;,&#123;7,8,9&#125;&#125; 利用{}分開不同維度的陣列 遍歷使用for循環巢式遍歷12345678910111213package mainimport \"fmt\"func main()&#123; var TwoDimensional = [...][3]int&#123;&#123;1,2,3&#125;,&#123;7,8,9&#125;&#125; for i,v := range TwoDimensional &#123; for j,w := range v &#123; fmt.Printf(\"col-%d,row-%d value is %d\\n\",j,i,w) &#125; &#125;&#125; result123456col-0,row-0 value is 1col-1,row-0 value is 2col-2,row-0 value is 3col-0,row-1 value is 7col-1,row-1 value is 8col-2,row-1 value is 9","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"陣列","slug":"陣列","permalink":"http://www.taroballz.com/tags/陣列/"}]},{"title":"Go初識-day10-閉包(closure)","slug":"Go_closure","date":"2018-03-31T16:00:00.000Z","updated":"2018-03-31T19:04:48.000Z","comments":true,"path":"2018/04/01/Go_closure/","link":"","permalink":"http://www.taroballz.com/2018/04/01/Go_closure/","excerpt":"introduction閉包可以用來在一個函式與一組「私有」變數之間建立關聯關係。在給定函式被多次呼叫的過程中，這些私有變數能夠保持其永續性。變數的作用域僅限於包含它們的函式，因此無法從其它程式代碼部分進行存取。不過，變數的生存期是可以很長，在一次函式呼叫期間所建立所生成的值在下次函式呼叫時仍然存在 一個函數和與其相關的引用環境組合而成的實體","text":"introduction閉包可以用來在一個函式與一組「私有」變數之間建立關聯關係。在給定函式被多次呼叫的過程中，這些私有變數能夠保持其永續性。變數的作用域僅限於包含它們的函式，因此無法從其它程式代碼部分進行存取。不過，變數的生存期是可以很長，在一次函式呼叫期間所建立所生成的值在下次函式呼叫時仍然存在 一個函數和與其相關的引用環境組合而成的實體 example123456789101112131415161718package mainimport \"fmt\"func SaveAdd() func(int) int &#123; //[1] var x int return func(add int) int &#123; //[2] x += add return x &#125;&#125;func main()&#123; f := SaveAdd() //[3] fmt.Println(f(1)) //[4] fmt.Println(f(100)) fmt.Println(f(1000))&#125; [1] SaveAdd函數的返回值為一個函數[2] return的匿名函數引用了函數外的變量x，使得return的這個匿名函數成為了閉包，而被綁定的x變量會記得被調用的狀態，等待下次再被調用[3] f為一個被已執行函數賦值的變量[4] f的參數為[2]return匿名函數的參數 result12311011101 因f一直存在，其中的x變量指向的值仍為同一塊內存空間，故保留了函數return匿名函數對x的操作並返回x之值 換句話說 (python)可將整個函數當成一個class，對class內部的函數來說外部變量就相當於class的屬性內部的函數操作類屬性時，類屬性會改變，且會記住被操作的最後狀態，並等待下次被其他內部函數操作 123456789101112class outerFunction(): def __init__(self): self.outervar = 1 def inner_function(self,var): self.outervar += varif __name__ == \"__main__\": f = outerFunction() print(\"outervar =\",f.outervar) f.inner_function(2) print(\"outervar =\",f.outervar) result1213 f物件並未消失，所以類屬性被內部類函數操作時，仍會記住其屬性狀態 檢測文件後綴名1234567891011121314151617181920212223242526package mainimport ( \"strings\" \"fmt\")func detect_extension(extension string) func(string string) string &#123; return func(filename string) string &#123; if strings.HasSuffix(filename,extension) == false &#123; //[1] return filename + extension &#125; return filename &#125;&#125;func main()&#123; bmp := detect_extension(\".bmp\") //[2] jpg := detect_extension(\".jpg\") fmt.Println(bmp(\"test\")) //[3] fmt.Println(bmp(\"test_2.bmp\")) fmt.Println(jpg(\"TEST\")) fmt.Println(jpg(\"TEST_2.jpg\")) &#125; [1] 內部匿名函數引用了外部的變量extension[2] 調用函數並綁定了extension變量[3] 對內部的匿名函數傳參 result1234test.bmptest_2.bmpTEST.jpgTEST_2.jpg Referencehttps://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"閉包","slug":"閉包","permalink":"http://www.taroballz.com/tags/閉包/"}]},{"title":"Go初識-day9-內置函數","slug":"Go_inner_function","date":"2018-03-30T16:00:00.000Z","updated":"2018-05-07T17:14:17.000Z","comments":true,"path":"2018/03/31/Go_inner_function/","link":"","permalink":"http://www.taroballz.com/2018/03/31/Go_inner_function/","excerpt":"內置函數內置函數可以直接使用，且不需要導入特定的package close: 主要用來關閉channel len: 用來求長度，比如sting,array,slice,map,channel new: 用來分配內存，主要用來分配值類型，比如int,struct等基本類型，返回的是指針(注意!!) make: 用來分配內存，主要用來分配引用類型，比如channel,map,slice等 append:用來追加元素到slice中 panic和recover: 用來作錯誤處理","text":"內置函數內置函數可以直接使用，且不需要導入特定的package close: 主要用來關閉channel len: 用來求長度，比如sting,array,slice,map,channel new: 用來分配內存，主要用來分配值類型，比如int,struct等基本類型，返回的是指針(注意!!) make: 用來分配內存，主要用來分配引用類型，比如channel,map,slice等 append:用來追加元素到slice中 panic和recover: 用來作錯誤處理 new通常用來分配值類型的數據返回的是指針 聲明1變量 := new(類型) 比較12345678910111213package mainimport \"fmt\"func main()&#123; var i int //[1] fmt.Println(\"i =\",i) j := new(int) //[2] fmt.Println(\"j =\",j) *j = 100 //[3] fmt.Println(\"*j =\",*j)&#125; [1] 一般聲明值類型的方式，返回的是值[2] 使用new來定義一個int類型的指針[3] 使用*對指向地址裡儲存的值賦值 result123i = 0j = 0xc042060088 //[1]*j = 100 [1] j變量為一指針類型 make通常用來分配引用類型比如channel,map,slice new 與 make的區別 1234567891011package mainimport \"fmt\"func main()&#123; a := new([]int) b := make([]int,0) fmt.Println(a) fmt.Println(b)&#125; result 12&amp;[][] 可以看到new返回的是指針類型，指向一個空切片的地址make直接返回的就是切片，而不是指針 append用來追加元素到slice中append函數的第二參數為可變參數，可追加一個值或多個值 追加一個值12var a []inta = append(a,1) result1a = [1] 追加多個值12var a []inta = append(a,1,3,5,7,9) result1a = [1 3 5 7 9] 追加一個slice中的元素123var a []int = []int&#123;1,2,3,&#125;var b []int = []int&#123;11,22,33,&#125;a = append(a,b...) //[1] [1] 使用...將b切片展開追加到a切片中 result1a = [1 2 3 11 22 33] panic &amp; recoverpanic 錯誤處裡程序執行時遇到某些極端情況，無法繼續執行，可拋出panic異常且Go本身就有自帶一些已知panic異常，可快速發現問題 且通常拋出panic且未捕獲的狀態下，程序會停止運行 系統自拋 panic123456789package mainimport \"fmt\"func main()&#123; a := 0 b := 100/a //[1] fmt.Println(b)&#125; [1] b變量應是無解值 result12345panic: runtime error: integer divide by zero //[1]goroutine 1 [running]:main.main() D:/GoWork/test.go:7 +0x11 //[2] [1] 拋出panic異常並跟隨原因[2] 並顯示於第7行語句發生異常 主動拋出 panic遇到一些代碼可正常執行，但邏輯錯誤，可自己主動拋出異常 模擬配置文件載入出錯模擬配置文件讀取失敗，但是程序仍能正常運行，屬邏輯錯誤設計者應主動拋出panic 123456789101112131415161718192021package mainimport ( \"errors\")//定義一個函數 模擬初始化配置文件出錯func initConfig_Failed()(err error)&#123; //[1] return errors.New(\"initConfig Failed!!\") //[2]&#125;func panic_test()&#123; err := initConfig_Failed() if err != nil &#123; panic(err) //[3] &#125;&#125;func main()&#123; panic_test()&#125; [1] 返回err變量，其為error類型(保存錯誤訊息)[2] errors.New初始化一個error類型的自訂義錯誤訊息實例[3] 主動調用panic函數，參數為錯誤信息 result1234567panic: initConfig Failed!!goroutine 1 [running]:main.panic_test() D:/GoWork/test.go:15 +0x9fmain.main() D:/GoWork/test.go:20 +0x27 panic錯誤訊息為自訂義之訊息，並明指了發生錯誤的行數 recover 捕獲異常 有時程序上線時，即使發生異常，也不希望程序退出 發生的錯誤並不是致命性的 發生錯誤並不影響程序繼續運行，或是不影響下一次請求 基於以上原因，希望能藉由捕獲異常(記錄日誌)，以防止程序崩潰或停擺 搭配 defer 及 匿名函數12345678910111213141516171819202122232425262728293031package mainimport ( \"fmt\" \"time\")func test_recover()&#123; defer func () &#123; //[1] err := recover() //[2] if err != nil &#123; fmt.Println(\"Error:\",err) //捕獲異常後，欲執行的事項，如紀錄日誌，除錯處理...等 &#125; &#125;() //[3] //以下為發生異常代碼 a := 0 b := 100/a fmt.Println(b) return &#125;func main()&#123; for &#123; //模擬不斷的請求處裡 test_recover() time.Sleep(time.Second) //延遲一秒 &#125;&#125; [1] 使用defer於函數發生panic要退出函數時，搭配匿名函數捕獲異常[2] 如發生異常，調用recover函數捕獲，並將獲取的panic信息賦值給err變量[3] 匿名函數聲明時即調用需再聲明完畢}左邊加上()調用並填入參數 result1234567Error: runtime error: integer divide by zeroError: runtime error: integer divide by zeroError: runtime error: integer divide by zeroError: runtime error: integer divide by zeroError: runtime error: integer divide by zero...... 從結果可發現程序不斷地在發出panic，但是沒有退出程序","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"錯誤處理","slug":"錯誤處理","permalink":"http://www.taroballz.com/tags/錯誤處理/"},{"name":"內置函數","slug":"內置函數","permalink":"http://www.taroballz.com/tags/內置函數/"}]},{"title":"Go初識-day9-遞歸函數","slug":"Go_recusive","date":"2018-03-30T16:00:00.000Z","updated":"2018-03-31T13:40:27.000Z","comments":true,"path":"2018/03/31/Go_recusive/","link":"","permalink":"http://www.taroballz.com/2018/03/31/Go_recusive/","excerpt":"introduction一個函數調用了自己，就叫做遞歸 設計原則 一個大問題可拆分出多個邏輯相同的子問題 且問題的規模會不斷的縮小，最後收斂 定義好出口條件 若沒有定義好出口條件，會造成死循環","text":"introduction一個函數調用了自己，就叫做遞歸 設計原則 一個大問題可拆分出多個邏輯相同的子問題 且問題的規模會不斷的縮小，最後收斂 定義好出口條件 若沒有定義好出口條件，會造成死循環 無限循環12345678910111213package mainimport ( \"fmt\" \"time\")func main()&#123; fmt.Println(\"Hello World\") time.Sleep(time.Second) main() return &#125; result1234567Hello WorldHello WorldHello WorldHello WorldHello World...... 如果未設置退出遞歸的條件將無限循環下去 設置退出條件12345678910111213141516171819package mainimport ( \"fmt\" \"time\")func recusive(n int)&#123; fmt.Println(\"Hello World\") time.Sleep(time.Second) if n &gt; 5 &#123; return &#125; recusive(n+1)&#125;func main()&#123; recusive(0)&#125; result1234567Hello WorldHello WorldHello WorldHello WorldHello WorldHello WorldHello World 階乘12345678910111213141516171819202122package mainimport \"fmt\"func multi(n int)int&#123; if n == 1 &#123; return 1 &#125; return multi(n-1)* n&#125;func main()&#123; for &#123; var input int fmt.Printf(\"number &gt;&gt;\") fmt.Scanf(\"%d\\n\",&amp;input) result := multi(input) fmt.Printf(\"%d! result :%d\\n\",input,result) &#125;&#125; result 123456number &gt;&gt;33! result :6number &gt;&gt;44! result :24number &gt;&gt;55! result :120 斐波那契數列返回的數為數列前兩數相加 12345678910111213141516171819202122package mainimport \"fmt\"func Fibonacci(n int)int&#123; if n == 1 || n == 2 &#123; return 1 &#125; return Fibonacci(n-1) + Fibonacci(n-2)&#125;func main()&#123; for &#123; var input int fmt.Printf(\"number &gt;&gt;\") fmt.Scanf(\"%d\\n\",&amp;input) result := Fibonacci(input) fmt.Printf(\"Fib(%d) result :%d\\n\",input,result) &#125;&#125; result12345678number &gt;&gt;3Fib(3) result :2number &gt;&gt;4Fib(4) result :3number &gt;&gt;5Fib(5) result :5number &gt;&gt;6Fib(6) result :8","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"遞歸函數","slug":"遞歸函數","permalink":"http://www.taroballz.com/tags/遞歸函數/"}]},{"title":"Go初識-day8-細談函數","slug":"Go_function","date":"2018-03-29T16:00:00.000Z","updated":"2018-06-05T14:44:31.000Z","comments":true,"path":"2018/03/30/Go_function/","link":"","permalink":"http://www.taroballz.com/2018/03/30/Go_function/","excerpt":"聲明語法123func 函數名 (參數列表)(返回值列表)&#123; 函數主體&#125; 參數列表可以為空但一定要有() 返回值列表也可以是空的，多個返回值需加()","text":"聲明語法123func 函數名 (參數列表)(返回值列表)&#123; 函數主體&#125; 參數列表可以為空但一定要有() 返回值列表也可以是空的，多個返回值需加() example 1123func add()&#123; &#125; 返回值與參數皆為空 example 2123func add(a int, b int)&#123; &#125; 多個參數，但無返回值 example 3123func add(a int, b int)int&#123; &#125; 多個參數，返回一個返回值，返回值的()省略 example 4123func add(a int, b int)(int,int)&#123; &#125; 多個參數，返回多個返回值，返回值須加上() example 5123func add(a, b int)(int,int)&#123; &#125; 多個同類型參數可一起聲明，返回多個返回值，返回值須加上() 錯誤範例1234func add()&#123; &#125; 函數聲明必須與{在同一行，否則無法編譯 函數的特點 函數不支持重載，一個包中不能有兩個名字一樣的函數 一個函數可以賦值給變量，因此函數也可以是變量 函數是一等公民，函數也可以是一種類型 支持匿名函數 (沒有名字的函數) 聲明時就可直接調用 賦值給一變量，使用變量調用 支持多返回值 函數可以賦值給變量12345678910111213141516package mainimport \"fmt\"func add(a,b int)int&#123; return a + b&#125;func main()&#123; c := add //[1] fmt.Println(\"add func address =\",add) fmt.Println(\"c address =\",c) sum := c(10,20) //[2] fmt.Println(\"sum is\",sum)&#125; [1] add函數賦值給一個變量，c變量為一指針指向函數的地址 其等同於：12var c func(int,int)intc = add [2] c變量可以直接當作函數調用 result123add func address = 0x48c950 c address = 0x48c950sum is 30 從結果可以知道add函數跟c變量指向的是同一個內存地址 函數亦可為類型1234567891011121314151617181920212223242526272829package mainimport \"fmt\"type add_func func(int,int) int //[1]func add(a,b int) int &#123; return a + b&#125;func sub(a,b int)int &#123; return a-b&#125;func operator(op add_func, a int, b int) int &#123; //[2] return op(a,b)&#125;func operator_2(op func(int,int)int, a,b int)int &#123; //[3] return op(a,b)&#125;func main()&#123; c := add sum := operator(c,100,200) //[4] sub := operator_2(sub,200,100) fmt.Println(\"sum =\",sum) fmt.Println(\"sub =\",sub)&#125; [1] type關鍵字可以用來定義一種自訂義的類型，其中add_func為類型名[2] operator函數接受自訂義為add_func的函數類型[3] 如果不使用type定義自訂義類型的話，直接於形式參數後面接上自訂義函數類型也是允許的[4] c變量指向的add函數符合自訂義的add_func這個函數類型 須注意傳入的參數必須符合自訂義的函數類型格式，否則會造成類型不匹配而無法編譯 result12sum = 300sub = 100 匿名函數沒有名字的函數 聲明時可直接調用123456789101112package mainimport \"fmt\"func main()&#123; func(a, b int)&#123; fmt.Println(\"a =\",a) fmt.Println(\"b =\",b) fmt.Println(\"a + b=\",a+b) return &#125;(10,20) //[1]&#125; [1] 在函數寫完之後直接在}右邊加()並填入參數調用 result123a = 10b = 20a + b= 30 使用變量調用1234567891011121314package mainimport \"fmt\"func main()&#123; sum := func(a, b int)&#123; //[1] fmt.Println(\"a =\",a) fmt.Println(\"b =\",b) fmt.Println(\"a + b=\",a+b) return &#125; sum(10,20) //[2]&#125; [1] 在聲明變量時定義一個匿名函數[2] 變量()，於()中填入參數並調用匿名函數 result123a = 10b = 20a + b= 30 函數參數傳遞方式 值傳遞 基本的數據類型皆為值傳遞 引用傳遞 常見的引用傳遞類型為指針(pointer)、map,slice,chan,interface類型 無論是值傳遞，還是引用傳遞，傳遞給函數的都是變量的副本，不過值傳遞是值的拷貝；引用傳遞是地址的拷貝，一般來說，地址的拷貝更為高效(最大為8 bytes)，而值拷貝取決於拷貝的物件大小，物件要是越大，性能會越低 命名返回值的名字在定義函數返回值的類型時，可將返回值對應的名字一起定義 example 11234func add(a,b int)(c int)&#123; c = a + b return&#125; example 212345func calc (a,b int)(sum int, avg int) &#123; sum = a + b avg = (a + b) / 2 return&#125; _ 忽略返回值_標示符，用來忽略返回值123456789func calc (a,b int) (sum int, avg int) &#123; sum = a + b avg = (a + b) / 2 return&#125;func main()&#123; sum , _ := calc(100,200)&#125; 可變參數如同最經常使用的fmt.Println()函數調用函數時，我們可以傳入多個參數，也可以不傳入參數 example 1可不傳入參數或多個參數123func function_1(arg ...int) &#123; &#125; example 2必須至少傳入一個參數或傳入多個參數123func function_1(a int, arg ...int)&#123; &#125; example 3必須至少傳入兩個參數或傳入多個參數123func function_1(a,b int, arg ...int)&#123; &#125; tips 其中arg參數名可自訂義 arg是一個切片(slice) 可通過arg[index]依次訪問所有參數 可通過len(arg)來判斷傳遞參數的個數 defer特性 當函數返回時，會執行defer語句，因此可以用來做資源清理 多個defer語句，按先進後出的方式執行 會先執行第二次聲明的defer語句，在執行第一次執行的defer語句12345678910111213package mainimport \"fmt\"func main()&#123; var i int = 0 defer fmt.Println(i) defer fmt.Println(\"second_defer\") i = 10 fmt.Println(i) return &#125; result12310second_defer0 先聲明的defer語句被壓至stack中，取值時從最晚聲明的defer語句開始取，所以”second defer”會先被執行 defer語句中的變量，在defer聲明時就決定了 1234567891011package mainimport \"fmt\"func main()&#123; i := 0 defer fmt.Println(i) //[1] i++ fmt.Println(i) return&#125; [1] 即使i++，但i在defer聲明時就確定i之值，當函數返回時打印出來的i仍為0result1210 用途關閉文件句柄123456func read()&#123; file := open(filename) defer file.close() //文件操作語句&#125; 鎖資源的解放123456func read()&#123; mc.Lock() defer mc.Unlock() //其他操作&#125; 數據庫連接的釋放123456func read()&#123; conn := openDatabase() defer conn.close() //數據庫操作&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"函數","slug":"函數","permalink":"http://www.taroballz.com/tags/函數/"}]},{"title":"Go初識-day7-流程控制_2","slug":"Go_Process_2","date":"2018-03-28T16:00:00.000Z","updated":"2018-06-05T14:02:33.000Z","comments":true,"path":"2018/03/29/Go_Process_2/","link":"","permalink":"http://www.taroballz.com/2018/03/29/Go_Process_2/","excerpt":"for 循環example 1123for 初始化語句;條件判斷;變量修改&#123; &#125; 注意for後面的語句絕對不要用()框起來","text":"for 循環example 1123for 初始化語句;條件判斷;變量修改&#123; &#125; 注意for後面的語句絕對不要用()框起來 example 2for可以省略前後的初始化語句及變量修改語句，只留下條件語句可以直接當成while語句使用123for 條件 &#123; &#125; example 3死循環或稱無限循環123for true &#123; &#125; 可直接簡寫成123for &#123; &#125; example 4用來遍歷數組,slice,map,chan等類型可使用for range 語句1234str := \"Hello World\"for i,v := range str &#123; //[1] fmt.Printf(\"index[%d],value:%c\\n\",i,v)&#125; 字符串其實就是一個字符組成的陣列 [1] i為元素於陣列裡的下標，v為值，i,v皆為初次定義，都必須聲明(:=)才能使用 result1234567891011index[0],value:Hindex[1],value:eindex[2],value:lindex[3],value:lindex[4],value:oindex[5],value: index[6],value:Windex[7],value:oindex[8],value:rindex[9],value:lindex[10],value:d continue &amp; break與其他語言的用法一樣 continue表示跳過後面執行語句並重新開始執行 break跳出循環 goto &amp; LABEL 容易打亂語句的執行 代碼可讀性變差，基本上不建議使用 LABELLABEL的語法就是一串自訂義的字符串加一個:作為標記12345678910111213package mainimport \"fmt\"func main()&#123; LABEL1: for i:=0;i&lt;=5;i++ &#123; if i == 4 &#123; continue LABEL1 &#125; fmt.Println(i) &#125;&#125; gotogoto到任何LABEL只能在同一個函數裡面不能跳脫到函數外部或其他函數的標籤以下就是使用goto來實現for循環123456789101112package mainfunc main()&#123; i:=0HERE: print(i) i++ if i == 5 &#123; return &#125; goto HERE&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"流程控制","slug":"流程控制","permalink":"http://www.taroballz.com/tags/流程控制/"}]},{"title":"Go初識-day6-流程控制_1","slug":"Go_Process","date":"2018-03-27T16:00:00.000Z","updated":"2018-06-05T13:40:38.000Z","comments":true,"path":"2018/03/28/Go_Process/","link":"","permalink":"http://www.taroballz.com/2018/03/28/Go_Process/","excerpt":"if / else 分支判斷 if的條件不需要加括號example 1123if condtion1 &#123; &#125;","text":"if / else 分支判斷 if的條件不需要加括號example 1123if condtion1 &#123; &#125; example 212345if condition1 &#123; &#125; else &#123; &#125; example 3123456789if condtion1 &#123; &#125; else if condtion2 &#123; &#125; else if condtion3 &#123; &#125; else &#123; &#125; tipselse或是else if一定是放在上一個語句塊的}右邊，以下為錯誤範例123456if condtion &#123; &#125;else &#123; &#125; if判斷錯誤(if err != nil)通常調用函數時會返回一個結果加一個錯誤12345678910111213141516package mainimport ( \"io/ioutil\" \"fmt\")func main()&#123; FileName := \"test.log\" content,err := ioutil.ReadFile(FileName) if err != nil &#123; fmt.Println(err) &#125; else &#123; fmt.Printf(\"%s\\n\",content) &#125;&#125; 可在if語句中定義變量，並用;隔開判斷語句123456789101112131415package mainimport ( \"io/ioutil\" \"fmt\")func main()&#123; FileName := \"test.log\" if content,err := ioutil.ReadFile(FileName); err != nil &#123; fmt.Println(err) &#125; else &#123; fmt.Printf(\"%s\\n\",content) &#125;&#125; 在if語句內定義的變量，作用域就只在if/else代碼塊中只要跳脫if/else語句代碼塊之外便不能訪問 switch case 語句 與c語言不一樣的地方就是每個case之間不需要break也不會穿透到其他case 如果仍想要穿透其他case執行可以在兩個case之間加上關鍵字fallthrough example 1123456switch var &#123; case var1: case var2: case var3: default: //[1]&#125; [1] 要是前面的case都不符合，default用來執行一個默認的分支 example 2多個值要使用相同的case可以寫在同一個case的條件語句中123456789var a int = 0switch a &#123; case 0,1,3,5,7,9: fmt.Println(\"It's 0 or 1,3,5,7,9\") case 2: fmt.Println(\"It's 2\") default: fmt.Println(\"It's default\")&#125; example 3switch後可以沒有表達式，case後使用條件語句1234567891011var i int = 0switch &#123; case i&lt;0 &amp;&amp; i&gt;-1: fmt.Println(\"-1&lt;i&lt;0\") case i&gt;0 &amp;&amp; i&lt;1: fmt.Println(\"0&lt;i&lt;1\") case i == 0: fmt.Println(\"i = 0\") default: fmt.Println(\"i didn't between 1 and -1\")&#125; example 4switch關鍵字後面可以初始化值12345678910switch i:=0;&#123; //[1] case i&lt;0 &amp;&amp; i&gt;-1: fmt.Println(\"-1&lt;i&lt;0\") case i&gt;0 &amp;&amp; i&lt;1: fmt.Println(\"0&lt;i&lt;1\") case i == 0: fmt.Println(\"i = 0\") default: fmt.Println(\"i didn't between 1 and -1\")&#125; [1]注意初始化值為一語句，後面需加上分號;,否則無法編譯","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"流程控制","slug":"流程控制","permalink":"http://www.taroballz.com/tags/流程控制/"}]},{"title":"Go初識-day5-時間和日期、指針","slug":"Go_Time","date":"2018-03-26T16:00:00.000Z","updated":"2018-05-19T13:00:20.000Z","comments":true,"path":"2018/03/27/Go_Time/","link":"","permalink":"http://www.taroballz.com/2018/03/27/Go_Time/","excerpt":"時間和日期類型introduction 時間與日期類型位於time包中 時間類型 為time.Time用來表示時間 time.Duration用來表示奈秒 一些常量：12345678const ( Nanosecond Duration = 1 Microsecond = 1000 * Nanosecond Millisecond = 1000 * Microsecond Second = 1000 * Millisecond Minute = 60 * Second Hour = 60 * Minute)","text":"時間和日期類型introduction 時間與日期類型位於time包中 時間類型 為time.Time用來表示時間 time.Duration用來表示奈秒 一些常量：12345678const ( Nanosecond Duration = 1 Microsecond = 1000 * Nanosecond Millisecond = 1000 * Microsecond Second = 1000 * Millisecond Minute = 60 * Second Hour = 60 * Minute) 獲取當前時間獲取當前時間使用time.Now() example1234567891011121314151617181920package mainimport ( \"fmt\" \"time\")func main()&#123; now := time.Now() Now_day := now.Day() Now_Minute := now.Minute() Now_Month := now.Month() Now_Year := now.Year() fmt.Println(\"now is:\",now) fmt.Println(\"day is:\",Now_day) fmt.Println(\"minute is:\",Now_Minute) fmt.Println(\"month is:\",Now_Month) fmt.Println(\"year is:\",Now_Year)&#125; result123456now is: 2018-03-27 20:56:45.447703 +0800 CST m=+0.004010601day is: 27minute is: 56month is: Marchyear is: 20182018/03/27-20:56:45 時間輸出格式化example1234567891011121314151617181920package mainimport ( \"fmt\" \"time\")func main()&#123; now := time.Now() //1 fmt.Printf(\"%02d/%02d/%02d-%02d:%02d:%02d\\n\", now.Year(),now.Month(),now.Day(),now.Hour(),now.Minute(),now.Second()) //2 fmt.Println(now.Format(\"02/1/2006 15:04\")) fmt.Println(now.Format(\"2006/1/02 15:04\")) fmt.Println(now.Format(\"2006/1/02 \")) //[1]&#125; [1] 第二種時間必須為Go誕生的時間，不能自己隨便定義，否則輸出的時間不對 result12342018/03/27-21:21:0927/3/2018 21:212018/3/27 21:212018/3/27 指針類型Introduction 變量預設存的為”值“，稱值類型或是普通類型 使用&amp;獲取變量的地址，例:var a int，要獲取a的地址就是&amp;a 指針類型，變量存的是地址，這個地址存的才是值 獲取指針類型所指向的值，使用*，比如:var *p int, 使用*p獲取p指向的值 獲取變量地址12345678package mainimport \"fmt\"func main()&#123; var a int fmt.Println(\"a address=\",&amp;a)&#125; result1a address= 0xc042060080 函數傳入指針並修改值123456789101112131415package mainimport \"fmt\"func modify_var(a *int)&#123; //[1] *a = 10 //[3] return&#125;func main()&#123; var a int = 5 fmt.Println(a) modify_var(&amp;a) //[2] fmt.Println(a)&#125; [1] *int為int類型的指針，接受的值必須為指針類型[2] &amp;獲取變量的地址[3] *獲取內存地址指向的值，進行修改 result12510","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"時間和日期(time)","slug":"時間和日期-time","permalink":"http://www.taroballz.com/tags/時間和日期-time/"},{"name":"指針","slug":"指針","permalink":"http://www.taroballz.com/tags/指針/"}]},{"title":"Go初識-day5-字符串操作","slug":"Go_string_operate","date":"2018-03-26T16:00:00.000Z","updated":"2018-03-30T15:16:31.000Z","comments":true,"path":"2018/03/27/Go_string_operate/","link":"","permalink":"http://www.taroballz.com/2018/03/27/Go_string_operate/","excerpt":"strings庫的使用判斷字符串開頭strings.HasPrefix(str string, prefix string) bool判斷字符串str是否以prefix開頭，並返回bool值","text":"strings庫的使用判斷字符串開頭strings.HasPrefix(str string, prefix string) bool判斷字符串str是否以prefix開頭，並返回bool值 example1234567891011121314151617package mainimport ( \"fmt\" \"strings\")func main()&#123; var a string = \"https://google.com\" var b string = \"http://www.taroballz.com\" aa := strings.HasPrefix(a,\"https://\") bb := strings.HasPrefix(b,\"https://\") fmt.Println(aa) fmt.Println(bb)&#125; result12truefalse 判斷字符串結尾strings.HasSuffix(str string, suffix string) bool判斷字符串str是否以suffix結尾，並返回bool值 example1234567891011121314151617package mainimport ( \"fmt\" \"strings\")func main()&#123; a := \"http://www.example.com/index.php\" b := \"http://www.demo.com/default.aspx\" aa := strings.HasSuffix(a,\"php\") bb := strings.HasSuffix(b,\"php\") fmt.Println(aa) fmt.Println(bb)&#125; result12truefalse 字符串出現的位置判斷首次出現strings.Index(str string, choice string) int判斷choice在str中首次出現的位置，如果沒有返回-1 example123456789101112package mainimport ( \"fmt\" \"strings\")func main()&#123; var a string = \"Hello World\" result := strings.Index(a,\"l\") fmt.Println(result)&#125; result12 判斷最後出現strings.LastIndex(str string, choice string) int判斷choice在str中最後出現的位置，如果沒有返回-1 example123456789101112package mainimport ( \"fmt\" \"strings\")func main()&#123; var a string = \"Hello World\" result := strings.LastIndex(a,\"l\") fmt.Println(result)&#125; result19 字符串替換strings.Replace(str string, old string, new string, n int)將str中的old替換成new，共替換n次 要是n小於0，則替換次數無限制 字符串記數strings.Count(str string, substr string)int計數substr在str中出現的次數，並返回出現的次數 生成重複的字符串strings.Repeat(str string, count int)string生成一個將str重複count次的字符串並返回 大小寫轉換字符串轉小寫strings.ToLower(str strinig)string將str轉成小寫後返回 字符串轉大寫strings.ToUpper(str string)string將str轉成大寫後返回 除去特定字符串除去字符串首尾的空白字符strings.TrimSpace(str string) 空白字符包含\\n,\\t…等 除去字符串首尾字符strings.Trim(str string, cut string)去掉str中首尾的cut 除去字符串首字符strings.TrimLeft(str string, cut string)去掉str中頭部的cut 除去字符串尾字符strings.TrimRight(str string, cut string)去掉str中尾部的cut 分割字符串以空格分割strings.Field(str string)返回一個以空格分割的所有子字符串的切片 自訂義分割strings.Split(str strings, split string)返回一個以split分割的所有子字符串的切片 合併字符串strings.Join(s1 []strings, sep string)返回一個 使用sep作為s1切片中各子字符串的分隔符的拼接字符串 為.Split的反操作 strconv庫的使用整數轉字符串strconv.Itoa(i int)把i整數轉為字符串 字符串轉整數strconv.Atoi(str string)(int,error)把str字符串轉為整數並返回要是無法轉換返回error","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"字符串操作","slug":"字符串操作","permalink":"http://www.taroballz.com/tags/字符串操作/"}]},{"title":"Go初識-day4-格式化輸出、基本字符串操作","slug":"Go_fmt","date":"2018-03-25T16:00:00.000Z","updated":"2018-03-26T14:35:46.000Z","comments":true,"path":"2018/03/26/Go_fmt/","link":"","permalink":"http://www.taroballz.com/2018/03/26/Go_fmt/","excerpt":"格式化輸出至終端使用fmt.Printf()調用格式化輸出至終端 一般類型%v:以原樣打印，輸出相應值的默認格式 —&gt; 不知道如何輸出也可用%T:打印相應值的類型(type)%%:打印出百分號 bool類型%t:打印true或是false —&gt; 一般也可用%v完成","text":"格式化輸出至終端使用fmt.Printf()調用格式化輸出至終端 一般類型%v:以原樣打印，輸出相應值的默認格式 —&gt; 不知道如何輸出也可用%T:打印相應值的類型(type)%%:打印出百分號 bool類型%t:打印true或是false —&gt; 一般也可用%v完成 整數%b:二進制表示%d:十進制表示%o:八進制表示%c:相應的Unicode碼所表示的字符 浮點數及其複合構成%e:科學記號表示，-1234.56e+78%E:科學記號表示，-1234.56E+78%f:有小數點而無指數表示，123.456 字符串與字符切片%s:打印字符串%q:打印字符串時，兩邊也會加入雙引號%x:十六進制，小寫字母%X:十六進制，大寫字母 指針%p:打印內存地址，時溜進制表示，前綴為0x 格式化輸出到字符串使用fmt.Sprintf()調用格式化輸出至字符串中可用於數字類型轉換成字符串類型與前一節使用方法一樣，只是返回的為字符串類型 example1234567891011121314package mainimport \"fmt\"func main()&#123; var integer int = 10000 var float_num float64 = 0.0005 integer_str := fmt.Sprintf(\"%d\",integer) float_num_str := fmt.Sprintf(\"%f\",float_num) fmt.Printf(\"integer_str type:%T,Value:%s\\n\",integer_str,integer_str) fmt.Printf(\"float_num_str type:%T,Value:%s\\n\",float_num_str,float_num_str)&#125; result12integer_str type:string,Value:10000float_num_str type:string,Value:0.000500 拼接字符串使用運算符拼接字符串之間可用運算符+拼接 example1234567891011package mainimport \"fmt\"func main()&#123; var a string = \"Hello\" b := \"World\" str := a + \" \" + b fmt.Println(str)&#125; result1Hello World 使用輸出格式化拼接使用fmt.Sprintf()拼接 example1234567891011package mainimport \"fmt\"func main()&#123; var a string = \"Hello\" b := \"World\" str := fmt.Sprintf(\"%s %s\",a,b) fmt.Println(str)&#125; result1Hello World 字符串長度使用len()方法求字符串長度 example123456789package mainimport \"fmt\"func main()&#123; var a = \"Hello World\" length_a := len(a) fmt.Printf(\"string a length is %d\",length_a)&#125; result1string a length is 11 字符串切片擷取字符串中想要的部分 example123456789101112131415package mainimport \"fmt\"func main()&#123; var a string = \"Hello new World\" Hello_str := a[:5] //[1] new_str := a[6:9] //[2] World_str := a[10:] //[3] fmt.Println(Hello_str) fmt.Println(new_str) fmt.Println(World_str)&#125; [1] 若取值index從0開始，可省略不寫[2] 取值:左邊為要開始取值的index,右邊為取值結束的index+1[3] 若取值結束需取到最後:右邊可省略不寫 result123HellonewWorld 字符串反轉example 1123456789101112131415161718package mainimport \"fmt\"func string_reverse(a string)string&#123; var result string for i:=0;i&lt;len(a);i++&#123; pick := a[len(a)-1-i:len(a)-i] result += pick &#125; return result&#125;func main()&#123; var a string = \"Hello World\" result := string_reverse(a) fmt.Println(result)&#125; example 2123456789101112131415161718package mainimport \"fmt\"func string_reverse(str string)string&#123; var result string strLen := len(str) for i:=0;i&lt;strLen;i++&#123; result += fmt.Sprintf(\"%c\",str[len(str)-i-1]) &#125; return result&#125;func main()&#123; var a string = \"Hello World\" result := string_reverse(a) fmt.Println(result)&#125; result1dlroW olleH","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"格式化輸出","slug":"格式化輸出","permalink":"http://www.taroballz.com/tags/格式化輸出/"},{"name":"字符串操作","slug":"字符串操作","permalink":"http://www.taroballz.com/tags/字符串操作/"}]},{"title":"Go初識-day4-作用域、數據類型與操作符","slug":"Go_variables_location","date":"2018-03-25T16:00:00.000Z","updated":"2018-03-26T12:34:22.000Z","comments":true,"path":"2018/03/26/Go_variables_location/","link":"","permalink":"http://www.taroballz.com/2018/03/26/Go_variables_location/","excerpt":"變量的作用域 在函數內部聲明的變量叫做局部變量，生命週期僅限於函數內部；可見性也僅限於函數內部，函數外部皆無法訪問 若函數內部有語句塊，如for,if,switch內部的語句塊，亦指{}內部，在語句塊內部定義的變量，在跳脫語句塊後也會回收 在函數外部聲明的變量叫做全局變量 生命週期作用於整個程序 如果變量名為大寫可以在外部訪問調用 函數外部只能聲明變量、常量，不能執行代碼","text":"變量的作用域 在函數內部聲明的變量叫做局部變量，生命週期僅限於函數內部；可見性也僅限於函數內部，函數外部皆無法訪問 若函數內部有語句塊，如for,if,switch內部的語句塊，亦指{}內部，在語句塊內部定義的變量，在跳脫語句塊後也會回收 在函數外部聲明的變量叫做全局變量 生命週期作用於整個程序 如果變量名為大寫可以在外部訪問調用 函數外部只能聲明變量、常量，不能執行代碼 數據類型與操作符bool類型bool類型只能存true和false 聲明123var a bool //[1]var a bool = truevar a = true [1] 聲明變量時未初始化值，默認初始化為false 相關操作符! : 取反值&amp;&amp; : and 操作 (注意短路特性，一開始為false即為false)|| : or 操作 (注意短路特性，一開始為true即為true) 數字類型主要有int,int8,in16,int32,int64,uint8,uint16,uint32,uint64,float32,float64 聲明1234var a int8 = 100var b int16 = 200var c float32var d float64 類型轉換在Go語言中不同的數字類型之間是不能直接賦值的以下為錯誤的代碼12var a int8 = 100var b int16 = a 需透過類型轉換才能成功賦值or運算 語法目標類型(欲轉換的變量)12var a int8 = 100var b int16 = int16(a) 邏輯操作符==,!=,&lt;,&lt;=,&gt;,&gt;=用於判斷邏輯操作符兩邊之間的關係，返回bool值 數學操作符+,-,*,/,% practice使用math/rand生成10個隨機整數，10個小於100的隨機整數以及10個隨機浮點數123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( \"fmt\" \"math/rand\" \"time\")func Create_randint()&#123; randnum := rand.Int() fmt.Println(randnum)&#125;func Create_randint_100()&#123; randnum := rand.Intn(100) //[1] fmt.Println(randnum)&#125;func Create_randfloat()&#123; randnum := rand.Float32() fmt.Println(randnum)&#125;func init()&#123; //[2] rand.Seed(time.Now().UnixNano()) //[3]&#125;func main()&#123; fmt.Println(\"print randnumber:\") for i:=0;i&lt;10;i++&#123; Create_randint() &#125; fmt.Println(\"print randnumber &lt; 100:\") for i:=0;i&lt;10;i++&#123; Create_randint_100() &#125; fmt.Println(\"print randfloatnumber\") for i:=0;i&lt;10;i++&#123; Create_randfloat() &#125;&#125; [1] rand.Intn為隨機生成一個參數範圍以內的數[2] 因為Seed初始化在每次運行程序時都必須要做，可放在init函數裡值行[3] 使用當前時間奈秒數的時間戳作為Seed使得其每次產出的數字皆不一樣 字符類型(byte)相當於c語言中的char類型一個byte佔據8bits 聲明12var a bytevar b byte = 'c' //[1] [1]使用&#39;&#39;(單引號)來表示字符，只能存放一個字符 example1234567891011package mainimport \"fmt\"var b byte = 'c'func main()&#123; fmt.Println(b) //[1] fmt.Printf(\"%c\\n\",b) //[2] fmt.Println(string(b)) //[3]&#125; [1] 默認打印byte會顯示此字符對應的ASCII碼數字[2] 使用Printf格式化輸出，可打印原字符[3] 將字符轉成字符串類型也可打印原字符 result12399cc 字符串類型0個或多個字符組成的字符串 聲明123var str string //[1]var hello string = \"Hello World!!\" //[2]var speical string = `\\n \\t` //[3] [1] 聲明string時沒有初始化變量默認為空字符串[2] 使用&quot;&quot;(雙引號)來表示字符串，可存放0或多個字符串，具有轉譯的功能[3] 使用``(反引號)來表示字符串，可存放0或多個字符串，不具轉譯功能(輸出甚麼就是甚麼)，為原生字符串，可用在輸出多行 example1234567891011121314151617package mainimport \"fmt\"var str stringvar hello string = \"Hello\\tWorld\\n!!\"var speical string = `Hello\\tWorld\\n!!`var poem string = `白日依山盡黃河 入海流欲窮千里目，更上一層樓`func main()&#123; fmt.Println(\"str =\",str) fmt.Println(\"hello =\",hello) fmt.Println(\"special =\",speical) fmt.Println(\"poem = \",poem)&#125; result1234567str = hello = Hello World!!special = Hello\\tWorld\\n!!poem = 白日依山盡黃河 入海流欲窮千里目，更上一層樓","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"作用域","slug":"作用域","permalink":"http://www.taroballz.com/tags/作用域/"},{"name":"數據類型與操作符","slug":"數據類型與操作符","permalink":"http://www.taroballz.com/tags/數據類型與操作符/"}]},{"title":"Go初識-day3-init函數、函數、常量","slug":"Go_init","date":"2018-03-24T16:00:00.000Z","updated":"2019-02-16T13:56:10.000Z","comments":true,"path":"2018/03/25/Go_init/","link":"","permalink":"http://www.taroballz.com/2018/03/25/Go_init/","excerpt":"init函數 每個原文件都可以包含一個init函數 在運行main函數之前會被Go的運行框架自動調用 通常用於在執行main函數之前初始化","text":"init函數 每個原文件都可以包含一個init函數 在運行main函數之前會被Go的運行框架自動調用 通常用於在執行main函數之前初始化 example12345678910111213141516package mainimport \"fmt\"var Name string = \"I'm global value\"func init()&#123; fmt.Println(\"Initialize....\") fmt.Println(Name) Name = \"Name initialize...\"&#125;func main()&#123; fmt.Println(\"I'm main function!!\") fmt.Println(Name)&#125; result1234Initialize....I&apos;m global valueI&apos;m main function!!Name initialize... tips 執行順序：初始化全局變量 —&gt; 執行init函數 —&gt; 執行main函數 要是main包中有導入其他包，會先執行其他包的init函數，最後才會執行main包中的init函數 補充有時，用戶可能需要導入一個包，但是不需要引用這個包裡面的函數或是其他標識符，會使用空白標識符(_)給予其別名，其目的就是為了執行該包的init函數而已 123import ( _ \"fmt\") 函數聲明格式123func 函數名 (參數列表) (返回值列表)&#123; //[1][2] 函數主體&#125; [1] 即使沒有參數，()小括號也要標示[2] 沒有返回值，則可不寫返回值；只有一個返回值則可省略()小括號 example無參數且無返回值123func function_one()&#123; &#125; 有參數有一返回值123func function_two(a int, b int)int&#123; &#125; 有參數及多個返回值123func function_three(a,b int)(int,int)&#123; &#125; 註釋Go中共使用兩種註釋 單行註釋 ( // )1234func add(a,b int)int&#123; //add 計算兩整數和，並返回結果&#125; 多行註釋 ( /* */ )123456func add(a,b int)int&#123; /*add 計算兩整數和 ，並返回結果*/&#125; 常量 常量為const開頭修飾，代表永遠只讀，不能修改 程序初始化時(編譯階段)，值就決定了 const只能修飾boolean,number(int,float,complex相關類型)和string 語法1const 常量名 [類型] = 值 //[1] [1] 可省略類型不寫，編譯時會自動做類型推斷 example初學者寫法1234const b string = \"Hello world\"const b = \"Hello world\"const Pi = 3.1415926const a = 9/3 //[1] [1] =右邊可以是表達式，編譯時會計算完成 優雅寫法12345const( b = \"Hello world\" Pi = 3.1415926 a = 9/3) 專業寫法(枚舉類型)12345const( a = iota //[1] b c) [1] iota會將變量設為0，後續變量往後會+1，也就是說a為0，b為1，c為2 iota為自增值 1234567const( b = 1 &lt;&lt; (10 * iota) kb mb gb tb) tips1const c = getvalue() 以上寫法是錯的，=右邊不能是編譯時會無法確定值的物件 practice定義兩個常量Male=1和Female=2，獲取當前時間的秒數，如果能被Female整除則在終端顯示Female否則打印Male 1234567891011121314151617181920package mainimport ( \"fmt\" \"time\")const ( Male = 1 Female = 2)func main()&#123; Now_second := time.Now().Unix() //[1] if Now_second % Female == 0 &#123; fmt.Println(\"Female\") &#125; else &#123; fmt.Println(\"Male\") &#125;&#125; [1] time.Now().Unix()獲取從1970年到現在的秒數","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"函數","slug":"函數","permalink":"http://www.taroballz.com/tags/函數/"},{"name":"init函數","slug":"init函數","permalink":"http://www.taroballz.com/tags/init函數/"},{"name":"常量(const)","slug":"常量-const","permalink":"http://www.taroballz.com/tags/常量-const/"}]},{"title":"Go初識-day3-變量、值類型與引用類型","slug":"Go_variables","date":"2018-03-24T16:00:00.000Z","updated":"2018-06-04T17:24:25.000Z","comments":true,"path":"2018/03/25/Go_variables/","link":"","permalink":"http://www.taroballz.com/2018/03/25/Go_variables/","excerpt":"變量格式var 變量名 類型變量名 := 值 //[1] [1] 第一次聲明可使用:=，Go會自動做類型推導 在Golang中變量名是寫在前面，類型則是寫在後面","text":"變量格式var 變量名 類型變量名 := 值 //[1] [1] 第一次聲明可使用:=，Go會自動做類型推導 在Golang中變量名是寫在前面，類型則是寫在後面 example範例 112345var a intvar b stringvar c boolvar d int = 8 //[1]var e string = \"Hello world\" //[1] [1] 聲明變量並初始化為=右邊之值若無指定初始化之值int默認為0，string默認為空字符串，bool默認為false 範例 2 (多變量一起聲明)1234567var ( a int b string c bool d int = 8 e string = \"Hello world\" ) 範例 31234567var ( a int b string c bool d = 8 //[1] e = \"Hello world\" //[1] ) [1] 在聲明變量時可不附類型，go會自己做類型推斷 範例 412345a := 0b := \"\"c := falsed := 8e := \"Hello world\" 值類型和引用類型值類型變量中直接存儲值 a 被分配了一個內存空間，a直接指向這個內存空間，這個空間存放的值為5 內存通常在棧中分配 基本數據類型int,float,bool,string以及array和struct都是值類型 引用類型變量中存儲的是一個地址，這個地址指向的才是值 在函數中使用引用類型的值作為參數效率較高(傳入參數為複製地址，而非複製值) 內存通常在堆上分配，通過GC回收 指針(pointer)、切片(slice),map,chan皆為引用類型 practice 1寫一個程序用來展示值類型和引用類型到終端，並觀察輸出結果123456789101112131415161718192021222324252627282930package mainimport \"fmt\"func ModifyValue(a int)&#123; a = 100 return &#125;func ModifyRef(a chan int)&#123; b := &lt;- a b = 100 a &lt;- b return &#125;func main()&#123; Value := 1 fmt.Println(\"Before:\",Value) ModifyValue(Value) fmt.Println(\"After:\",Value) BeforeChannel := make(chan int,1) SendValue := 1 BeforeChannel &lt;- SendValue ModifyRef(BeforeChannel) PickValue := &lt;- BeforeChannel fmt.Println(\"SendValue:\",SendValue) fmt.Println(\"PickValue:\",PickValue)&#125; result1234Before: 1After: 1SendValue: 1PickValue: 100 從執行結果可以發現，值類型的參數傳遞到函數中時，是複製了一份一模一樣的值傳入，函數中修改的是複製的值，而非原本的值，所以函數外部的值不管有沒有經過函數都沒有變化 引用類型在函數中傳參時，操作的就是同一塊內存空間，所以經過函數時，channel的值發生了改變 practice 2寫一個程序，交換兩個整數值比如a=3;b=4，交換之後a=4;b=3123456789101112131415package mainimport \"fmt\"func change(a,b *int)&#123; //[1] *a,*b = *b,*a //[2] return&#125;func main()&#123; a := 3 b := 4 change(&amp;a,&amp;b) //[3] fmt.Println(\"a=\",a,\"b=\",b)&#125; [1] change函數接收的為int類型的指針[2] 參數為指針類型，使用*則是向內存地址指向的內存空間取值[3] 因change函數接受為指針類型的參數，&amp;取址符為對後面的變量取得其內存地址 result1a= 4 b= 3","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"變量","slug":"變量","permalink":"http://www.taroballz.com/tags/變量/"},{"name":"值類型與引用類型","slug":"值類型與引用類型","permalink":"http://www.taroballz.com/tags/值類型與引用類型/"}]},{"title":"Go初識-day2-保留字、基本結構、包別名","slug":"Go_package","date":"2018-03-23T16:00:00.000Z","updated":"2018-04-03T12:30:08.000Z","comments":true,"path":"2018/03/24/Go_package/","link":"","permalink":"http://www.taroballz.com/2018/03/24/Go_package/","excerpt":"Notice 變量或函數命名須以字母或是下劃線開頭，大小寫有區分，不能包含運算符 _ 是特殊標示符，用來忽略結果 保留關鍵字如下： break default func interface select case defer go map struct chan else goto package switch const fallthough if range type continue for import return var","text":"Notice 變量或函數命名須以字母或是下劃線開頭，大小寫有區分，不能包含運算符 _ 是特殊標示符，用來忽略結果 保留關鍵字如下： break default func interface select case defer go map struct chan else goto package switch const fallthough if range type continue for import return var Go程序的基本結構1234567package mainimport \"fmt\"func main()&#123; fmt.Println(\"Hello World\")&#125; import (引用其他package)通常會習慣寫成 1234import ( \"fmt\" \"os\" ) 可允許寫成 12import (\"fmt\")import (\"os\") 包中函數調用 同一個包中的函數可以直接調用，與大小寫無關 不同package中函數，通過包名+點+函數名進行調用 如:calc.Add(100,200) 包之間的訪問規則： 大寫意味著這個函數/變量是可導出的 小寫意味著這個函數/變量是私有的 —-&gt;包外部不能訪問 Practice 寫一個程序，對於給定一個數字n，求出所有兩兩相加等於n的組合12345678910111213141516package mainimport \"fmt\"func two_num_sum(sum int)&#123; for i:=0;i&lt;=sum;i++ &#123; fmt.Printf(\"%d + %d = %d\\n\",i,sum-i,sum) //[1] &#125;&#125;func main()&#123; var sum int fmt.Printf(\"Input the sum number:\") fmt.Scanf(\"%d\\n\",&amp;sum) //[2] two_num_sum(sum)&#125; [1] fmt.Printf為格式化輸出，用法與c語言相同[2] fmt.Scanf為格式化輸入，用法與c語言相同，須注意在變量前面加入取址符&amp; 寫一個程序包含add和main兩個package，其中add包中有兩個變量：Name和Age，請問main包中如何訪問Name和Age？day2\\practice2\\add\\add.go1234package addvar Name string = \"Taroballz\" //[1]var Age int = 27 [1] 變量需大寫才能被外部包調用宣告變量時就初始化，表示變量初始值即為=右邊的值因為Go屬於編譯型語言而非腳本語言，需要有入口函數去執行代碼所以在main函數外部的全局域寫 1234var Name stringvar Age intName = \"Taroballz\"Age = 27 或是 12Name := \"Taroballz\"Age := 27 會因為找不到入口函數而無法賦值 day2\\practice2\\main\\main.go12345678910package mainimport (\"fmt\" \"go_lesson/day2/practice2/add\" )func main()&#123; fmt.Println(\"My Name is\",add.Name) fmt.Println(\"I'm\",add.Age,\"years old\")&#125; 包的別名要是導入的包名太長，可自定義包的別名來取代原本的包名，並使用包的別名引用函數 格式1import 別名 &quot;包名&quot; //[1] [1] 注意別名與包名之間的空格 example1234567package mainimport f \"fmt\" //[1]func main()&#123; f.Println(\"Hello World!\") //[2] &#125; [1] 將fmt包的別名自訂義為f[2] 使用別名f調用函數Println result1Hello World! tips 要是將包導入但不會去用到包中的函數或是變量的話可將別名改為-，表示將包導入並初始化，但是包被忽略不引用","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"},{"name":"Go基本結構","slug":"Go基本結構","permalink":"http://www.taroballz.com/tags/Go基本結構/"},{"name":"保留字","slug":"保留字","permalink":"http://www.taroballz.com/tags/保留字/"},{"name":"包(package)","slug":"包-package","permalink":"http://www.taroballz.com/tags/包-package/"}]},{"title":"Go初識-day1-語言特性(高併發與channel的演示)","slug":"GO_channelAndthread","date":"2018-03-22T16:00:00.000Z","updated":"2019-01-14T13:24:52.000Z","comments":true,"path":"2018/03/23/GO_channelAndthread/","link":"","permalink":"http://www.taroballz.com/2018/03/23/GO_channelAndthread/","excerpt":"特性 是現今雲計算時代的C語言 可直接編譯不依賴其他的庫(library) 為靜態語言，執行效率高 垃圾回收C/C++因為給予程序員較自由的內存管理權限，但申請內存空間要是忘記釋放會造成內存洩漏導致記憶體滿載 Golang中有完整的GC機制，可以完整且快速掃描當前程序不需要使用的 對象 或 變量 並回收內存使用再也不需要開發人員主動去管理內存 開發人員可專注業務實現，降低負擔 只需使用new方法 分配內存，完全不用擔心釋放問題","text":"特性 是現今雲計算時代的C語言 可直接編譯不依賴其他的庫(library) 為靜態語言，執行效率高 垃圾回收C/C++因為給予程序員較自由的內存管理權限，但申請內存空間要是忘記釋放會造成內存洩漏導致記憶體滿載 Golang中有完整的GC機制，可以完整且快速掃描當前程序不需要使用的 對象 或 變量 並回收內存使用再也不需要開發人員主動去管理內存 開發人員可專注業務實現，降低負擔 只需使用new方法 分配內存，完全不用擔心釋放問題 天然併發 (Golang就是多核時代下全新的併發性語言) 從語言層面支持併發，非常簡單 goroutine屬於輕量級線程，創建上萬個線程成為可能 基於CSP (Communicating Sequential Process；通信序列進程)模型實現 —-&gt; goroutine + channel 每個goroutine之間是透過channel(管道)進行通信 每個goroutine都是一個可獨立執行且可調度的執行單位 學習資料 Go語言官網：https://golang.org Go中文社區: https://studygolang.com Go中文在線文檔：https://studygolang.com/pkgdoc (原版官方中文文檔翻譯) 簡單goroutine範例1234567891011121314151617package mainimport ( \"fmt\" \"time\" )func printnum(a int)&#123; fmt.Println(a)&#125;func main()&#123; for i:=0;i&lt;10;i++ &#123; go printnum(i) //[1] &#125; time.Sleep(time.Second) //[2]&#125; [1] 使用關鍵字go即可調用goroutine達到併發的效果[2] sleep用意在於 main本身也是一個進程，在創建線程的過程中並不會理會其他子線程的執行狀況仍會繼續往下執行，可能會造成主進程執行完畢，但子進程仍還在執行而導致結果不符合預期，故目的是為了等待子線程也都執行完畢，主線程才繼續執行 result123456789101034265789 可以看到輸出為無序的打印0-9所有數字，表示線程之間可單獨調度執行，證明為併發執行如果不為併發執行應該是有序的0-9 管道(channel) 管道，類似unix/linux中的pipe 或是 | 進程之間的資源是隔離且彼此獨立，因此想實現通訊處理，就必須透過管道來實現 所有進程都能訪問管道，因此A進程可將數據放入管道中，由B進程提取實現通信 多個goroutine之間通過channel進行通信 支持任何類型 數據先進先出 簡單管道範例12345678910111213141516package mainimport \"fmt\"func pipe_test()&#123; pipe := make(chan int,3) //[1] pipe &lt;- 1 //[2] pipe &lt;- 2 pipe &lt;- 3 var t int t =&lt;- pipe //[3] fmt.Println(t) pipe &lt;- 4 //[4]&#125; [1] 分配一個內存空間用於創建(make)管道(chan)，管道容量為3，為int類型 等同於12var pipe chan intpipe = make(chan int,3) 管道內只能放3個int類型的數據 存放的數據超過容量值會阻塞，並等待消耗後存入數據 如在編譯時檢測到有阻塞且無法解決，會拋出deadlock錯誤 [2] 透過 &lt;- 將右邊的數據存放至管道中 [3] 透過 =&lt;- 從右邊的管道取值賦給左邊的變量 [4] 管道pipe空出一個位置，可允許數值在繼續存入 result11 多返回值一個函數可以返回多個值 簡單多返回值範例123456789101112131415package mainimport \"fmt\"func calc (a,b int)(int,int)&#123; //[1] sum := a+b avg := (a+b)/2 return sum,avg //[1]&#125;func main()&#123; sum,avg := calc(10,20) //[2] fmt.Println(\"sum of a and b =\", sum) fmt.Println(\"avg of a and b =\", avg)&#125; [1] 返回多個值可在參數後面使用(返回值1的類型,返回值2的類型)來獲取多個返回值,return多個返回值之間用,隔開[2] 使用多個變量來接收多個返回值 result12sum of a and b = 30avg of a and b = 15 將用不到的返回值忽略在上一章提到在Go中定義的變量名在腳本中沒有被使用，編譯時會報錯，必須刪除其變量，才能正常編譯但是函數又有多個返回值該怎辦？可用_ (下劃線) 忽略掉以上述代碼為例，要是用不到avg值則代碼改寫如下1234func main()&#123; sum,_ := calc(10,20) //[2] fmt.Println(\"sum of a and b =\", sum)&#125; 可成功編譯不會報錯1sum of a and b = 30","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"}]},{"title":"Go初識-day1(開發環境及簡易定義函數及變量)","slug":"GO_enviroment","date":"2018-03-03T16:00:00.000Z","updated":"2019-01-14T17:03:56.000Z","comments":true,"path":"2018/03/04/GO_enviroment/","link":"","permalink":"http://www.taroballz.com/2018/03/04/GO_enviroment/","excerpt":"開發環境搭建 網址：https://golang.org/dl 根據操作系統選擇對應Golang的安裝包 IDE選用JetBrains的GoLand 要是跳出GOPATH is empty的情況則增加新專案的src目錄的上一層資料夾 新建project 父級目錄/src/ —-&gt;code文件統一放在src目錄底下","text":"開發環境搭建 網址：https://golang.org/dl 根據操作系統選擇對應Golang的安裝包 IDE選用JetBrains的GoLand 要是跳出GOPATH is empty的情況則增加新專案的src目錄的上一層資料夾 新建project 父級目錄/src/ —-&gt;code文件統一放在src目錄底下 認識go語言 go語言是針對其他語言的痛點進行設計 加入併發編程原生支持(天然併發) 為大數據，微服務，並發而生的同用編程語言 項目轉型的首選語言 沒有對象，沒有繼承多態，沒有泛型，沒有try/catch 有接口，函數式編程，CSP併發模型(goroutine + channel) introduction Go語言與Python語言非常類似，一個文件代表一個包(package) Go語言所有的庫文件都以包為組合單位，所以皆須導入包名(package name)才能使用 Go定義變量必須要有明確的類型與c語言同屬於強類型語言，才可進行靜態編譯，運行效率高 Go中可不用 ; (分號) 結尾 —-&gt;Go編譯時會自動加 分號 實現hello world123456789package main /*說明其為package，若希望編譯完為 可執行文件 package name必須為main 若只是單純的 庫文件，則包名可以自定義*/import( \"fmt\" // 將\"字符串格式化輸入輸出\"的package -- \"fmt\"系統庫 使用import導入 )func main()&#123; //main函數為 \"入口函數\" (與上面的包名\"不一樣\")，程序執行時皆由main函數開始執行，且左大括號必須和函數名同一行 fmt.Println(\"Hello world!\") //調用函數的格式為 \"庫文件.函數(參數)\" [1]&#125; [1] 調用函數，大部分都需要導入包(package)文件 go語言以包(package)作為管理單位 每個文件必須先聲明包 每個程序必須有一個main包 運行程序cmd切換到go文件所在的目錄下使用 go run 命令運行.go腳本利用go run命令執行.go腳本不需要編譯 12&gt; go run helloworld.go Hello world! 使用go run命令時，要將main函數有用到的函數全部加載進去，函數有可能存在別的文件中，因此就必須go run多個文件 1&gt; go run main.go hello.go 調適工具delve安裝於cmd底下執行1go get github.com/derekparker/delve/cmd/dlv 定義變量var 變量名 類型example:1var I_am_int_var int 定義函數並調用 定義函數必須以func開頭 格式 12345func 函數名(參數a 類型, 參數b 類型) 函數返回的類型 &#123; var 返回變量名 類型 (運算) return 返回變量名&#125; 左大括號{ 必定要在func函數定義的最後面 不能換行 example:123456789101112131415package mainimport \"fmt\"func add (a int, b int) int &#123; var sum int sum = a + b return sum&#125;func main() &#123; var c int c = add(100, 200) fmt.Println(\"100+200=\", c)&#125; result:1100+200= 300","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/categories/Golang/"}],"tags":[{"name":"2018","slug":"2018","permalink":"http://www.taroballz.com/tags/2018/"},{"name":"Golang","slug":"Golang","permalink":"http://www.taroballz.com/tags/Golang/"}]},{"title":"Python模塊-協程(yield,greenlet,gevent)","slug":"gevent","date":"2018-01-16T16:00:00.000Z","updated":"2018-01-17T12:00:12.000Z","comments":true,"path":"2018/01/17/gevent/","link":"","permalink":"http://www.taroballz.com/2018/01/17/gevent/","excerpt":"Preface: 不管是線程(threading)或是進程(multiprocessing)都為一種搶占資源(競爭式)的型式執行程序 資源消耗大，且CPU切換耗時 Introduction: 協程為單線程,因此不存在CPU線程之間的切換,效率高 協成為單線程，不存在GIL鎖，且數據取用相對安全 協程為單線程，併發次數幾近無限次，適合用於高併發處理","text":"Preface: 不管是線程(threading)或是進程(multiprocessing)都為一種搶占資源(競爭式)的型式執行程序 資源消耗大，且CPU切換耗時 Introduction: 協程為單線程,因此不存在CPU線程之間的切換,效率高 協成為單線程，不存在GIL鎖，且數據取用相對安全 協程為單線程，併發次數幾近無限次，適合用於高併發處理 Notice: 可利用多進程+協程實現CPU多核利用 要是協程中遇到阻塞的情況,因為單線程的原因會造成程序全阻塞 Usage:使用生成器的yield實現協程操作:傳統生產者消費者模型12345678910111213141516171819def buyer(name): print(name, \"來去準備購物囉！！！\") while True: buysomething = yield \"老闆！我要買這個\" print (\"買了一件東西 - %s\" % buysomething)def seller(thing): buyer_response = next(shopping_person) print(buyer_response) shopping_person.send(thing) print(\"謝謝光臨！商品重新上架 - %s\"%thing)if __name__ == \"__main__\": shopping_list = &#123;\"小華\":\"糖果\", \"小明\":\"餅乾\", \"小馬\":\"果汁\"&#125; for name,item in shopping_list.items(): shopping_person = buyer(name) # 創建生成器對象 sellsomething = seller( item ) 其結果如下123456789101112小華 來去準備購物囉！！！老闆！我要買這個買了一件東西 - 糖果謝謝光臨！商品重新上架 - 糖果小明 來去準備購物囉！！！老闆！我要買這個買了一件東西 - 餅乾謝謝光臨！商品重新上架 - 餅乾小馬 來去準備購物囉！！！老闆！我要買這個買了一件東西 - 果汁謝謝光臨！商品重新上架 - 果汁 yield可以記住函數執行到的位置再次調用next()或是send()就可以回到函數內部繼續往下執行 greenlet (python第3方支持協程模塊)須先安裝1pip install gevent 一般執行函數的情況1234567891011def function_1(): print(\"我是函數_1顯示的第1行\") print(\"我是函數_1顯示的第2行\")def function_2(): print(\"我是函數_2顯示的第1行\") print(\"我是函數_2顯示的第2行\")if __name__ == \"__main__\": function_1() function_2() 結果如下所示1234我是函數_1顯示的第1行我是函數_1顯示的第2行我是函數_2顯示的第1行我是函數_2顯示的第2行 使用greenlet進行函式間的切換1234567891011121314151617from greenlet import greenletdef function_1(): print(\"我是函數_1顯示的第1行\") greenlet_test2.switch() print(\"我是函數_1顯示的第2行\") greenlet_test2.switch()def function_2(): print(\"我是函數_2顯示的第1行\") greenlet_test1.switch() print(\"我是函數_2顯示的第2行\")if __name__ == \"__main__\": greenlet_test1 = greenlet(function_1) greenlet_test2 = greenlet(function_2) greenlet_test1.switch() 其結果如下1234我是函數_1顯示的第1行我是函數_2顯示的第1行我是函數_1顯示的第2行我是函數_2顯示的第2行 由上述我們可以知道greenlet中的switch方法類似生成器中的next()或是send()方法可來回的在函數之間進行執行順序的切換 協程中的切換是指執行順序的切換而非CPU的切換 Gevent (python第3方支持協程模塊)透過gevent實現程序併發效果123456789101112131415161718192021import geventdef fun_1(): print(\"開始執行fun_1\") gevent.sleep() print(\"仍在執行fun_1\") gevent.sleep(1) print(\"結束fun_1執行\")def fun_2(): print(\"開始執行fun_2\") gevent.sleep() print(\"仍在執行fun_2\") gevent.sleep(2) print(\"結束fun_2執行\")if __name__ == \"__main__\": g1 = gevent.spawn(fun_1) #創造一個fun_1的gevent物件並啟用此物件 g2 = gevent.spawn(fun_2) g1.join() g2.join() 其結果為123456開始執行fun_1開始執行fun_2仍在執行fun_1仍在執行fun_2結束fun_1執行結束fun_2執行 gevent.sleep()就是用做模擬IO阻塞的情況,亦是交出自己的線程控制權在其他函式面臨阻塞時進行切換到其他函式繼續執行藉此提高整個程序的執行效率 應用於requests庫可以看一下如果使用一般的方式進行網頁抓取需要多少時間123456789101112131415161718192021import requestsimport timedef GET_url(url): status = requests.get(url) data = status.text print(\"GET %s status:%s &amp; length:%d\"%(url,status,len(data)))if __name__ == \"__main__\": start = time.time() url_list = ['http://www.taobao.com', \"http://shopee.tw/\", \"https://www.autobuy.tw/\", 'https://github.com', 'https://tw.yahoo.com', 'http://www.python.org'] for url in url_list: GET_url(url) print(\"spent time: %d sec\"%(time.time()-start)) 結果如下1234567GET http://www.taobao.com status:&lt;Response [200]&gt; &amp; length:237961GET http://shopee.tw/ status:&lt;Response [200]&gt; &amp; length:78523GET https://www.autobuy.tw/ status:&lt;Response [200]&gt; &amp; length:107359GET https://github.com status:&lt;Response [200]&gt; &amp; length:52086GET https://tw.yahoo.com status:&lt;Response [200]&gt; &amp; length:443617GET http://www.python.org status:&lt;Response [200]&gt; &amp; length:48940spent time: 14 sec 若使用gevent進行切換1234567891011121314151617181920import requestsimport geventimport timedef GET_url(url): status = requests.get(url) data = status.text print(\"GET %s status:%s &amp; length:%d\"%(url,status,len(data)))if __name__ == \"__main__\": start = time.time() gevent.joinall([ gevent.spawn(GET_url,'http://www.taobao.com'), gevent.spawn(GET_url,\"https://shopee.tw/\"), gevent.spawn(GET_url,\"https://www.autobuy.tw/\"), gevent.spawn(GET_url, 'https://github.com'), gevent.spawn(GET_url, 'https://tw.yahoo.com'), gevent.spawn(GET_url, 'http://www.python.org'), ]) print(\"spent time: %d sec\"%(time.time()-start)) spawn的第一個參數為函數名,第二個參數為函數所需的參數 結果如下1234567GET http://www.taobao.com status:&lt;Response [200]&gt; &amp; length:237961GET https://shopee.tw/ status:&lt;Response [200]&gt; &amp; length:78523GET https://www.autobuy.tw/ status:&lt;Response [200]&gt; &amp; length:106504GET https://github.com status:&lt;Response [200]&gt; &amp; length:52084GET https://tw.yahoo.com status:&lt;Response [200]&gt; &amp; length:447471GET http://www.python.org status:&lt;Response [200]&gt; &amp; length:48940spent time: 4 sec 在windows作業系統上可添加以下代碼使效果更為顯著12from gevent import monkeymonkey.patch_all() Reference:https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001407503089986d175822da68d4d6685fbe849a0e0ca35000http://www.cnblogs.com/alex3714/articles/5248247.html","categories":[{"name":"Python模塊","slug":"Python模塊","permalink":"http://www.taroballz.com/categories/Python模塊/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"協程","slug":"協程","permalink":"http://www.taroballz.com/tags/協程/"},{"name":"產生器","slug":"產生器","permalink":"http://www.taroballz.com/tags/產生器/"}]},{"title":"Python模塊-進程間的通信(Queue,Pipe)與數據共享(Manager)","slug":"processing_communcation","date":"2018-01-10T16:00:00.000Z","updated":"2018-12-02T17:39:48.000Z","comments":true,"path":"2018/01/11/processing_communcation/","link":"","permalink":"http://www.taroballz.com/2018/01/11/processing_communcation/","excerpt":"Introduction: 進程之間互相獨立，預設為不能共享數據 透過multiprocess模塊中的Pipe及Queue實現不同進程之間的通信 Queue(隊列)： 先進來的先出去，後進來的後出去 透過Manager實現進程之間的數據共享","text":"Introduction: 進程之間互相獨立，預設為不能共享數據 透過multiprocess模塊中的Pipe及Queue實現不同進程之間的通信 Queue(隊列)： 先進來的先出去，後進來的後出去 透過Manager實現進程之間的數據共享 Notice: 使用queue.Queue()調用的方法為線程隊列不適用於進程間的通信 Usage:Queue :123456789101112131415161718from multiprocessing import Process,Queuedef func(q,name): #以參數的方式將對列物件以參數型式導入子進程 q.put('My Process_name is %s and put the data to the id %d queue'%(name,id(q))) if __name__ == \"__main__\": q = Queue() #於主進程創建隊列物件 process_list=[] print(\"main queue id: %d\"%id(q)) for i in range(3): proc = Process(target=func,args=(q,'Process-%d'%i)) process_list.append(proc) proc.start() print(q.get()) #往管道中取數據 print(q.get()) print(q.get()) for each_process in process_list: each_process.join() Queue()參數可填入管道的長度 Queue(3)表示創建能存三筆資料的管道物件 創建的Queue物件可放置任意數據類型 通過Queue.get()取數據 先put的先取出，後put的後取出 要是Queue為空的情況下，還執意get的話，會堵塞到有數據可取出為止 可使用Queue.get_nowait()方法，要是堵塞了會直接報錯 其結果如下1234main queue id: 52342000My Process_name is Process-1 and put the data to the id 64566512 queueMy Process_name is Process-0 and put the data to the id 43398512 queueMy Process_name is Process-2 and put the data to the id 61551856 queue 從上面執行結果可知道我們所創建的Queue物件似乎為一個copy的對象並指向不同RAM地址貌似不是對同一個隊列進行操作但是從主進程get()的結果卻發現的確是對同一隊列的資料進行操作，原因應為copy後的隊列內部進行了pickle的序列化及反序列化的操作 判斷Queue是否為滿(full)或空(empty)123Queue.full() #判斷管道是否為滿Queue.empty() #判斷管道是否為空 返回bool值 Pipe (類似socket通信)12345678910111213141516171819from multiprocessing import Process,Pipeimport osdef func(conn): conn.send(\"Hi I'm your subprocess. My ID is %d\"%os.getpid()) print(\"ID %d receive main_process message: \"%os.getpid(),conn.recv()) conn.close() if __name__ == \"__main__\": main_conn , sub_conn = Pipe() #使用Pipe()函數同時建立主進程及自進程兩個通信的物件 processlist=[] for i in range(2): proc = Process(target=func,args=(sub_conn,)) processlist.append(proc) proc.start() print(\"I'm mainprocess, I receive my sub_process message: \",main_conn.recv()) main_conn.send(\"Remember I'm your Master\") for each_process in processlist: each_process.join() 其結果如下1234I&apos;m mainprocess, I receive my sub_process message: Hi I&apos;m your subprocess. My ID is 8424ID 8424 receive main_process message: Remember I&apos;m your MasterI&apos;m mainprocess, I receive my sub_process message: Hi I&apos;m your subprocess. My ID is 13468ID 13468 receive main_process message: Remember I&apos;m your Master Manager12345678910111213141516171819202122from multiprocessing import Process,Managerdef func(dic,lis,n): #對字典及列表進行操作 dic[\"Process_%s\"%n] = \"1\" dic['2'] = 2 dic[0.25] = None lis.append(n)if __name__ == \"__main__\": with Manager() as manager: #創建一個Manager()的物件 dic = manager.dict() #透過Manager()物件創建一個空字典 此字典進程之間可以共享 lis = manager.list(range(5)) #透過Manager()物件創建一個含0-5數字的列表 此列表進程之間可以共享 process_list = [] for i in range(10): proc = Process(target=func, args=(dic,lis,i)) proc.start() process_list.append(proc) for each_process in process_list: each_process.join() print(dic) print(lis) 其結果為12&#123;0.25: None, &apos;Process_9&apos;: &apos;1&apos;, &apos;2&apos;: 2, &apos;Process_8&apos;: &apos;1&apos;, &apos;Process_4&apos;: &apos;1&apos;, &apos;Process_0&apos;: &apos;1&apos;, &apos;Process_7&apos;: &apos;1&apos;, &apos;Process_2&apos;: &apos;1&apos;, &apos;Process_6&apos;: &apos;1&apos;, &apos;Process_1&apos;: &apos;1&apos;, &apos;Process_3&apos;: &apos;1&apos;, &apos;Process_5&apos;: &apos;1&apos;&#125;[0, 1, 2, 3, 4, 0, 1, 2, 3, 6, 5, 4, 8, 7, 9] 我們可以發現使用Manager各個進程是對同一個列表及字典進行操作 Reference:http://www.cnblogs.com/yuanchenqi/articles/5745958.html","categories":[{"name":"Python模塊","slug":"Python模塊","permalink":"http://www.taroballz.com/categories/Python模塊/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"多進程","slug":"多進程","permalink":"http://www.taroballz.com/tags/多進程/"}]},{"title":"Python模塊-multiprocessing多進程","slug":"multiprocessing","date":"2018-01-08T16:00:00.000Z","updated":"2018-12-02T10:59:33.000Z","comments":true,"path":"2018/01/09/multiprocessing/","link":"","permalink":"http://www.taroballz.com/2018/01/09/multiprocessing/","excerpt":"Preface: Python中同時間一個進程只能有一個線程通過GIL交給其中一個CPU執行 同時間要完成多任務能透過創建多進程(multiprocessing)交給不同CPU執行 進程： 程序是未運行的EXE檔：其還沒運行之前，無法調度系統的資源(內存、設備如滑鼠鍵盤等) 進程是運行起來的程序檔案：其能調度系統資源，稱為進程 操作系統分配資源的基本單位 Introduction: multiprocessing是Python中多進程的管理模塊 其使用方法與多線程(threading)模塊類似,只是環境不同而已 創建進程所耗費的資源較創建線程大","text":"Preface: Python中同時間一個進程只能有一個線程通過GIL交給其中一個CPU執行 同時間要完成多任務能透過創建多進程(multiprocessing)交給不同CPU執行 進程： 程序是未運行的EXE檔：其還沒運行之前，無法調度系統的資源(內存、設備如滑鼠鍵盤等) 進程是運行起來的程序檔案：其能調度系統資源，稱為進程 操作系統分配資源的基本單位 Introduction: multiprocessing是Python中多進程的管理模塊 其使用方法與多線程(threading)模塊類似,只是環境不同而已 創建進程所耗費的資源較創建線程大 Notice: 進程結束時,必須對每個進程物件調用join()方法，相當於wait,否則進程將成為僵屍進程 進程之間完全獨立且不能共享數據,除非透過第三方進行交流,例如Queue,Pipe (優先考慮) 進程之間應避免共享的資源,只要透過第三方進行交流，必定會降低執行程序的效率 windows系統下，如想啟動一個子進程,與進程相關的語句要寫在if __name__ == &quot;__main__&quot;之下 Usage:Example I: (直接調用)1234567891011121314151617from multiprocessing import Processdef func(name): print('My name is %s'%name) if __name__ == \"__main__\": process_list = [] for i in range(3): pro = Process(target=func, args=('taroballz',)) # 創建一個進程物件 process_list.append(pro) pro.start() # 進程開始工作 for each_process in process_list: each_process.join() #等待子進程們回到主進程 print('The end of mulitprocessing performance') 根據以上的code可表示創建了三個子進程，加上主進程共有四個進程於四個CPU上執行不同工作 要是執行的進程數大於CPU本身的執行緒數，CPU會使用切換的方式來完成多進程運作 Example II: (繼承類調用)12345678910111213141516171819from multiprocessing import Processclass New_Process(Process): def __init__(self): super(New_Process,self).__init__() def run(self): #將進程要執行的任務寫在run方法中 print(\"My Process_name is %s\"%self.name) if __name__ == \"__main__\": process_list=[] for i in range(3): pro = New_Process() process_list.append(pro) pro.start() for each_process in process_list: each_process.join() print('The end of mulitprocessing performance') Relation between Processes:12345678910111213141516from multiprocessing import Processimport osdef show_process_info(processname): print(processname) print(\"process __name__ is\",__name__) print(\"parents process ID(PPID): \",os.getppid()) print(\"self process ID(PID): \",os.getpid(),'\\n')if __name__ == \"__main__\": show_process_info('main_process') for i in range(2): proc = Process(target=show_process_info,args=(\"Process-%d\"%i, )) proc.start() proc.join() print(\"The End ! !\") 執行結果如下所示12345678910111213141516main_processprocess __name__ is __main__parents process ID(PPID): 3460self process ID(PID): 13512 Process-0process __name__ is __mp_main__parents process ID(PPID): 13512self process ID(PID): 13636 Process-1process __name__ is __mp_main__parents process ID(PPID): 13512self process ID(PID): 11412 The End ! ! 從結果我們可以知道新創建的子進程都為主進程所創造 且 隸屬於原本的主進程(兩個子進程的PPID皆屬於主進程自身的PID) Reference:http://www.cnblogs.com/yuanchenqi/articles/5745958.html","categories":[{"name":"Python模塊","slug":"Python模塊","permalink":"http://www.taroballz.com/categories/Python模塊/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"多進程","slug":"多進程","permalink":"http://www.taroballz.com/tags/多進程/"}]},{"title":"Python基礎-異常處理","slug":"Exception","date":"2018-01-07T16:00:00.000Z","updated":"2018-04-03T18:57:13.000Z","comments":true,"path":"2018/01/08/Exception/","link":"","permalink":"http://www.taroballz.com/2018/01/08/Exception/","excerpt":"Introduction:可自訂義當程序出錯時，自動執行其他程序或做其他處理 Example:1234567try: #代碼塊，邏輯 inp = input(\"請輸入序號\") i = int(inp)except Exception as e: #上述代碼塊如出錯，自動執行當前塊的內容 print(\"發生錯誤： \",e) i = 1print(i)","text":"Introduction:可自訂義當程序出錯時，自動執行其他程序或做其他處理 Example:1234567try: #代碼塊，邏輯 inp = input(\"請輸入序號\") i = int(inp)except Exception as e: #上述代碼塊如出錯，自動執行當前塊的內容 print(\"發生錯誤： \",e) i = 1print(i) 要是try代碼塊中的代碼沒有出錯則會繼續執行 要是try代碼塊出錯則會創建Exception類(class)對象，對象名為e，e中封裝了出錯的錯誤訊息 Types of Error:任何的錯誤訊息都會有一個對象來表示此錯誤訊息為何 Exception (BOSS級) 可捕獲任何異常訊息IndexErrorValueErrorAttributeErrorImportErrorIndentationError ….等等 Application:可同時捕獲多種不同的錯誤，讓其進行不同的程序(錯誤的細項放前面執行，最後才用Exception)12345678try: int(\"w3r\")except IndexError as e: print(\"發生錯誤： \",'IndexError',e)except ValueError as e: print(\"發生錯誤： \",'ValueError',e)except Exception as e: print(\"發生錯誤： \",'Exception',e) Usage:else在except之後鍵入else: 要是try代碼塊中執行代碼出錯 → 會捕捉錯誤訊息並執行except代碼塊中的程序 要是try中代碼塊中的代碼執行沒有出錯 → 當try代碼塊中代碼執行完成時則會執行else代碼塊中的程序 12345678910try: int(\"w3r\")except IndexError as e: print(\"發生錯誤： \",'IndexError',e)except ValueError as e: print(\"發生錯誤： \",'ValueError',e)except Exception as e: print(\"發生錯誤： \",'Exception',e)else: print(\"else\",\"執行代碼並無發生錯誤\") finally最後不管有無出錯皆會執行finally代碼塊中的代碼123456789101112try: int(\"w3r\")except IndexError as e: print(\"發生錯誤： \",'IndexError',e)except ValueError as e: print(\"發生錯誤： \",'ValueError',e)except Exception as e: print(\"發生錯誤： \",'Exception',e)else: print(\"else\",\"執行代碼並無發生錯誤\")finally: print(\"finally:....\",\"不管最後有沒有出錯都要執行我\") Advanced :主動觸發異常上述所說都是由Python內部解釋器解釋時所觸發的異常我們也可以讓程序運行時主動觸發異常 → 使用raise1234try: raise Exception(\"出現異常\")except Exception as e: print(e) 用於嵌套函數中某函數執行失敗並retrun False時拋出異常，並讓日誌紀錄 不必在另外寫一個函數用於紀錄日誌 只需將出錯訊息進行raise Exception 於except Exception代碼塊中連同其他出錯訊息一起記錄 自訂義異常(編寫一個類)123456789class self_definitionError(Exception): def __init__(self, msg): self.message = msg def __str__(self): return self.messagetry: raise self_definition('自訂義錯誤')except self_definitionError as e: print(e) #使用print方法，則會調用e對象的__str__()方法，獲取值後返回 assert(斷言)assert 後的條件成立則繼續執行，條件不成立時 程序報錯為AssertionError用於強制用戶服從，不服從則報錯，可用Exception捕獲異常，但一般不會這麼做 example I條件成立，沒有發生異常12assert 1 == 1print('OK') 顯示:1OK example II條件不成立，發生AssertionError異常12assert 1 == 2print('OK') 顯示:123Traceback(most recent call last): assert 1 == 2AssertionError conclusion多線程會使用到此方法，通常用在寫好的程序中前面加入assert條件判斷欲使用程序必須滿足assert後面的條件才能運行類似if else","categories":[{"name":"Python基礎","slug":"Python基礎","permalink":"http://www.taroballz.com/categories/Python基礎/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"}]},{"title":"被動信息蒐集-簡介","slug":"information_gather","date":"2018-01-06T16:00:00.000Z","updated":"2018-01-07T16:50:52.000Z","comments":true,"path":"2018/01/07/information_gather/","link":"","permalink":"http://www.taroballz.com/2018/01/07/information_gather/","excerpt":"被動信息蒐集 透過公開渠道（互聯網）獲得信息 不與目標系統之間產生直接交互 通常不會留下痕跡","text":"被動信息蒐集 透過公開渠道（互聯網）獲得信息 不與目標系統之間產生直接交互 通常不會留下痕跡 管道 搜索引擎 媒體公關 公開網站 收集內容 IP地址 域名及whois信息 郵件地址 文檔圖片數據 公司組織架構及地址 聯繫電話/傳真號碼 目標系統使用之技術架構 公開商業信息 信息用途 描述目標 發現目標公司系統版本及開放服務 進行社交工程學攻擊 嘗試突破物理（管理架構）缺口","categories":[{"name":"被動信息蒐集","slug":"被動信息蒐集","permalink":"http://www.taroballz.com/categories/被動信息蒐集/"}],"tags":[{"name":"被動信息蒐集","slug":"被動信息蒐集","permalink":"http://www.taroballz.com/tags/被動信息蒐集/"}]},{"title":"Python模塊-Queue隊列","slug":"Queue","date":"2018-01-04T16:00:00.000Z","updated":"2018-01-07T16:50:52.000Z","comments":true,"path":"2018/01/05/Queue/","link":"","permalink":"http://www.taroballz.com/2018/01/05/Queue/","excerpt":"Introduction: queue是python中的標準庫，俗稱隊列，可直接import使用 隊列(queue)為一種數據結構，用於存儲數據(類似列表及字典) 列表及字典不適合用於多線程中使用，在多個線程中，數據是共享的，進行數據交換的時候，不能夠保證數據的安全性和一致性，我們希望多個線程不要執行同一個任務，但使用列表或是字典就容易發生不同線程取到同一組數據或是執行同一個任務的詬病 隊列可以完美解決線程間的數據交換，保證線程間數據的安全性和一致性","text":"Introduction: queue是python中的標準庫，俗稱隊列，可直接import使用 隊列(queue)為一種數據結構，用於存儲數據(類似列表及字典) 列表及字典不適合用於多線程中使用，在多個線程中，數據是共享的，進行數據交換的時候，不能夠保證數據的安全性和一致性，我們希望多個線程不要執行同一個任務，但使用列表或是字典就容易發生不同線程取到同一組數據或是執行同一個任務的詬病 隊列可以完美解決線程間的數據交換，保證線程間數據的安全性和一致性 Types: 先存入的數據會最先被取出(先進先出,FIFO)class queue.Queue(maxsize) 後存入的數據會最先被取出(後進先出,LIFO)class queue.LifoQueue(maxsize) 優先級隊列，级别越低越先出来class queue.PriorityQueue(maxsize) Usage:創建隊列物件12import queueq_obj = queue.Queue(maxsize) maxsize 填入可存儲數據的長度，若不填入則為無限大 插入數據將數據寫入隊列queue.put(item,block,timeout) block決定是否等待堵塞，預設為True timeout為等待時間 123q_obj.put('data')q_obj.put('data1')q_obj.put('data2') 要是輸入的數據超過maxsize的限定值，預設會等待阻塞(block=1)，要是將block手動設為0且又超過maxsize的限定值將會報錯並提示隊列已滿 q_obj.put(&#39;data&#39;,False)相當於q_obj.put_nowait() 拿取數據使用get拿取隊列中的數據queue.get(item,block,timeout) 1print(q_obj.get()) 1data 1print(q_obj.get()) 1data1 1print(q_obj.get()) 1data2 要是queue物件中已無存儲的數據仍進行拿取(get)，預設會等待阻塞(block=1)，要是將block手動設為0執意拿取空隊列中的數據將會報錯並提示隊列已空 q_obj.get(False)相當於q_obj.get_nowait() 返回當前隊列的大小1q_obj.qsize() 如果隊列滿了，返回True,反之False(queue.full 與 maxsize 大小對應)1q_obj.full() 如果隊列為空，返回True,反之False1q_obj.empty() 在完成工作之後，queue.task_done函數向任務已經完成的隊列發送一個信號1q_obj.task_done() 等到隊列為空，再執行別的操作1q_obj.join() Reference: http://www.cnblogs.com/CongZhang/p/5274486.htmlhttp://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p03_communicating_between_threads.html","categories":[{"name":"Python模塊","slug":"Python模塊","permalink":"http://www.taroballz.com/categories/Python模塊/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.taroballz.com/tags/Python/"},{"name":"多線程","slug":"多線程","permalink":"http://www.taroballz.com/tags/多線程/"}]}]}